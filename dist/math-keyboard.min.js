!function(I){var g={};function n(t){if(g[t])return g[t].exports;var c=g[t]={i:t,l:!1,exports:{}};return I[t].call(c.exports,c,c.exports,n),c.l=!0,c.exports}n.m=I,n.c=g,n.d=function(I,g,t){n.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:t})},n.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},n.t=function(I,g){if(1&g&&(I=n(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var c in I)n.d(t,c,function(g){return I[g]}.bind(null,c));return t},n.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return n.d(g,"a",g),g},n.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},n.p="./dist/",n(n.s=56)}([function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"default\", function() { return /* binding */ addStylesClient; });\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzliYmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz80OTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(50);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.11\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (false) { var repeat, classify, classifyRE, hasConsole; }\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (false) {}\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {}\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (false\n  ) {}\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     false && false;\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (false\n  ) {}\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     false && false;\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       false && false;\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n     false && false;\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (false) {}\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"production\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {}\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (false) {}\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (false) {}\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {}\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {}\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    false\n  ) {}\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {}\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (false) {}\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) { var perf; }\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n       false && false;\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) { var keyInLowerCase; }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {} else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (false) {}\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (false) {}\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n       false && false;\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       false && false;\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (false) {}\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (false) {}\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {}\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n     false && false;\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {}\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (false) {}\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (false) {} else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {} else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {}\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n       false && false;\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (undefined)\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) { var lowerCaseEvent; }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {}\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {} else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {}\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {}\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {}\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {}\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (false) {}\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? undefined\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n       false && false;\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) { var hyphenatedKey; } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n     false && false;\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {}\n    if (props && hasOwn(props, key)) {\n       false && false;\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {}\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {}\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (false) {}\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (false) {}\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {}\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {}\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {} else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {}\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (false\n  ) {}\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {}\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {}\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {}\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.11';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n       false && false;\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {}\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {}\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (false) {}\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (false) {}\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (false) {}\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (false) {}\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (false\n              ) {}\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (false\n              ) {}\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {}\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes([oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {}\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {}\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {}\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (false) { var binding, typeBinding, value$1; }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {}\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {}\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n     false && false;\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {}\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {}\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) { var name, opts; }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        false\n      ) {}\n    }\n    if (false\n    ) {}\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) { var res; }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) { var res; }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {}\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (false) {}\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {}\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:|^#/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (false) {}\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (false) {}\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (false) {}\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         false && false;\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (false) {}\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (false) {}\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (false) {}\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (false) {}\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (false) {}\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) { var parent, iterator; }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (false) {}\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {}\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {}\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (false) {}\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (false) {}\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (false) {}\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (false) {}\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (false) {}\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {}\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          false\n        ) {}\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (false) {}\n      }\n    } else {\n      // literal attribute\n      if (false) { var res; }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {}\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (false) {}\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n       false && false;\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (false\n  ) {}\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (false) {}\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (name === 'v-slot' || name[0] === '#') {\n            checkFunctionParameterExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stripped = exp.replace(stripStringRE, '');\n  var keywordMatch = stripped.match(unaryOperatorsRE);\n  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\nfunction checkFunctionParameterExpression (exp, text, warn, range) {\n  try {\n    new Function(exp, '');\n  } catch (e) {\n    warn(\n      \"invalid function parameter expression: \" + (e.message) + \" in\\n\\n\" +\n      \"    \" + exp + \"\\n\\n\" +\n      \"  Raw expression: \" + (text.trim()) + \"\\n\",\n      range\n    );\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (false) {}\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {}\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {}\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (false) { var leadingSpaceLength; }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (false) {}\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n     false && false;\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {}\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {}\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {}\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"production\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {}\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(2).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLGlEQXFGMUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFzRCxFQUFFLEVBSzNEO0FBQ0gsa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQyxFQUFFLHVCQWUxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQyxFQUFFLEVBUzFDO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQyxFQUFFLEVBRWpEO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFVBQVUsS0FBOEQsRUFBRSxFQUtuRTtBQUNQLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQXFDLElBQUksS0FHeEM7QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFxQyxJQUFJLEtBR3hDO0FBQ1AsS0FBSztBQUNMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLLFVBQVUsS0FBbUUsRUFBRSxFQU0vRTtBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGdFQUFnRTtBQUNyRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNEJBQTRCLCtCQUErQjtBQUMzRCw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQyxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxNQUFxQyxJQUFJLEtBSXhDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FDc0Q7QUFDNUQsSUFBSSxFQVFEO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUE0RSxFQUFFLEVBS2pGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLG9CQUFvQjtBQUN4QyxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7O0FBRXpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQU8xQztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFnRSxFQUFFLEVBT3JFO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUE2RCxFQUFFLEVBTWxFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLDJDQUEyQyw4QkFBOEIsRUFBRTs7QUFFaEY7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLE1BQU0sTUFBcUMsSUFBSSxLQUd4QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBcUM7QUFDckQscUJBQXFCLFNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSx1QkFXMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBbUUsRUFBRSxFQUl4RTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0EsUUFBUSxLQUFtRSxFQUFFLEVBSXhFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQ29CO0FBQzFCLElBQUksRUFFRDtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUE2QyxFQUFFLEVBRWxEOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSxLQUE2RCxFQUFFLEVBRWxFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDJCQUEyQixFQUFFO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyw0QkFBNEIsRUFBRTtBQUN4RSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsTUFBTSxLQUFxQyxFQUFFLEVBTTFDO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFZMUM7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXlELEVBQUUsRUFFOUQ7QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsS0FBcUMs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QUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QyxrQkFBa0I7QUFDMUQsS0FBSztBQUNMLHdDQUF3QywwQkFBMEI7QUFDbEUsS0FBSztBQUNMLHdDQUF3QyxpQkFBaUI7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlLEVBQUUsdUJBQXVCLFVBQVUsRUFBRTtBQUNwRjtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELDZDQUE2QztBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUE2QztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FDc0M7QUFDMUMsSUFBSSxFQU1EOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsR0FBRztBQUNILHlDQUF5QztBQUN6Qzs7QUFFQSxpQ0FBaUMsd0NBQXdDO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDLEVBQUUsRUFVMUM7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVLEtBQXFDLEVBQUUsRUFRakQ7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsNEJBQTRCO0FBQzVCO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixpRUFBaUU7QUFDekYsWUFBWSwwRkFBMEY7QUFDdEcsTUFBTSxLQUFLLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Qsc0JBQXNCLCtDQUErQztBQUNyRSxpREFBaUQ7O0FBRWpEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxzQ0FXMUM7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRCQUE0QixFQUFFO0FBQ2xGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtCQUErQixFQUFFO0FBQ3JGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBc0UsRUFBRSxFQUUzRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxRSxFQUFFLEVBRTFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxxQ0FBcUM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1Q0FBdUMsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksTUFBcUMsSUFBSSxLQUl4QztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsOEJBQThCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsdUNBQXVDOztBQUV6RSxxQ0FBcUMsMEJBQTBCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBNEQsRUFBRSxFQU1qRTs7QUFFTDs7QUFFQTtBQUNBLFFBQVEsS0FDNEM7QUFDcEQsTUFB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QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxVQUFVLEtBQXFDLEVBQUUsRUFNakQ7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsS0FBaUUsRUFBRSxFQU10RTtBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQWtELEVBQUUsRUFTdkQ7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLFFBQVEsS0FBNkQsRUFBRSxFQVFsRTtBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDLEVBQUUsRUFjMUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUMsRUFBRSxFQW9CMUM7QUFDVDtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLEtBQXFDLEVBQUUsRUFLakQ7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQStDLEVBQUUsRUFPcEQ7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUN5QjtBQUNuQyxVQUFVLEVBSUQ7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUF5RCxFQUFFLEVBRTlEO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLEtBQXFDLEVBQUUsWUFXMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QixFQUFFO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQSxNQUFNLEtBQ3NDO0FBQzVDLE1BQU0sRUFFRDtBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLE1BQXFDLElBQUksS0FFeEM7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBa0QsRUFBRSxFQUt2RDtBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQW1FLEVBQUUsRUFFeEU7O0FBRVA7QUFDQSwyQkFBMkIsWUFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLEtBQW1FLEVBQUUsRUFHeEU7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDREQUFHLEVBQUMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjYuMTFcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG52YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG52YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgLy8gb3JkZXJcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybigoXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBmb3Igd2VleCByZWN5Y2xlLWxpc3QgY2hpbGQgY29tcG9uZW50IHByb3BzXG4gICAgIShmYWxzZSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICB9XG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgaWYgKHZtKSB7XG4gICAgICB2YXIgY3VyID0gdm07XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxudmFyIHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICB2YXIgY291bnRlciA9IDE7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYygpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICByZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiByZXNbMF0uaXNDb21tZW50KSAvLyAjOTY1OFxuICAgICkgPyB1bmRlZmluZWRcbiAgICAgIDogcmVzXG4gIH07XG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gIGlmIChmbi5wcm94eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cblxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdXNlIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3Jcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgIHZhciBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgIHZhciB0aW1lclRpbWVvdXQgPSBudWxsXG5cbiAgICA7KG93bmVyKS4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKG93bmVycywgb3duZXIpOyB9KTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmcpO1xuICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuMTEnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMoW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIHZhciBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0sIHJhbmdlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBpc0R5bmFtaWNBcmcsXG4gIG1vZGlmaWVycyxcbiAgcmFuZ2Vcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3TmFtZTogcmF3TmFtZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgYXJnOiBhcmcsXG4gICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IChcIl9wKFwiICsgbmFtZSArIFwiLFxcXCJcIiArIHN5bWJvbCArIFwiXFxcIilcIilcbiAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm4sXG4gIHJhbmdlLFxuICBkeW5hbWljXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgZWwsXG4gIG5hbWVcbikge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbnZhciBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICApIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICB0aGlzJDEuX19wYXRjaF9fKFxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICB0aGlzJDEua2VwdCxcbiAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICk7XG4gICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMkMSwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rXFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXG4gICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgdmFyIHNsb3RCaW5kaW5nJDEgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZyQxKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJ2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIFwiICtcbiAgICAgICAgICAgICAgXCI8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XG4gICAgICAgIHZhciBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgIHZhciBuYW1lJDEgPSByZWYkMS5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyQxID0gcmVmJDEuZHluYW1pYztcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lJDE7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljJDE7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcbiAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICB2YXIgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICBpZiAoIW5hbWUpIHtcbiAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuXCIsXG4gICAgICAgIGJpbmRpbmdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxuICAgIC8vIGR5bmFtaWMgW25hbWVdXG4gICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAvLyBzdGF0aWMgbmFtZVxuICAgIDogeyBuYW1lOiAoXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpLCBkeW5hbWljOiBmYWxzZSB9XG59XG5cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIChcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXCJ2LWJpbmQ6XCIgKyBuYW1lICsgXCJcXFwiXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKTtcbiAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGh5cGhlbmF0ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcIlxcXCJ1cGRhdGU6XFxcIisoXCIgKyBuYW1lICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IFwiKFwiICsgKG1hcFsndi1iaW5kJ10pICsgXCIpLnR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbnZhciBmbkludm9rZVJFID0gL1xcKFteKV0qP1xcKTsqJC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgRGVsYCBmb3IgRGVsZXRlIGtleSBuYW1lLlxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmVcbikge1xuICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICB2YXIgc3RhdGljSGFuZGxlcnMgPSBcIlwiO1xuICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiX2QoXCIgKyBzdGF0aWNIYW5kbGVycyArIFwiLFtcIiArIChkeW5hbWljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIoJGV2ZW50KVwiKVxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCJcbiAgKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG5cblxuXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdGhpcy5wcmUgPSBmYWxzZTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pOyB9KSlcbiAgICA6IG51bGw7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdmFyIHN0cmlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oXG4gICAgICBcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgdmFyIHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoJDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmIChuID4gMCkge1xuICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICBuID4+Pj0gMTtcbiAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgc3RyICs9IHN0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG52YXIgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,exports){eval("/**\n * MathQuill v0.10.1               http://mathquill.com\n * by Han, Jeanine, and Mary  maintainers@mathquill.com\n *\n * This Source Code Form is subject to the terms of the\n * Mozilla Public License, v. 2.0. If a copy of the MPL\n * was not distributed with this file, You can obtain\n * one at http://mozilla.org/MPL/2.0/.\n */\n\n(function() {\n\nvar jQuery = window.jQuery,\n  undefined,\n  mqCmdId = 'mathquill-command-id',\n  mqBlockId = 'mathquill-block-id',\n  min = Math.min,\n  max = Math.max;\n\nfunction noop() {}\n\n/**\n * A utility higher-order function that makes defining variadic\n * functions more convenient by letting you essentially define functions\n * with the last argument as a splat, i.e. the last argument \"gathers up\"\n * remaining arguments to the function:\n *   var doStuff = variadic(function(first, rest) { return rest; });\n *   doStuff(1, 2, 3); // => [2, 3]\n */\nvar __slice = [].slice;\nfunction variadic(fn) {\n  var numFixedArgs = fn.length - 1;\n  return function() {\n    var args = __slice.call(arguments, 0, numFixedArgs);\n    var varArg = __slice.call(arguments, numFixedArgs);\n    return fn.apply(this, args.concat([ varArg ]));\n  };\n}\n\n/**\n * A utility higher-order function that makes combining object-oriented\n * programming and functional programming techniques more convenient:\n * given a method name and any number of arguments to be bound, returns\n * a function that calls it's first argument's method of that name (if\n * it exists) with the bound arguments and any additional arguments that\n * are passed:\n *   var sendMethod = send('method', 1, 2);\n *   var obj = { method: function() { return Array.apply(this, arguments); } };\n *   sendMethod(obj, 3, 4); // => [1, 2, 3, 4]\n *   // or more specifically,\n *   var obj2 = { method: function(one, two, three) { return one*two + three; } };\n *   sendMethod(obj2, 3); // => 5\n *   sendMethod(obj2, 4); // => 6\n */\nvar send = variadic(function(method, args) {\n  return variadic(function(obj, moreArgs) {\n    if (method in obj) return obj[method].apply(obj, args.concat(moreArgs));\n  });\n});\n\n/**\n * A utility higher-order function that creates \"implicit iterators\"\n * from \"generators\": given a function that takes in a sole argument,\n * a \"yield_\" function, that calls \"yield_\" repeatedly with an object as\n * a sole argument (presumably objects being iterated over), returns\n * a function that calls it's first argument on each of those objects\n * (if the first argument is a function, it is called repeatedly with\n * each object as the first argument, otherwise it is stringified and\n * the method of that name is called on each object (if such a method\n * exists)), passing along all additional arguments:\n *   var a = [\n *     { method: function(list) { list.push(1); } },\n *     { method: function(list) { list.push(2); } },\n *     { method: function(list) { list.push(3); } }\n *   ];\n *   a.each = iterator(function(yield_) {\n *     for (var i in this) yield_(this[i]);\n *   });\n *   var list = [];\n *   a.each('method', list);\n *   list; // => [1, 2, 3]\n *   // Note that the for-in loop will yield 'each', but 'each' maps to\n *   // the function object created by iterator() which does not have a\n *   // .method() method, so that just fails silently.\n */\nfunction iterator(generator) {\n  return variadic(function(fn, args) {\n    if (typeof fn !== 'function') fn = send(fn);\n    var yield_ = function(obj) { return fn.apply(obj, [ obj ].concat(args)); };\n    return generator.call(this, yield_);\n  });\n}\n\n/**\n * sugar to make defining lots of commands easier.\n * TODO: rethink this.\n */\nfunction bind(cons /*, args... */) {\n  var args = __slice.call(arguments, 1);\n  return function() {\n    return cons.apply(this, args);\n  };\n}\n\n/**\n * a development-only debug method.  This definition and all\n * calls to `pray` will be stripped from the minified\n * build of mathquill.\n *\n * This function must be called by name to be removed\n * at compile time.  Do not define another function\n * with the same name, and only call this function by\n * name.\n */\nfunction pray(message, cond) {\n  if (!cond) throw new Error('prayer failed: '+message);\n}\nvar P = (function(prototype, ownProperty, undefined) {\n  // helper functions that also help minification\n  function isObject(o) { return typeof o === 'object'; }\n  function isFunction(f) { return typeof f === 'function'; }\n\n  // used to extend the prototypes of superclasses (which might not\n  // have `.Bare`s)\n  function SuperclassBare() {}\n\n  return function P(_superclass /* = Object */, definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    }\n\n    // C is the class to be returned.\n    //\n    // It delegates to instantiating an instance of `Bare`, so that it\n    // will always return a new instance regardless of the calling\n    // context.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n    function C() {\n      var self = new Bare;\n      if (isFunction(self.init)) self.init.apply(self, arguments);\n      return self;\n    }\n\n    // C.Bare is a class with a noop constructor.  Its prototype is the\n    // same as C, so that instances of C.Bare are also instances of C.\n    // New objects can be allocated without initialization by calling\n    // `new MyClass.Bare`.\n    function Bare() {}\n    C.Bare = Bare;\n\n    // Set up the prototype of the new class.\n    var _super = SuperclassBare[prototype] = _superclass[prototype];\n    var proto = Bare[prototype] = C[prototype] = C.p = new SuperclassBare;\n\n    // other variables, as a minifier optimization\n    var extensions;\n\n\n    // set the constructor property on the prototype, for convenience\n    proto.constructor = C;\n\n    C.extend = function(def) { return P(C, def); }\n\n    return (C.open = function(def) {\n      extensions = {};\n\n      if (isFunction(def)) {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        extensions = def.call(C, proto, _super, C, _superclass);\n      }\n      else if (isObject(def)) {\n        // if you passed an object instead, we'll take it\n        extensions = def;\n      }\n\n      // ...and extend it\n      if (isObject(extensions)) {\n        for (var ext in extensions) {\n          if (ownProperty.call(extensions, ext)) {\n            proto[ext] = extensions[ext];\n          }\n        }\n      }\n\n      // if there's no init, we assume we're inheriting a non-pjs class, so\n      // we default to applying the superclass's constructor.\n      if (!isFunction(proto.init)) {\n        proto.init = _superclass;\n      }\n\n      return C;\n    })(definition);\n  }\n\n  // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n})('prototype', ({}).hasOwnProperty);\n/*************************************************\n * Base classes of edit tree-related objects\n *\n * Only doing tree node manipulation via these\n * adopt/ disown methods guarantees well-formedness\n * of the tree.\n ************************************************/\n\n// L = 'left'\n// R = 'right'\n//\n// the contract is that they can be used as object properties\n// and (-L) === R, and (-R) === L.\nvar L = -1;\nvar R = 1;\n\nfunction prayDirection(dir) {\n  pray('a direction was passed', dir === L || dir === R);\n}\n\n/**\n * Tiny extension of jQuery adding directionalized DOM manipulation methods.\n *\n * Funny how Pjs v3 almost just works with `jQuery.fn.init`.\n *\n * jQuery features that don't work on $:\n *   - jQuery.*, like jQuery.ajax, obviously (Pjs doesn't and shouldn't\n *                                            copy constructor properties)\n *\n *   - jQuery(function), the shortcut for `jQuery(document).ready(function)`,\n *     because `jQuery.fn.init` is idiosyncratic and Pjs doing, essentially,\n *     `jQuery.fn.init.apply(this, arguments)` isn't quite right, you need:\n *\n *       _.init = function(s, c) { jQuery.fn.init.call(this, s, c, $(document)); };\n *\n *     if you actually give a shit (really, don't bother),\n *     see https://github.com/jquery/jquery/blob/1.7.2/src/core.js#L889\n *\n *   - jQuery(selector), because jQuery translates that to\n *     `jQuery(document).find(selector)`, but Pjs doesn't (should it?) let\n *     you override the result of a constructor call\n *       + note that because of the jQuery(document) shortcut-ness, there's also\n *         the 3rd-argument-needs-to-be-`$(document)` thing above, but the fix\n *         for that (as can be seen above) is really easy. This problem requires\n *         a way more intrusive fix\n *\n * And that's it! Everything else just magically works because jQuery internally\n * uses `this.constructor()` everywhere (hence calling `$`), but never ever does\n * `this.constructor.find` or anything like that, always doing `jQuery.find`.\n */\nvar $ = P(jQuery, function(_) {\n  _.insDirOf = function(dir, el) {\n    return dir === L ?\n      this.insertBefore(el.first()) : this.insertAfter(el.last());\n  };\n  _.insAtDirEnd = function(dir, el) {\n    return dir === L ? this.prependTo(el) : this.appendTo(el);\n  };\n});\n\nvar Point = P(function(_) {\n  _.parent = 0;\n  _[L] = 0;\n  _[R] = 0;\n\n  _.init = function(parent, leftward, rightward) {\n    this.parent = parent;\n    this[L] = leftward;\n    this[R] = rightward;\n  };\n\n  this.copy = function(pt) {\n    return Point(pt.parent, pt[L], pt[R]);\n  };\n});\n\n/**\n * MathQuill virtual-DOM tree-node abstract base class\n */\nvar Node = P(function(_) {\n  _[L] = 0;\n  _[R] = 0\n  _.parent = 0;\n\n  var id = 0;\n  function uniqueNodeId() { return id += 1; }\n  this.byId = {};\n\n  _.init = function() {\n    this.id = uniqueNodeId();\n    Node.byId[this.id] = this;\n\n    this.ends = {};\n    this.ends[L] = 0;\n    this.ends[R] = 0;\n  };\n\n  _.dispose = function() { delete Node.byId[this.id]; };\n\n  _.toString = function() { return '{{ MathQuill Node #'+this.id+' }}'; };\n\n  _.jQ = $();\n  _.jQadd = function(jQ) { return this.jQ = this.jQ.add(jQ); };\n  _.jQize = function(jQ) {\n    // jQuery-ifies this.html() and links up the .jQ of all corresponding Nodes\n    var jQ = $(jQ || this.html());\n\n    function jQadd(el) {\n      if (el.getAttribute) {\n        var cmdId = el.getAttribute('mathquill-command-id');\n        var blockId = el.getAttribute('mathquill-block-id');\n        if (cmdId) Node.byId[cmdId].jQadd(el);\n        if (blockId) Node.byId[blockId].jQadd(el);\n      }\n      for (el = el.firstChild; el; el = el.nextSibling) {\n        jQadd(el);\n      }\n    }\n\n    for (var i = 0; i < jQ.length; i += 1) jQadd(jQ[i]);\n    return jQ;\n  };\n\n  _.createDir = function(dir, cursor) {\n    prayDirection(dir);\n    var node = this;\n    node.jQize();\n    node.jQ.insDirOf(dir, cursor.jQ);\n    cursor[dir] = node.adopt(cursor.parent, cursor[L], cursor[R]);\n    return node;\n  };\n  _.createLeftOf = function(el) { return this.createDir(L, el); };\n\n  _.selectChildren = function(leftEnd, rightEnd) {\n    return Selection(leftEnd, rightEnd);\n  };\n\n  _.bubble = iterator(function(yield_) {\n    for (var ancestor = this; ancestor; ancestor = ancestor.parent) {\n      var result = yield_(ancestor);\n      if (result === false) break;\n    }\n\n    return this;\n  });\n\n  _.postOrder = iterator(function(yield_) {\n    (function recurse(descendant) {\n      descendant.eachChild(recurse);\n      yield_(descendant);\n    })(this);\n\n    return this;\n  });\n\n  _.isEmpty = function() {\n    return this.ends[L] === 0 && this.ends[R] === 0;\n  };\n\n  _.children = function() {\n    return Fragment(this.ends[L], this.ends[R]);\n  };\n\n  _.eachChild = function() {\n    var children = this.children();\n    children.each.apply(children, arguments);\n    return this;\n  };\n\n  _.foldChildren = function(fold, fn) {\n    return this.children().fold(fold, fn);\n  };\n\n  _.withDirAdopt = function(dir, parent, withDir, oppDir) {\n    Fragment(this, this).withDirAdopt(dir, parent, withDir, oppDir);\n    return this;\n  };\n\n  _.adopt = function(parent, leftward, rightward) {\n    Fragment(this, this).adopt(parent, leftward, rightward);\n    return this;\n  };\n\n  _.disown = function() {\n    Fragment(this, this).disown();\n    return this;\n  };\n\n  _.remove = function() {\n    this.jQ.remove();\n    this.postOrder('dispose');\n    return this.disown();\n  };\n});\n\nfunction prayWellFormed(parent, leftward, rightward) {\n  pray('a parent is always present', parent);\n  pray('leftward is properly set up', (function() {\n    // either it's empty and `rightward` is the left end child (possibly empty)\n    if (!leftward) return parent.ends[L] === rightward;\n\n    // or it's there and its [R] and .parent are properly set up\n    return leftward[R] === rightward && leftward.parent === parent;\n  })());\n\n  pray('rightward is properly set up', (function() {\n    // either it's empty and `leftward` is the right end child (possibly empty)\n    if (!rightward) return parent.ends[R] === leftward;\n\n    // or it's there and its [L] and .parent are properly set up\n    return rightward[L] === leftward && rightward.parent === parent;\n  })());\n}\n\n\n/**\n * An entity outside the virtual tree with one-way pointers (so it's only a\n * \"view\" of part of the tree, not an actual node/entity in the tree) that\n * delimits a doubly-linked list of sibling nodes.\n * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range\n * classes: like DocumentFragment, its contents must be sibling nodes\n * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),\n * but like Range, it has only one-way pointers to its contents, its contents\n * have no reference to it and in fact may still be in the visible tree (unlike\n * DocumentFragment, whose contents must be detached from the visible tree\n * and have their 'parent' pointers set to the DocumentFragment).\n */\nvar Fragment = P(function(_) {\n  _.init = function(withDir, oppDir, dir) {\n    if (dir === undefined) dir = L;\n    prayDirection(dir);\n\n    pray('no half-empty fragments', !withDir === !oppDir);\n\n    this.ends = {};\n\n    if (!withDir) return;\n\n    pray('withDir is passed to Fragment', withDir instanceof Node);\n    pray('oppDir is passed to Fragment', oppDir instanceof Node);\n    pray('withDir and oppDir have the same parent',\n         withDir.parent === oppDir.parent);\n\n    this.ends[dir] = withDir;\n    this.ends[-dir] = oppDir;\n\n    // To build the jquery collection for a fragment, accumulate elements\n    // into an array and then call jQ.add once on the result. jQ.add sorts the\n    // collection according to document order each time it is called, so\n    // building a collection by folding jQ.add directly takes more than\n    // quadratic time in the number of elements.\n    //\n    // https://github.com/jquery/jquery/blob/2.1.4/src/traversing.js#L112\n    var accum = this.fold([], function (accum, el) {\n      accum.push.apply(accum, el.jQ.get());\n      return accum;\n    });\n\n    this.jQ = this.jQ.add(accum);\n  };\n  _.jQ = $();\n\n  // like Cursor::withDirInsertAt(dir, parent, withDir, oppDir)\n  _.withDirAdopt = function(dir, parent, withDir, oppDir) {\n    return (dir === L ? this.adopt(parent, withDir, oppDir)\n                      : this.adopt(parent, oppDir, withDir));\n  };\n  _.adopt = function(parent, leftward, rightward) {\n    prayWellFormed(parent, leftward, rightward);\n\n    var self = this;\n    self.disowned = false;\n\n    var leftEnd = self.ends[L];\n    if (!leftEnd) return this;\n\n    var rightEnd = self.ends[R];\n\n    if (leftward) {\n      // NB: this is handled in the ::each() block\n      // leftward[R] = leftEnd\n    } else {\n      parent.ends[L] = leftEnd;\n    }\n\n    if (rightward) {\n      rightward[L] = rightEnd;\n    } else {\n      parent.ends[R] = rightEnd;\n    }\n\n    self.ends[R][R] = rightward;\n\n    self.each(function(el) {\n      el[L] = leftward;\n      el.parent = parent;\n      if (leftward) leftward[R] = el;\n\n      leftward = el;\n    });\n\n    return self;\n  };\n\n  _.disown = function() {\n    var self = this;\n    var leftEnd = self.ends[L];\n\n    // guard for empty and already-disowned fragments\n    if (!leftEnd || self.disowned) return self;\n\n    self.disowned = true;\n\n    var rightEnd = self.ends[R]\n    var parent = leftEnd.parent;\n\n    prayWellFormed(parent, leftEnd[L], leftEnd);\n    prayWellFormed(parent, rightEnd, rightEnd[R]);\n\n    if (leftEnd[L]) {\n      leftEnd[L][R] = rightEnd[R];\n    } else {\n      parent.ends[L] = rightEnd[R];\n    }\n\n    if (rightEnd[R]) {\n      rightEnd[R][L] = leftEnd[L];\n    } else {\n      parent.ends[R] = leftEnd[L];\n    }\n\n    return self;\n  };\n\n  _.remove = function() {\n    this.jQ.remove();\n    this.each('postOrder', 'dispose');\n    return this.disown();\n  };\n\n  _.each = iterator(function(yield_) {\n    var self = this;\n    var el = self.ends[L];\n    if (!el) return self;\n\n    for (; el !== self.ends[R][R]; el = el[R]) {\n      var result = yield_(el);\n      if (result === false) break;\n    }\n\n    return self;\n  });\n\n  _.fold = function(fold, fn) {\n    this.each(function(el) {\n      fold = fn.call(this, fold, el);\n    });\n\n    return fold;\n  };\n});\n\n\n/**\n * Registry of LaTeX commands and commands created when typing\n * a single character.\n *\n * (Commands are all subclasses of Node.)\n */\nvar LatexCmds = {}, CharCmds = {};\n/********************************************\n * Cursor and Selection \"singleton\" classes\n *******************************************/\n\n/* The main thing that manipulates the Math DOM. Makes sure to manipulate the\nHTML DOM to match. */\n\n/* Sort of singletons, since there should only be one per editable math\ntextbox, but any one HTML document can contain many such textboxes, so any one\nJS environment could actually contain many instances. */\n\n//A fake cursor in the fake textbox that the math is rendered in.\nvar Cursor = P(Point, function(_) {\n  _.init = function(initParent, options) {\n    this.parent = initParent;\n    this.options = options;\n\n    var jQ = this.jQ = this._jQ = $('<span class=\"mq-cursor\">&#8203;</span>');\n    //closured for setInterval\n    this.blink = function(){ jQ.toggleClass('mq-blink'); };\n\n    this.upDownCache = {};\n  };\n\n  _.show = function() {\n    this.jQ = this._jQ.removeClass('mq-blink');\n    if ('intervalId' in this) //already was shown, just restart interval\n      clearInterval(this.intervalId);\n    else { //was hidden and detached, insert this.jQ back into HTML DOM\n      if (this[R]) {\n        if (this.selection && this.selection.ends[L][L] === this[L])\n          this.jQ.insertBefore(this.selection.jQ);\n        else\n          this.jQ.insertBefore(this[R].jQ.first());\n      }\n      else\n        this.jQ.appendTo(this.parent.jQ);\n      this.parent.focus();\n    }\n    this.intervalId = setInterval(this.blink, 500);\n    return this;\n  };\n  _.hide = function() {\n    if ('intervalId' in this)\n      clearInterval(this.intervalId);\n    delete this.intervalId;\n    this.jQ.detach();\n    this.jQ = $();\n    return this;\n  };\n\n  _.withDirInsertAt = function(dir, parent, withDir, oppDir) {\n    var oldParent = this.parent;\n    this.parent = parent;\n    this[dir] = withDir;\n    this[-dir] = oppDir;\n    // by contract, .blur() is called after all has been said and done\n    // and the cursor has actually been moved\n    // FIXME pass cursor to .blur() so text can fix cursor pointers when removing itself\n    if (oldParent !== parent && oldParent.blur) oldParent.blur(this);\n  };\n  _.insDirOf = function(dir, el) {\n    prayDirection(dir);\n    this.jQ.insDirOf(dir, el.jQ);\n    this.withDirInsertAt(dir, el.parent, el[dir], el);\n    this.parent.jQ.addClass('mq-hasCursor');\n    return this;\n  };\n  _.insLeftOf = function(el) { return this.insDirOf(L, el); };\n  _.insRightOf = function(el) { return this.insDirOf(R, el); };\n\n  _.insAtDirEnd = function(dir, el) {\n    prayDirection(dir);\n    this.jQ.insAtDirEnd(dir, el.jQ);\n    this.withDirInsertAt(dir, el, 0, el.ends[dir]);\n    el.focus();\n    return this;\n  };\n  _.insAtLeftEnd = function(el) { return this.insAtDirEnd(L, el); };\n  _.insAtRightEnd = function(el) { return this.insAtDirEnd(R, el); };\n\n  /**\n   * jump up or down from one block Node to another:\n   * - cache the current Point in the node we're jumping from\n   * - check if there's a Point in it cached for the node we're jumping to\n   *   + if so put the cursor there,\n   *   + if not seek a position in the node that is horizontally closest to\n   *     the cursor's current position\n   */\n  _.jumpUpDown = function(from, to) {\n    var self = this;\n    self.upDownCache[from.id] = Point.copy(self);\n    var cached = self.upDownCache[to.id];\n    if (cached) {\n      cached[R] ? self.insLeftOf(cached[R]) : self.insAtRightEnd(cached.parent);\n    }\n    else {\n      var pageX = self.offset().left;\n      to.seek(pageX, self);\n    }\n  };\n  _.offset = function() {\n    //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()\n    //returns all 0's on inline elements with negative margin-right (like\n    //the cursor) at the end of their parent, so temporarily remove the\n    //negative margin-right when calling jQuery::offset()\n    //Opera bug DSK-360043\n    //http://bugs.jquery.com/ticket/11523\n    //https://github.com/jquery/jquery/pull/717\n    var self = this, offset = self.jQ.removeClass('mq-cursor').offset();\n    self.jQ.addClass('mq-cursor');\n    return offset;\n  }\n  _.unwrapGramp = function() {\n    var gramp = this.parent.parent;\n    var greatgramp = gramp.parent;\n    var rightward = gramp[R];\n    var cursor = this;\n\n    var leftward = gramp[L];\n    gramp.disown().eachChild(function(uncle) {\n      if (uncle.isEmpty()) return;\n\n      uncle.children()\n        .adopt(greatgramp, leftward, rightward)\n        .each(function(cousin) {\n          cousin.jQ.insertBefore(gramp.jQ.first());\n        })\n      ;\n\n      leftward = uncle.ends[R];\n    });\n\n    if (!this[R]) { //then find something to be rightward to insLeftOf\n      if (this[L])\n        this[R] = this[L][R];\n      else {\n        while (!this[R]) {\n          this.parent = this.parent[R];\n          if (this.parent)\n            this[R] = this.parent.ends[L];\n          else {\n            this[R] = gramp[R];\n            this.parent = greatgramp;\n            break;\n          }\n        }\n      }\n    }\n    if (this[R])\n      this.insLeftOf(this[R]);\n    else\n      this.insAtRightEnd(greatgramp);\n\n    gramp.jQ.remove();\n\n    if (gramp[L].siblingDeleted) gramp[L].siblingDeleted(cursor.options, R);\n    if (gramp[R].siblingDeleted) gramp[R].siblingDeleted(cursor.options, L);\n  };\n  _.startSelection = function() {\n    var anticursor = this.anticursor = Point.copy(this);\n    var ancestors = anticursor.ancestors = {}; // a map from each ancestor of\n      // the anticursor, to its child that is also an ancestor; in other words,\n      // the anticursor's ancestor chain in reverse order\n    for (var ancestor = anticursor; ancestor.parent; ancestor = ancestor.parent) {\n      ancestors[ancestor.parent.id] = ancestor;\n    }\n  };\n  _.endSelection = function() {\n    delete this.anticursor;\n  };\n  _.select = function() {\n    var anticursor = this.anticursor;\n    if (this[L] === anticursor[L] && this.parent === anticursor.parent) return false;\n\n    // Find the lowest common ancestor (`lca`), and the ancestor of the cursor\n    // whose parent is the LCA (which'll be an end of the selection fragment).\n    for (var ancestor = this; ancestor.parent; ancestor = ancestor.parent) {\n      if (ancestor.parent.id in anticursor.ancestors) {\n        var lca = ancestor.parent;\n        break;\n      }\n    }\n    pray('cursor and anticursor in the same tree', lca);\n    // The cursor and the anticursor should be in the same tree, because the\n    // mousemove handler attached to the document, unlike the one attached to\n    // the root HTML DOM element, doesn't try to get the math tree node of the\n    // mousemove target, and Cursor::seek() based solely on coordinates stays\n    // within the tree of `this` cursor's root.\n\n    // The other end of the selection fragment, the ancestor of the anticursor\n    // whose parent is the LCA.\n    var antiAncestor = anticursor.ancestors[lca.id];\n\n    // Now we have two either Nodes or Points, guaranteed to have a common\n    // parent and guaranteed that if both are Points, they are not the same,\n    // and we have to figure out which is the left end and which the right end\n    // of the selection.\n    var leftEnd, rightEnd, dir = R;\n\n    // This is an extremely subtle algorithm.\n    // As a special case, `ancestor` could be a Point and `antiAncestor` a Node\n    // immediately to `ancestor`'s left.\n    // In all other cases,\n    // - both Nodes\n    // - `ancestor` a Point and `antiAncestor` a Node\n    // - `ancestor` a Node and `antiAncestor` a Point\n    // `antiAncestor[R] === rightward[R]` for some `rightward` that is\n    // `ancestor` or to its right, if and only if `antiAncestor` is to\n    // the right of `ancestor`.\n    if (ancestor[L] !== antiAncestor) {\n      for (var rightward = ancestor; rightward; rightward = rightward[R]) {\n        if (rightward[R] === antiAncestor[R]) {\n          dir = L;\n          leftEnd = ancestor;\n          rightEnd = antiAncestor;\n          break;\n        }\n      }\n    }\n    if (dir === R) {\n      leftEnd = antiAncestor;\n      rightEnd = ancestor;\n    }\n\n    // only want to select Nodes up to Points, can't select Points themselves\n    if (leftEnd instanceof Point) leftEnd = leftEnd[R];\n    if (rightEnd instanceof Point) rightEnd = rightEnd[L];\n\n    this.hide().selection = lca.selectChildren(leftEnd, rightEnd);\n    this.insDirOf(dir, this.selection.ends[dir]);\n    this.selectionChanged();\n    return true;\n  };\n\n  _.clearSelection = function() {\n    if (this.selection) {\n      this.selection.clear();\n      delete this.selection;\n      this.selectionChanged();\n    }\n    return this;\n  };\n  _.deleteSelection = function() {\n    if (!this.selection) return;\n\n    this[L] = this.selection.ends[L][L];\n    this[R] = this.selection.ends[R][R];\n    this.selection.remove();\n    this.selectionChanged();\n    delete this.selection;\n  };\n  _.replaceSelection = function() {\n    var seln = this.selection;\n    if (seln) {\n      this[L] = seln.ends[L][L];\n      this[R] = seln.ends[R][R];\n      delete this.selection;\n    }\n    return seln;\n  };\n});\n\nvar Selection = P(Fragment, function(_, super_) {\n  _.init = function() {\n    super_.init.apply(this, arguments);\n    this.jQ = this.jQ.wrapAll('<span class=\"mq-selection\"></span>').parent();\n      //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it\n  };\n  _.adopt = function() {\n    this.jQ.replaceWith(this.jQ = this.jQ.children());\n    return super_.adopt.apply(this, arguments);\n  };\n  _.clear = function() {\n    // using the browser's native .childNodes property so that we\n    // don't discard text nodes.\n    this.jQ.replaceWith(this.jQ[0].childNodes);\n    return this;\n  };\n  _.join = function(methodName) {\n    return this.fold('', function(fold, child) {\n      return fold + child[methodName]();\n    });\n  };\n});\n/*********************************************\n * Controller for a MathQuill instance,\n * on which services are registered with\n *\n *   Controller.open(function(_) { ... });\n *\n ********************************************/\n\nvar Controller = P(function(_) {\n  _.init = function(root, container, options) {\n    this.id = root.id;\n    this.data = {};\n\n    this.root = root;\n    this.container = container;\n    this.options = options;\n\n    root.controller = this;\n\n    this.cursor = root.cursor = Cursor(root, options);\n    // TODO: stop depending on root.cursor, and rm it\n  };\n\n  _.handle = function(name, dir) {\n    var handlers = this.options.handlers;\n    if (handlers && handlers.fns[name]) {\n      var mq = handlers.APIClasses[this.KIND_OF_MQ](this);\n      if (dir === L || dir === R) handlers.fns[name](dir, mq);\n      else handlers.fns[name](mq);\n    }\n  };\n\n  var notifyees = [];\n  this.onNotify = function(f) { notifyees.push(f); };\n  _.notify = function() {\n    for (var i = 0; i < notifyees.length; i += 1) {\n      notifyees[i].apply(this.cursor, arguments);\n    }\n    return this;\n  };\n});\n/*********************************************************\n * The publicly exposed MathQuill API.\n ********************************************************/\n\nvar API = {}, Options = P(), optionProcessors = {}, Progenote = P(), EMBEDS = {};\n\n/**\n * Interface Versioning (#459, #495) to allow us to virtually guarantee\n * backcompat. v0.10.x introduces it, so for now, don't completely break the\n * API for people who don't know about it, just complain with console.warn().\n *\n * The methods are shimmed in outro.js so that MQ.MathField.prototype etc can\n * be accessed.\n */\nfunction insistOnInterVer() {\n  if (window.console) console.warn(\n    'You are using the MathQuill API without specifying an interface version, ' +\n    'which will fail in v1.0.0. Easiest fix is to do the following before ' +\n    'doing anything else:\\n' +\n    '\\n' +\n    '    MathQuill = MathQuill.getInterface(1);\\n' +\n    '    // now MathQuill.MathField() works like it used to\\n' +\n    '\\n' +\n    'See also the \"`dev` branch (2014\\u20132015) \\u2192 v0.10.0 Migration Guide\" at\\n' +\n    '  https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide'\n  );\n}\n// globally exported API object\nfunction MathQuill(el) {\n  insistOnInterVer();\n  return MQ1(el);\n};\nMathQuill.prototype = Progenote.p;\nMathQuill.interfaceVersion = function(v) {\n  // shim for #459-era interface versioning (ended with #495)\n  if (v !== 1) throw 'Only interface version 1 supported. You specified: ' + v;\n  insistOnInterVer = function() {\n    if (window.console) console.warn(\n      'You called MathQuill.interfaceVersion(1); to specify the interface ' +\n      'version, which will fail in v1.0.0. You can fix this easily by doing ' +\n      'this before doing anything else:\\n' +\n      '\\n' +\n      '    MathQuill = MathQuill.getInterface(1);\\n' +\n      '    // now MathQuill.MathField() works like it used to\\n' +\n      '\\n' +\n      'See also the \"`dev` branch (2014\\u20132015) \\u2192 v0.10.0 Migration Guide\" at\\n' +\n      '  https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide'\n    );\n  };\n  insistOnInterVer();\n  return MathQuill;\n};\nMathQuill.getInterface = getInterface;\n\nvar MIN = getInterface.MIN = 1, MAX = getInterface.MAX = 2;\nfunction getInterface(v) {\n  if (!(MIN <= v && v <= MAX)) throw 'Only interface versions between ' +\n    MIN + ' and ' + MAX + ' supported. You specified: ' + v;\n\n  /**\n   * Function that takes an HTML element and, if it's the root HTML element of a\n   * static math or math or text field, returns an API object for it (else, null).\n   *\n   *   var mathfield = MQ.MathField(mathFieldSpan);\n   *   assert(MQ(mathFieldSpan).id === mathfield.id);\n   *   assert(MQ(mathFieldSpan).id === MQ(mathFieldSpan).id);\n   *\n   */\n  function MQ(el) {\n    if (!el || !el.nodeType) return null; // check that `el` is a HTML element, using the\n      // same technique as jQuery: https://github.com/jquery/jquery/blob/679536ee4b7a92ae64a5f58d90e9cc38c001e807/src/core/init.js#L92\n    var blockId = $(el).children('.mq-root-block').attr(mqBlockId);\n    var ctrlr = blockId && Node.byId[blockId].controller;\n    return ctrlr ? APIClasses[ctrlr.KIND_OF_MQ](ctrlr) : null;\n  };\n  var APIClasses = {};\n\n  MQ.L = L;\n  MQ.R = R;\n\n  function config(currentOptions, newOptions) {\n    if (newOptions && newOptions.handlers) {\n      newOptions.handlers = { fns: newOptions.handlers, APIClasses: APIClasses };\n    }\n    for (var name in newOptions) if (newOptions.hasOwnProperty(name)) {\n      var value = newOptions[name], processor = optionProcessors[name];\n      currentOptions[name] = (processor ? processor(value) : value);\n    }\n  }\n  MQ.config = function(opts) { config(Options.p, opts); return this; };\n  MQ.registerEmbed = function(name, options) {\n    if (!/^[a-z][a-z0-9]*$/i.test(name)) {\n      throw 'Embed name must start with letter and be only letters and digits';\n    }\n    EMBEDS[name] = options;\n  };\n\n  var AbstractMathQuill = APIClasses.AbstractMathQuill = P(Progenote, function(_) {\n    _.init = function(ctrlr) {\n      this.__controller = ctrlr;\n      this.__options = ctrlr.options;\n      this.id = ctrlr.id;\n      this.data = ctrlr.data;\n    };\n    _.__mathquillify = function(classNames) {\n      var ctrlr = this.__controller, root = ctrlr.root, el = ctrlr.container;\n      ctrlr.createTextarea();\n\n      var contents = el.addClass(classNames).contents().detach();\n      root.jQ =\n        $('<span class=\"mq-root-block\"/>').attr(mqBlockId, root.id).appendTo(el);\n      this.latex(contents.text());\n\n      this.revert = function() {\n        return el.empty().unbind('.mathquill')\n        .removeClass('mq-editable-field mq-math-mode mq-text-mode')\n        .append(contents);\n      };\n    };\n    _.config = function(opts) { config(this.__options, opts); return this; };\n    _.el = function() { return this.__controller.container[0]; };\n    _.text = function() { return this.__controller.exportText(); };\n    _.latex = function(latex) {\n      if (arguments.length > 0) {\n        this.__controller.renderLatexMath(latex);\n        if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n        return this;\n      }\n      return this.__controller.exportLatex();\n    };\n    _.html = function() {\n      return this.__controller.root.jQ.html()\n        .replace(/ mathquill-(?:command|block)-id=\"?\\d+\"?/g, '')\n        .replace(/<span class=\"?mq-cursor( mq-blink)?\"?>.?<\\/span>/i, '')\n        .replace(/ mq-hasCursor|mq-hasCursor ?/, '')\n        .replace(/ class=(\"\"|(?= |>))/g, '');\n    };\n    _.reflow = function() {\n      this.__controller.root.postOrder('reflow');\n      return this;\n    };\n  });\n  MQ.prototype = AbstractMathQuill.prototype;\n\n  APIClasses.EditableField = P(AbstractMathQuill, function(_, super_) {\n    _.__mathquillify = function() {\n      super_.__mathquillify.apply(this, arguments);\n      this.__controller.editable = true;\n      this.__controller.delegateMouseEvents();\n      this.__controller.editablesTextareaEvents();\n      return this;\n    };\n    _.focus = function() { this.__controller.textarea.focus(); return this; };\n    _.blur = function() { this.__controller.textarea.blur(); return this; };\n    _.write = function(latex) {\n      this.__controller.writeLatex(latex);\n      this.__controller.scrollHoriz();\n      if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n      return this;\n    };\n    _.cmd = function(cmd) {\n      var ctrlr = this.__controller.notify(), cursor = ctrlr.cursor;\n      if (/^\\\\[a-z]+$/i.test(cmd)) {\n        cmd = cmd.slice(1);\n        var klass = LatexCmds[cmd];\n        if (klass) {\n          cmd = klass(cmd);\n          if (cursor.selection) cmd.replaces(cursor.replaceSelection());\n          cmd.createLeftOf(cursor.show());\n          this.__controller.scrollHoriz();\n        }\n        else /* TODO: API needs better error reporting */;\n      }\n      else cursor.parent.write(cursor, cmd);\n      if (ctrlr.blurred) cursor.hide().parent.blur();\n      return this;\n    };\n    _.select = function() {\n      var ctrlr = this.__controller;\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      while (ctrlr.cursor[L]) ctrlr.selectLeft();\n      return this;\n    };\n    _.clearSelection = function() {\n      this.__controller.cursor.clearSelection();\n      return this;\n    };\n\n    _.moveToDirEnd = function(dir) {\n      this.__controller.notify('move').cursor.insAtDirEnd(dir, this.__controller.root);\n      return this;\n    };\n    _.moveToLeftEnd = function() { return this.moveToDirEnd(L); };\n    _.moveToRightEnd = function() { return this.moveToDirEnd(R); };\n\n    _.keystroke = function(keys) {\n      var keys = keys.replace(/^\\s+|\\s+$/g, '').split(/\\s+/);\n      for (var i = 0; i < keys.length; i += 1) {\n        this.__controller.keystroke(keys[i], { preventDefault: noop });\n      }\n      return this;\n    };\n    _.typedText = function(text) {\n      for (var i = 0; i < text.length; i += 1) this.__controller.typedText(text.charAt(i));\n      return this;\n    };\n    _.dropEmbedded = function(pageX, pageY, options) {\n      var clientX = pageX - $(window).scrollLeft();\n      var clientY = pageY - $(window).scrollTop();\n\n      var el = document.elementFromPoint(clientX, clientY);\n      this.__controller.seek($(el), pageX, pageY);\n      var cmd = Embed().setOptions(options);\n      cmd.createLeftOf(this.__controller.cursor);\n    };\n    _.clickAt = function(clientX, clientY, target) {\n      target = target || document.elementFromPoint(clientX, clientY);\n\n      var ctrlr = this.__controller, root = ctrlr.root;\n      if (!jQuery.contains(root.jQ[0], target)) target = root.jQ[0];\n      ctrlr.seek($(target), clientX + pageXOffset, clientY + pageYOffset);\n      if (ctrlr.blurred) this.focus();\n      return this;\n    };\n    _.ignoreNextMousedown = function(fn) {\n      this.__controller.cursor.options.ignoreNextMousedown = fn;\n      return this;\n    };\n  });\n  MQ.EditableField = function() { throw \"wtf don't call me, I'm 'abstract'\"; };\n  MQ.EditableField.prototype = APIClasses.EditableField.prototype;\n\n  /**\n   * Export the API functions that MathQuill-ify an HTML element into API objects\n   * of each class. If the element had already been MathQuill-ified but into a\n   * different kind (or it's not an HTML element), return null.\n   */\n  for (var kind in API) (function(kind, defAPIClass) {\n    var APIClass = APIClasses[kind] = defAPIClass(APIClasses);\n    MQ[kind] = function(el, opts) {\n      var mq = MQ(el);\n      if (mq instanceof APIClass || !el || !el.nodeType) return mq;\n      var ctrlr = Controller(APIClass.RootBlock(), $(el), Options());\n      ctrlr.KIND_OF_MQ = kind;\n      return APIClass(ctrlr).__mathquillify(opts, v);\n    };\n    MQ[kind].prototype = APIClass.prototype;\n  }(kind, API[kind]));\n\n  return MQ;\n}\n\nMathQuill.noConflict = function() {\n  window.MathQuill = origMathQuill;\n  return MathQuill;\n};\nvar origMathQuill = window.MathQuill;\nwindow.MathQuill = MathQuill;\n\nfunction RootBlockMixin(_) {\n  var names = 'moveOutOf deleteOutOf selectOutOf upOutOf downOutOf'.split(' ');\n  for (var i = 0; i < names.length; i += 1) (function(name) {\n    _[name] = function(dir) { this.controller.handle(name, dir); };\n  }(names[i]));\n  _.reflow = function() {\n    this.controller.handle('reflow');\n    this.controller.handle('edited');\n    this.controller.handle('edit');\n  };\n}\nvar Parser = P(function(_, super_, Parser) {\n  // The Parser object is a wrapper for a parser function.\n  // Externally, you use one to parse a string by calling\n  //   var result = SomeParser.parse('Me Me Me! Parse Me!');\n  // You should never call the constructor, rather you should\n  // construct your Parser from the base parsers and the\n  // parser combinator methods.\n\n  function parseError(stream, message) {\n    if (stream) {\n      stream = \"'\"+stream+\"'\";\n    }\n    else {\n      stream = 'EOF';\n    }\n\n    throw 'Parse Error: '+message+' at '+stream;\n  }\n\n  _.init = function(body) { this._ = body; };\n\n  _.parse = function(stream) {\n    return this.skip(eof)._(''+stream, success, parseError);\n\n    function success(stream, result) { return result; }\n  };\n\n  // -*- primitive combinators -*- //\n  _.or = function(alternative) {\n    pray('or is passed a parser', alternative instanceof Parser);\n\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      return self._(stream, onSuccess, failure);\n\n      function failure(newStream) {\n        return alternative._(stream, onSuccess, onFailure);\n      }\n    });\n  };\n\n  _.then = function(next) {\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      return self._(stream, success, onFailure);\n\n      function success(newStream, result) {\n        var nextParser = (next instanceof Parser ? next : next(result));\n        pray('a parser is returned', nextParser instanceof Parser);\n        return nextParser._(newStream, onSuccess, onFailure);\n      }\n    });\n  };\n\n  // -*- optimized iterative combinators -*- //\n  _.many = function() {\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var xs = [];\n      while (self._(stream, success, failure));\n      return onSuccess(stream, xs);\n\n      function success(newStream, x) {\n        stream = newStream;\n        xs.push(x);\n        return true;\n      }\n\n      function failure() {\n        return false;\n      }\n    });\n  };\n\n  _.times = function(min, max) {\n    if (arguments.length < 2) max = min;\n    var self = this;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var xs = [];\n      var result = true;\n      var failure;\n\n      for (var i = 0; i < min; i += 1) {\n        result = self._(stream, success, firstFailure);\n        if (!result) return onFailure(stream, failure);\n      }\n\n      for (; i < max && result; i += 1) {\n        result = self._(stream, success, secondFailure);\n      }\n\n      return onSuccess(stream, xs);\n\n      function success(newStream, x) {\n        xs.push(x);\n        stream = newStream;\n        return true;\n      }\n\n      function firstFailure(newStream, msg) {\n        failure = msg;\n        stream = newStream;\n        return false;\n      }\n\n      function secondFailure(newStream, msg) {\n        return false;\n      }\n    });\n  };\n\n  // -*- higher-level combinators -*- //\n  _.result = function(res) { return this.then(succeed(res)); };\n  _.atMost = function(n) { return this.times(0, n); };\n  _.atLeast = function(n) {\n    var self = this;\n    return self.times(n).then(function(start) {\n      return self.many().map(function(end) {\n        return start.concat(end);\n      });\n    });\n  };\n\n  _.map = function(fn) {\n    return this.then(function(result) { return succeed(fn(result)); });\n  };\n\n  _.skip = function(two) {\n    return this.then(function(result) { return two.result(result); });\n  };\n\n  // -*- primitive parsers -*- //\n  var string = this.string = function(str) {\n    var len = str.length;\n    var expected = \"expected '\"+str+\"'\";\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var head = stream.slice(0, len);\n\n      if (head === str) {\n        return onSuccess(stream.slice(len), head);\n      }\n      else {\n        return onFailure(stream, expected);\n      }\n    });\n  };\n\n  var regex = this.regex = function(re) {\n    pray('regexp parser is anchored', re.toString().charAt(1) === '^');\n\n    var expected = 'expected '+re;\n\n    return Parser(function(stream, onSuccess, onFailure) {\n      var match = re.exec(stream);\n\n      if (match) {\n        var result = match[0];\n        return onSuccess(stream.slice(result.length), result);\n      }\n      else {\n        return onFailure(stream, expected);\n      }\n    });\n  };\n\n  var succeed = Parser.succeed = function(result) {\n    return Parser(function(stream, onSuccess) {\n      return onSuccess(stream, result);\n    });\n  };\n\n  var fail = Parser.fail = function(msg) {\n    return Parser(function(stream, _, onFailure) {\n      return onFailure(stream, msg);\n    });\n  };\n\n  var letter = Parser.letter = regex(/^[a-z]/i);\n  var letters = Parser.letters = regex(/^[a-z]*/i);\n  var digit = Parser.digit = regex(/^[0-9]/);\n  var digits = Parser.digits = regex(/^[0-9]*/);\n  var whitespace = Parser.whitespace = regex(/^\\s+/);\n  var optWhitespace = Parser.optWhitespace = regex(/^\\s*/);\n\n  var any = Parser.any = Parser(function(stream, onSuccess, onFailure) {\n    if (!stream) return onFailure(stream, 'expected any character');\n\n    return onSuccess(stream.slice(1), stream.charAt(0));\n  });\n\n  var all = Parser.all = Parser(function(stream, onSuccess, onFailure) {\n    return onSuccess('', stream);\n  });\n\n  var eof = Parser.eof = Parser(function(stream, onSuccess, onFailure) {\n    if (stream) return onFailure(stream, 'expected EOF');\n\n    return onSuccess(stream, stream);\n  });\n});\n/*************************************************\n * Sane Keyboard Events Shim\n *\n * An abstraction layer wrapping the textarea in\n * an object with methods to manipulate and listen\n * to events on, that hides all the nasty cross-\n * browser incompatibilities behind a uniform API.\n *\n * Design goal: This is a *HARD* internal\n * abstraction barrier. Cross-browser\n * inconsistencies are not allowed to leak through\n * and be dealt with by event handlers. All future\n * cross-browser issues that arise must be dealt\n * with here, and if necessary, the API updated.\n *\n * Organization:\n * - key values map and stringify()\n * - saneKeyboardEvents()\n *    + defer() and flush()\n *    + event handler logic\n *    + attach event handlers and export methods\n ************************************************/\n\nvar saneKeyboardEvents = (function() {\n  // The following [key values][1] map was compiled from the\n  // [DOM3 Events appendix section on key codes][2] and\n  // [a widely cited report on cross-browser tests of key codes][3],\n  // except for 10: 'Enter', which I've empirically observed in Safari on iOS\n  // and doesn't appear to conflict with any other known key codes.\n  //\n  // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues\n  // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes\n  // [3]: http://unixpapa.com/js/key.html\n  var KEY_VALUES = {\n    8: 'Backspace',\n    9: 'Tab',\n\n    10: 'Enter', // for Safari on iOS\n\n    13: 'Enter',\n\n    16: 'Shift',\n    17: 'Control',\n    18: 'Alt',\n    20: 'CapsLock',\n\n    27: 'Esc',\n\n    32: 'Spacebar',\n\n    33: 'PageUp',\n    34: 'PageDown',\n    35: 'End',\n    36: 'Home',\n\n    37: 'Left',\n    38: 'Up',\n    39: 'Right',\n    40: 'Down',\n\n    45: 'Insert',\n\n    46: 'Del',\n\n    144: 'NumLock'\n  };\n\n  // To the extent possible, create a normalized string representation\n  // of the key combo (i.e., key code and modifier keys).\n  function stringify(evt) {\n    var which = evt.which || evt.keyCode;\n    var keyVal = KEY_VALUES[which];\n    var key;\n    var modifiers = [];\n\n    if (evt.ctrlKey) modifiers.push('Ctrl');\n    if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');\n    if (evt.altKey) modifiers.push('Alt');\n    if (evt.shiftKey) modifiers.push('Shift');\n\n    key = keyVal || String.fromCharCode(which);\n\n    if (!modifiers.length && !keyVal) return key;\n\n    modifiers.push(key);\n    return modifiers.join('-');\n  }\n\n  // create a keyboard events shim that calls callbacks at useful times\n  // and exports useful public methods\n  return function saneKeyboardEvents(el, handlers) {\n    var keydown = null;\n    var keypress = null;\n\n    var textarea = jQuery(el);\n    var target = jQuery(handlers.container || textarea);\n\n    // checkTextareaFor() is called after keypress or paste events to\n    // say \"Hey, I think something was just typed\" or \"pasted\" (resp.),\n    // so that at all subsequent opportune times (next event or timeout),\n    // will check for expected typed or pasted text.\n    // Need to check repeatedly because #135: in Safari 5.1 (at least),\n    // after selecting something and then typing, the textarea is\n    // incorrectly reported as selected during the input event (but not\n    // subsequently).\n    var checkTextarea = noop, timeoutId;\n    function checkTextareaFor(checker) {\n      checkTextarea = checker;\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(checker);\n    }\n    target.bind('keydown keypress input keyup focusout paste', function(e) { checkTextarea(e); });\n\n\n    // -*- public methods -*- //\n    function select(text) {\n      // check textarea at least once/one last time before munging (so\n      // no race condition if selection happens after keypress/paste but\n      // before checkTextarea), then never again ('cos it's been munged)\n      checkTextarea();\n      checkTextarea = noop;\n      clearTimeout(timeoutId);\n\n      textarea.val(text);\n      if (text && textarea[0].select) textarea[0].select();\n      shouldBeSelected = !!text;\n    }\n    var shouldBeSelected = false;\n\n    // -*- helper subroutines -*- //\n\n    // Determine whether there's a selection in the textarea.\n    // This will always return false in IE < 9, which don't support\n    // HTMLTextareaElement::selection{Start,End}.\n    function hasSelection() {\n      var dom = textarea[0];\n\n      if (!('selectionStart' in dom)) return false;\n      return dom.selectionStart !== dom.selectionEnd;\n    }\n\n    function handleKey() {\n      handlers.keystroke(stringify(keydown), keydown);\n    }\n\n    // -*- event handlers -*- //\n    function onKeydown(e) {\n      keydown = e;\n      keypress = null;\n\n      if (shouldBeSelected) checkTextareaFor(function(e) {\n        if (!(e && e.type === 'focusout') && textarea[0].select) {\n          textarea[0].select(); // re-select textarea in case it's an unrecognized\n        }\n        checkTextarea = noop; // key that clears the selection, then never\n        clearTimeout(timeoutId); // again, 'cos next thing might be blur\n      });\n\n      handleKey();\n    }\n\n    function onKeypress(e) {\n      // call the key handler for repeated keypresses.\n      // This excludes keypresses that happen directly\n      // after keydown.  In that case, there will be\n      // no previous keypress, so we skip it here\n      if (keydown && keypress) handleKey();\n\n      keypress = e;\n\n      checkTextareaFor(typedText);\n    }\n    function typedText() {\n      // If there is a selection, the contents of the textarea couldn't\n      // possibly have just been typed in.\n      // This happens in browsers like Firefox and Opera that fire\n      // keypress for keystrokes that are not text entry and leave the\n      // selection in the textarea alone, such as Ctrl-C.\n      // Note: we assume that browsers that don't support hasSelection()\n      // also never fire keypress on keystrokes that are not text entry.\n      // This seems reasonably safe because:\n      // - all modern browsers including IE 9+ support hasSelection(),\n      //   making it extremely unlikely any browser besides IE < 9 won't\n      // - as far as we know IE < 9 never fires keypress on keystrokes\n      //   that aren't text entry, which is only as reliable as our\n      //   tests are comprehensive, but the IE < 9 way to do\n      //   hasSelection() is poorly documented and is also only as\n      //   reliable as our tests are comprehensive\n      // If anything like #40 or #71 is reported in IE < 9, see\n      // b1318e5349160b665003e36d4eedd64101ceacd8\n      if (hasSelection()) return;\n\n      var text = textarea.val();\n      if (text.length === 1) {\n        textarea.val('');\n        handlers.typedText(text);\n      } // in Firefox, keys that don't type text, just clear seln, fire keypress\n      // https://github.com/mathquill/mathquill/issues/293#issuecomment-40997668\n      else if (text && textarea[0].select) textarea[0].select(); // re-select if that's why we're here\n    }\n\n    function onBlur() { keydown = keypress = null; }\n\n    function onPaste(e) {\n      // browsers are dumb.\n      //\n      // In Linux, middle-click pasting causes onPaste to be called,\n      // when the textarea is not necessarily focused.  We focus it\n      // here to ensure that the pasted text actually ends up in the\n      // textarea.\n      //\n      // It's pretty nifty that by changing focus in this handler,\n      // we can change the target of the default action.  (This works\n      // on keydown too, FWIW).\n      //\n      // And by nifty, we mean dumb (but useful sometimes).\n      textarea.focus();\n\n      checkTextareaFor(pastedText);\n    }\n    function pastedText() {\n      var text = textarea.val();\n      textarea.val('');\n      if (text) handlers.paste(text);\n    }\n\n    // -*- attach event handlers -*- //\n    target.bind({\n      keydown: onKeydown,\n      keypress: onKeypress,\n      focusout: onBlur,\n      paste: onPaste\n    });\n\n    // -*- export public methods -*- //\n    return {\n      select: select\n    };\n  };\n}());\n/***********************************************\n * Export math in a human-readable text format\n * As you can see, only half-baked so far.\n **********************************************/\n\nController.open(function(_, super_) {\n  _.exportText = function() {\n    return this.root.foldChildren('', function(text, child) {\n      return text + child.text();\n    });\n  };\n});\nController.open(function(_) {\n  _.focusBlurEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor;\n    var blurTimeout;\n    ctrlr.textarea.focus(function() {\n      ctrlr.blurred = false;\n      clearTimeout(blurTimeout);\n      ctrlr.container.addClass('mq-focused');\n      if (!cursor.parent)\n        cursor.insAtRightEnd(root);\n      if (cursor.selection) {\n        cursor.selection.jQ.removeClass('mq-blur');\n        ctrlr.selectionChanged(); //re-select textarea contents after tabbing away and back\n      }\n      else\n        cursor.show();\n    }).blur(function() {\n      ctrlr.blurred = true;\n      blurTimeout = setTimeout(function() { // wait for blur on window; if\n        root.postOrder('intentionalBlur'); // none, intentional blur: #264\n        cursor.clearSelection().endSelection();\n        blur();\n      });\n      $(window).on('blur', windowBlur);\n    });\n    function windowBlur() { // blur event also fired on window, just switching\n      clearTimeout(blurTimeout); // tabs/windows, not intentional blur\n      if (cursor.selection) cursor.selection.jQ.addClass('mq-blur');\n      blur();\n    }\n    function blur() { // not directly in the textarea blur handler so as to be\n      cursor.hide().parent.blur(); // synchronous with/in the same frame as\n      ctrlr.container.removeClass('mq-focused'); // clearing/blurring selection\n      $(window).off('blur', windowBlur);\n    }\n    ctrlr.blurred = true;\n    cursor.hide().parent.blur();\n  };\n});\n\n/**\n * TODO: I wanted to move MathBlock::focus and blur here, it would clean\n * up lots of stuff like, TextBlock::focus is set to MathBlock::focus\n * and TextBlock::blur calls MathBlock::blur, when instead they could\n * use inheritance and super_.\n *\n * Problem is, there's lots of calls to .focus()/.blur() on nodes\n * outside Controller::focusBlurEvents(), such as .postOrder('blur') on\n * insertion, which if MathBlock::blur becomes Node::blur, would add the\n * 'blur' CSS class to all Symbol's (because .isEmpty() is true for all\n * of them).\n *\n * I'm not even sure there aren't other troublesome calls to .focus() or\n * .blur(), so this is TODO for now.\n */\n/*****************************************\n * Deals with the browser DOM events from\n * interaction with the typist.\n ****************************************/\n\nController.open(function(_) {\n  _.keystroke = function(key, evt) {\n    this.cursor.parent.keystroke(key, evt, this);\n  };\n});\n\nNode.open(function(_) {\n  _.keystroke = function(key, e, ctrlr) {\n    var cursor = ctrlr.cursor;\n\n    switch (key) {\n    case 'Ctrl-Shift-Backspace':\n    case 'Ctrl-Backspace':\n      ctrlr.ctrlDeleteDir(L);\n      break;\n\n    case 'Shift-Backspace':\n    case 'Backspace':\n      ctrlr.backspace();\n      break;\n\n    // Tab or Esc -> go one block right if it exists, else escape right.\n    case 'Esc':\n    case 'Tab':\n      ctrlr.escapeDir(R, key, e);\n      return;\n\n    // Shift-Tab -> go one block left if it exists, else escape left.\n    case 'Shift-Tab':\n    case 'Shift-Esc':\n      ctrlr.escapeDir(L, key, e);\n      return;\n\n    // End -> move to the end of the current block.\n    case 'End':\n      ctrlr.notify('move').cursor.insAtRightEnd(cursor.parent);\n      break;\n\n    // Ctrl-End -> move all the way to the end of the root block.\n    case 'Ctrl-End':\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      break;\n\n    // Shift-End -> select to the end of the current block.\n    case 'Shift-End':\n      while (cursor[R]) {\n        ctrlr.selectRight();\n      }\n      break;\n\n    // Ctrl-Shift-End -> select to the end of the root block.\n    case 'Ctrl-Shift-End':\n      while (cursor[R] || cursor.parent !== ctrlr.root) {\n        ctrlr.selectRight();\n      }\n      break;\n\n    // Home -> move to the start of the root block or the current block.\n    case 'Home':\n      ctrlr.notify('move').cursor.insAtLeftEnd(cursor.parent);\n      break;\n\n    // Ctrl-Home -> move to the start of the current block.\n    case 'Ctrl-Home':\n      ctrlr.notify('move').cursor.insAtLeftEnd(ctrlr.root);\n      break;\n\n    // Shift-Home -> select to the start of the current block.\n    case 'Shift-Home':\n      while (cursor[L]) {\n        ctrlr.selectLeft();\n      }\n      break;\n\n    // Ctrl-Shift-Home -> move to the start of the root block.\n    case 'Ctrl-Shift-Home':\n      while (cursor[L] || cursor.parent !== ctrlr.root) {\n        ctrlr.selectLeft();\n      }\n      break;\n\n    case 'Left': ctrlr.moveLeft(); break;\n    case 'Shift-Left': ctrlr.selectLeft(); break;\n    case 'Ctrl-Left': break;\n\n    case 'Right': ctrlr.moveRight(); break;\n    case 'Shift-Right': ctrlr.selectRight(); break;\n    case 'Ctrl-Right': break;\n\n    case 'Up': ctrlr.moveUp(); break;\n    case 'Down': ctrlr.moveDown(); break;\n\n    case 'Shift-Up':\n      if (cursor[L]) {\n        while (cursor[L]) ctrlr.selectLeft();\n      } else {\n        ctrlr.selectLeft();\n      }\n\n    case 'Shift-Down':\n      if (cursor[R]) {\n        while (cursor[R]) ctrlr.selectRight();\n      }\n      else {\n        ctrlr.selectRight();\n      }\n\n    case 'Ctrl-Up': break;\n    case 'Ctrl-Down': break;\n\n    case 'Ctrl-Shift-Del':\n    case 'Ctrl-Del':\n      ctrlr.ctrlDeleteDir(R);\n      break;\n\n    case 'Shift-Del':\n    case 'Del':\n      ctrlr.deleteForward();\n      break;\n\n    case 'Meta-A':\n    case 'Ctrl-A':\n      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);\n      while (cursor[L]) ctrlr.selectLeft();\n      break;\n\n    default:\n      return;\n    }\n    e.preventDefault();\n    ctrlr.scrollHoriz();\n  };\n\n  _.moveOutOf = // called by Controller::escapeDir, moveDir\n  _.moveTowards = // called by Controller::moveDir\n  _.deleteOutOf = // called by Controller::deleteDir\n  _.deleteTowards = // called by Controller::deleteDir\n  _.unselectInto = // called by Controller::selectDir\n  _.selectOutOf = // called by Controller::selectDir\n  _.selectTowards = // called by Controller::selectDir\n    function() { pray('overridden or never called on this node'); };\n});\n\nController.open(function(_) {\n  this.onNotify(function(e) {\n    if (e === 'move' || e === 'upDown') this.show().clearSelection();\n  });\n  _.escapeDir = function(dir, key, e) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n\n    // only prevent default of Tab if not in the root editable\n    if (cursor.parent !== this.root) e.preventDefault();\n\n    // want to be a noop if in the root editable (in fact, Tab has an unrelated\n    // default browser action if so)\n    if (cursor.parent === this.root) return;\n\n    cursor.parent.moveOutOf(dir, cursor);\n    return this.notify('move');\n  };\n\n  optionProcessors.leftRightIntoCmdGoes = function(updown) {\n    if (updown && updown !== 'up' && updown !== 'down') {\n      throw '\"up\" or \"down\" required for leftRightIntoCmdGoes option, '\n            + 'got \"'+updown+'\"';\n    }\n    return updown;\n  };\n  _.moveDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor, updown = cursor.options.leftRightIntoCmdGoes;\n\n    if (cursor.selection) {\n      cursor.insDirOf(dir, cursor.selection.ends[dir]);\n    }\n    else if (cursor[dir]) cursor[dir].moveTowards(dir, cursor, updown);\n    else cursor.parent.moveOutOf(dir, cursor, updown);\n\n    return this.notify('move');\n  };\n  _.moveLeft = function() { return this.moveDir(L); };\n  _.moveRight = function() { return this.moveDir(R); };\n\n  /**\n   * moveUp and moveDown have almost identical algorithms:\n   * - first check left and right, if so insAtLeft/RightEnd of them\n   * - else check the parent's 'upOutOf'/'downOutOf' property:\n   *   + if it's a function, call it with the cursor as the sole argument and\n   *     use the return value as if it were the value of the property\n   *   + if it's a Node, jump up or down into it:\n   *     - if there is a cached Point in the block, insert there\n   *     - else, seekHoriz within the block to the current x-coordinate (to be\n   *       as close to directly above/below the current position as possible)\n   *   + unless it's exactly `true`, stop bubbling\n   */\n  _.moveUp = function() { return moveUpDown(this, 'up'); };\n  _.moveDown = function() { return moveUpDown(this, 'down'); };\n  function moveUpDown(self, dir) {\n    var cursor = self.notify('upDown').cursor;\n    var dirInto = dir+'Into', dirOutOf = dir+'OutOf';\n    if (cursor[R][dirInto]) cursor.insAtLeftEnd(cursor[R][dirInto]);\n    else if (cursor[L][dirInto]) cursor.insAtRightEnd(cursor[L][dirInto]);\n    else {\n      cursor.parent.bubble(function(ancestor) {\n        var prop = ancestor[dirOutOf];\n        if (prop) {\n          if (typeof prop === 'function') prop = ancestor[dirOutOf](cursor);\n          if (prop instanceof Node) cursor.jumpUpDown(ancestor, prop);\n          if (prop !== true) return false;\n        }\n      });\n    }\n    return self;\n  }\n  this.onNotify(function(e) { if (e !== 'upDown') this.upDownCache = {}; });\n\n  this.onNotify(function(e) { if (e === 'edit') this.show().deleteSelection(); });\n  _.deleteDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n\n    var hadSelection = cursor.selection;\n    this.notify('edit'); // deletes selection if present\n    if (!hadSelection) {\n      if (cursor[dir]) cursor[dir].deleteTowards(dir, cursor);\n      else cursor.parent.deleteOutOf(dir, cursor);\n    }\n\n    if (cursor[L].siblingDeleted) cursor[L].siblingDeleted(cursor.options, R);\n    if (cursor[R].siblingDeleted) cursor[R].siblingDeleted(cursor.options, L);\n    cursor.parent.bubble('reflow');\n\n    return this;\n  };\n  _.ctrlDeleteDir = function(dir) {\n    prayDirection(dir);\n    var cursor = this.cursor;\n    if (!cursor[L] || cursor.selection) return ctrlr.deleteDir();\n\n    this.notify('edit');\n    Fragment(cursor.parent.ends[L], cursor[L]).remove();\n    cursor.insAtDirEnd(L, cursor.parent);\n\n    if (cursor[L].siblingDeleted) cursor[L].siblingDeleted(cursor.options, R);\n    if (cursor[R].siblingDeleted) cursor[R].siblingDeleted(cursor.options, L);\n    cursor.parent.bubble('reflow');\n\n    return this;\n  };\n  _.backspace = function() { return this.deleteDir(L); };\n  _.deleteForward = function() { return this.deleteDir(R); };\n\n  this.onNotify(function(e) { if (e !== 'select') this.endSelection(); });\n  _.selectDir = function(dir) {\n    var cursor = this.notify('select').cursor, seln = cursor.selection;\n    prayDirection(dir);\n\n    if (!cursor.anticursor) cursor.startSelection();\n\n    var node = cursor[dir];\n    if (node) {\n      // \"if node we're selecting towards is inside selection (hence retracting)\n      // and is on the *far side* of the selection (hence is only node selected)\n      // and the anticursor is *inside* that node, not just on the other side\"\n      if (seln && seln.ends[dir] === node && cursor.anticursor[-dir] !== node) {\n        node.unselectInto(dir, cursor);\n      }\n      else node.selectTowards(dir, cursor);\n    }\n    else cursor.parent.selectOutOf(dir, cursor);\n\n    cursor.clearSelection();\n    cursor.select() || cursor.show();\n  };\n  _.selectLeft = function() { return this.selectDir(L); };\n  _.selectRight = function() { return this.selectDir(R); };\n});\n// Parser MathBlock\nvar latexMathParser = (function() {\n  function commandToBlock(cmd) { // can also take in a Fragment\n    var block = MathBlock();\n    cmd.adopt(block, 0, 0);\n    return block;\n  }\n  function joinBlocks(blocks) {\n    var firstBlock = blocks[0] || MathBlock();\n\n    for (var i = 1; i < blocks.length; i += 1) {\n      blocks[i].children().adopt(firstBlock, firstBlock.ends[R], 0);\n    }\n\n    return firstBlock;\n  }\n\n  var string = Parser.string;\n  var regex = Parser.regex;\n  var letter = Parser.letter;\n  var any = Parser.any;\n  var optWhitespace = Parser.optWhitespace;\n  var succeed = Parser.succeed;\n  var fail = Parser.fail;\n\n  // Parsers yielding either MathCommands, or Fragments of MathCommands\n  //   (either way, something that can be adopted by a MathBlock)\n  var variable = letter.map(function(c) { return Letter(c); });\n  var symbol = regex(/^[^${}\\\\_^]/).map(function(c) { return VanillaSymbol(c); });\n\n  var controlSequence =\n    regex(/^[^\\\\a-eg-zA-Z]/) // hotfix #164; match MathBlock::write\n    .or(string('\\\\').then(\n      regex(/^[a-z]+/i)\n      .or(regex(/^\\s+/).result(' '))\n      .or(any)\n    )).then(function(ctrlSeq) {\n      var cmdKlass = LatexCmds[ctrlSeq];\n\n      if (cmdKlass) {\n        return cmdKlass(ctrlSeq).parser();\n      }\n      else {\n        return fail('unknown command: \\\\'+ctrlSeq);\n      }\n    })\n  ;\n\n  var command =\n    controlSequence\n    .or(variable)\n    .or(symbol)\n  ;\n\n  // Parsers yielding MathBlocks\n  var mathGroup = string('{').then(function() { return mathSequence; }).skip(string('}'));\n  var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));\n  var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);\n\n  var optMathBlock =\n    string('[').then(\n      mathBlock.then(function(block) {\n        return block.join('latex') !== ']' ? succeed(block) : fail();\n      })\n      .many().map(joinBlocks).skip(optWhitespace)\n    ).skip(string(']'))\n  ;\n\n  var latexMath = mathSequence;\n\n  latexMath.block = mathBlock;\n  latexMath.optBlock = optMathBlock;\n  return latexMath;\n})();\n\nController.open(function(_, super_) {\n  _.exportLatex = function() {\n    return this.root.latex().replace(/(\\\\[a-z]+) (?![a-z])/ig,'$1');\n  };\n  _.writeLatex = function(latex) {\n    var cursor = this.notify('edit').cursor;\n\n    var all = Parser.all;\n    var eof = Parser.eof;\n\n    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);\n\n    if (block && !block.isEmpty()) {\n      block.children().adopt(cursor.parent, cursor[L], cursor[R]);\n      var jQ = block.jQize();\n      jQ.insertBefore(cursor.jQ);\n      cursor[L] = block.ends[R];\n      block.finalizeInsert(cursor.options, cursor);\n      if (block.ends[R][R].siblingCreated) block.ends[R][R].siblingCreated(cursor.options, L);\n      if (block.ends[L][L].siblingCreated) block.ends[L][L].siblingCreated(cursor.options, R);\n      cursor.parent.bubble('reflow');\n    }\n\n    return this;\n  };\n  _.renderLatexMath = function(latex) {\n    var root = this.root, cursor = this.cursor;\n\n    var all = Parser.all;\n    var eof = Parser.eof;\n\n    var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);\n\n    root.eachChild('postOrder', 'dispose');\n    root.ends[L] = root.ends[R] = 0;\n\n    if (block) {\n      block.children().adopt(root, 0, 0);\n    }\n\n    var jQ = root.jQ;\n\n    if (block) {\n      var html = block.join('html');\n      jQ.html(html);\n      root.jQize(jQ.children());\n      root.finalizeInsert(cursor.options);\n    }\n    else {\n      jQ.empty();\n    }\n\n    delete cursor.selection;\n    cursor.insAtRightEnd(root);\n  };\n  _.renderLatexText = function(latex) {\n    var root = this.root, cursor = this.cursor;\n\n    root.jQ.children().slice(1).remove();\n    root.eachChild('postOrder', 'dispose');\n    root.ends[L] = root.ends[R] = 0;\n    delete cursor.selection;\n    cursor.show().insAtRightEnd(root);\n\n    var regex = Parser.regex;\n    var string = Parser.string;\n    var eof = Parser.eof;\n    var all = Parser.all;\n\n    // Parser RootMathCommand\n    var mathMode = string('$').then(latexMathParser)\n      // because TeX is insane, math mode doesn't necessarily\n      // have to end.  So we allow for the case that math mode\n      // continues to the end of the stream.\n      .skip(string('$').or(eof))\n      .map(function(block) {\n        // HACK FIXME: this shouldn't have to have access to cursor\n        var rootMathCommand = RootMathCommand(cursor);\n\n        rootMathCommand.createBlocks();\n        var rootMathBlock = rootMathCommand.ends[L];\n        block.children().adopt(rootMathBlock, 0, 0);\n\n        return rootMathCommand;\n      })\n    ;\n\n    var escapedDollar = string('\\\\$').result('$');\n    var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);\n    var latexText = mathMode.or(textChar).many();\n    var commands = latexText.skip(eof).or(all.result(false)).parse(latex);\n\n    if (commands) {\n      for (var i = 0; i < commands.length; i += 1) {\n        commands[i].adopt(root, root.ends[R], 0);\n      }\n\n      root.jQize().appendTo(root.jQ);\n\n      root.finalizeInsert(cursor.options);\n    }\n  };\n});\n/********************************************************\n * Deals with mouse events for clicking, drag-to-select\n *******************************************************/\n\nController.open(function(_) {\n  Options.p.ignoreNextMousedown = noop;\n  _.delegateMouseEvents = function() {\n    var ultimateRootjQ = this.root.jQ;\n    //drag-to-select event handling\n    this.container.bind('mousedown.mathquill', function(e) {\n      var rootjQ = $(e.target).closest('.mq-root-block');\n      var root = Node.byId[rootjQ.attr(mqBlockId) || ultimateRootjQ.attr(mqBlockId)];\n      var ctrlr = root.controller, cursor = ctrlr.cursor, blink = cursor.blink;\n      var textareaSpan = ctrlr.textareaSpan, textarea = ctrlr.textarea;\n\n      e.preventDefault(); // doesn't work in IE\\u22648, but it's a one-line fix:\n      e.target.unselectable = true; // http://jsbin.com/yagekiji/1\n\n      if (cursor.options.ignoreNextMousedown(e)) return;\n      else cursor.options.ignoreNextMousedown = noop;\n\n      var target;\n      function mousemove(e) { target = $(e.target); }\n      function docmousemove(e) {\n        if (!cursor.anticursor) cursor.startSelection();\n        ctrlr.seek(target, e.pageX, e.pageY).cursor.select();\n        target = undefined;\n      }\n      // outside rootjQ, the MathQuill node corresponding to the target (if any)\n      // won't be inside this root, so don't mislead Controller::seek with it\n\n      function mouseup(e) {\n        cursor.blink = blink;\n        if (!cursor.selection) {\n          if (ctrlr.editable) {\n            cursor.show();\n          }\n          else {\n            textareaSpan.detach();\n          }\n        }\n\n        // delete the mouse handlers now that we're not dragging anymore\n        rootjQ.unbind('mousemove', mousemove);\n        $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);\n      }\n\n      if (ctrlr.blurred) {\n        if (!ctrlr.editable) rootjQ.prepend(textareaSpan);\n        textarea.focus();\n      }\n\n      cursor.blink = noop;\n      ctrlr.seek($(e.target), e.pageX, e.pageY).cursor.startSelection();\n\n      rootjQ.mousemove(mousemove);\n      $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);\n      // listen on document not just body to not only hear about mousemove and\n      // mouseup on page outside field, but even outside page, except iframes: https://github.com/mathquill/mathquill/commit/8c50028afcffcace655d8ae2049f6e02482346c5#commitcomment-6175800\n    });\n  }\n});\n\nController.open(function(_) {\n  _.seek = function(target, pageX, pageY) {\n    var cursor = this.notify('select').cursor;\n\n    if (target) {\n      var nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);\n      if (!nodeId) {\n        var targetParent = target.parent();\n        nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);\n      }\n    }\n    var node = nodeId ? Node.byId[nodeId] : this.root;\n    pray('nodeId is the id of some Node that exists', node);\n\n    // don't clear selection until after getting node from target, in case\n    // target was selection span, otherwise target will have no parent and will\n    // seek from root, which is less accurate (e.g. fraction)\n    cursor.clearSelection().show();\n\n    node.seek(pageX, cursor);\n    this.scrollHoriz(); // before .selectFrom when mouse-selecting, so\n                        // always hits no-selection case in scrollHoriz and scrolls slower\n    return this;\n  };\n});\n/***********************************************\n * Horizontal panning for editable fields that\n * overflow their width\n **********************************************/\n\nController.open(function(_) {\n  _.scrollHoriz = function() {\n    var cursor = this.cursor, seln = cursor.selection;\n    var rootRect = this.root.jQ[0].getBoundingClientRect();\n    if (!seln) {\n      var x = cursor.jQ[0].getBoundingClientRect().left;\n      if (x > rootRect.right - 20) var scrollBy = x - (rootRect.right - 20);\n      else if (x < rootRect.left + 20) var scrollBy = x - (rootRect.left + 20);\n      else return;\n    }\n    else {\n      var rect = seln.jQ[0].getBoundingClientRect();\n      var overLeft = rect.left - (rootRect.left + 20);\n      var overRight = rect.right - (rootRect.right - 20);\n      if (seln.ends[L] === cursor[R]) {\n        if (overLeft < 0) var scrollBy = overLeft;\n        else if (overRight > 0) {\n          if (rect.left - overRight < rootRect.left + 20) var scrollBy = overLeft;\n          else var scrollBy = overRight;\n        }\n        else return;\n      }\n      else {\n        if (overRight > 0) var scrollBy = overRight;\n        else if (overLeft < 0) {\n          if (rect.right - overLeft > rootRect.right - 20) var scrollBy = overRight;\n          else var scrollBy = overLeft;\n        }\n        else return;\n      }\n    }\n    this.root.jQ.stop().animate({ scrollLeft: '+=' + scrollBy}, 100);\n  };\n});\n/*********************************************\n * Manage the MathQuill instance's textarea\n * (as owned by the Controller)\n ********************************************/\n\nController.open(function(_) {\n  Options.p.substituteTextarea = function() {\n    return $('<textarea autocapitalize=off autocomplete=off autocorrect=off ' +\n               'spellcheck=false x-palm-disable-ste-all=true />')[0];\n  };\n  _.createTextarea = function() {\n    var textareaSpan = this.textareaSpan = $('<span class=\"mq-textarea\"></span>'),\n      textarea = this.options.substituteTextarea();\n    if (!textarea.nodeType) {\n      throw 'substituteTextarea() must return a DOM element, got ' + textarea;\n    }\n    textarea = this.textarea = $(textarea).appendTo(textareaSpan);\n\n    var ctrlr = this;\n    ctrlr.cursor.selectionChanged = function() { ctrlr.selectionChanged(); };\n    ctrlr.container.bind('copy', function() { ctrlr.setTextareaSelection(); });\n  };\n  _.selectionChanged = function() {\n    var ctrlr = this;\n    forceIERedraw(ctrlr.container[0]);\n\n    // throttle calls to setTextareaSelection(), because setting textarea.value\n    // and/or calling textarea.select() can have anomalously bad performance:\n    // https://github.com/mathquill/mathquill/issues/43#issuecomment-1399080\n    if (ctrlr.textareaSelectionTimeout === undefined) {\n      ctrlr.textareaSelectionTimeout = setTimeout(function() {\n        ctrlr.setTextareaSelection();\n      });\n    }\n  };\n  _.setTextareaSelection = function() {\n    this.textareaSelectionTimeout = undefined;\n    var latex = '';\n    if (this.cursor.selection) {\n      latex = this.cursor.selection.join('latex');\n      if (this.options.statelessClipboard) {\n        // FIXME: like paste, only this works for math fields; should ask parent\n        latex = '$' + latex + '$';\n      }\n    }\n    this.selectFn(latex);\n  };\n  _.staticMathTextareaEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor,\n      textarea = ctrlr.textarea, textareaSpan = ctrlr.textareaSpan;\n\n    this.container.prepend('<span class=\"mq-selectable\">$'+ctrlr.exportLatex()+'$</span>');\n    ctrlr.blurred = true;\n    textarea.bind('cut paste', false)\n    .focus(function() { ctrlr.blurred = false; }).blur(function() {\n      if (cursor.selection) cursor.selection.clear();\n      setTimeout(detach); //detaching during blur explodes in WebKit\n    });\n    function detach() {\n      textareaSpan.detach();\n      ctrlr.blurred = true;\n    }\n\n    ctrlr.selectFn = function(text) {\n      textarea.val(text);\n      if (text) textarea.select();\n    };\n  };\n  _.editablesTextareaEvents = function() {\n    var ctrlr = this, root = ctrlr.root, cursor = ctrlr.cursor,\n      textarea = ctrlr.textarea, textareaSpan = ctrlr.textareaSpan;\n\n    var keyboardEventsShim = saneKeyboardEvents(textarea, this);\n    this.selectFn = function(text) { keyboardEventsShim.select(text); };\n\n    this.container.prepend(textareaSpan)\n    .on('cut', function(e) {\n      if (cursor.selection) {\n        setTimeout(function() {\n          ctrlr.notify('edit'); // deletes selection if present\n          cursor.parent.bubble('reflow');\n        });\n      }\n    });\n\n    this.focusBlurEvents();\n  };\n  _.typedText = function(ch) {\n    if (ch === '\\n') return this.handle('enter');\n    var cursor = this.notify().cursor;\n    cursor.parent.write(cursor, ch);\n    this.scrollHoriz();\n  };\n  _.paste = function(text) {\n    // TODO: document `statelessClipboard` config option in README, after\n    // making it work like it should, that is, in both text and math mode\n    // (currently only works in math fields, so worse than pointless, it\n    //  only gets in the way by \\text{}-ifying pasted stuff and $-ifying\n    //  cut/copied LaTeX)\n    if (this.options.statelessClipboard) {\n      if (text.slice(0,1) === '$' && text.slice(-1) === '$') {\n        text = text.slice(1, -1);\n      }\n      else {\n        text = '\\\\text{'+text+'}';\n      }\n    }\n    // FIXME: this always inserts math or a TextBlock, even in a RootTextBlock\n    this.writeLatex(text).cursor.show();\n  };\n});\n/*************************************************\n * Abstract classes of math blocks and commands.\n ************************************************/\n\n/**\n * Math tree node base class.\n * Some math-tree-specific extensions to Node.\n * Both MathBlock's and MathCommand's descend from it.\n */\nvar MathElement = P(Node, function(_, super_) {\n  _.finalizeInsert = function(options, cursor) { // `cursor` param is only for\n      // SupSub::contactWeld, and is deliberately only passed in by writeLatex,\n      // see ea7307eb4fac77c149a11ffdf9a831df85247693\n    var self = this;\n    self.postOrder('finalizeTree', options);\n    self.postOrder('contactWeld', cursor);\n\n    // note: this order is important.\n    // empty elements need the empty box provided by blur to\n    // be present in order for their dimensions to be measured\n    // correctly by 'reflow' handlers.\n    self.postOrder('blur');\n\n    self.postOrder('reflow');\n    if (self[R].siblingCreated) self[R].siblingCreated(options, L);\n    if (self[L].siblingCreated) self[L].siblingCreated(options, R);\n    self.bubble('reflow');\n  };\n});\n\n/**\n * Commands and operators, like subscripts, exponents, or fractions.\n * Descendant commands are organized into blocks.\n */\nvar MathCommand = P(MathElement, function(_, super_) {\n  _.init = function(ctrlSeq, htmlTemplate, textTemplate) {\n    var cmd = this;\n    super_.init.call(cmd);\n\n    if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;\n    if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;\n    if (textTemplate) cmd.textTemplate = textTemplate;\n  };\n\n  // obvious methods\n  _.replaces = function(replacedFragment) {\n    replacedFragment.disown();\n    this.replacedFragment = replacedFragment;\n  };\n  _.isEmpty = function() {\n    return this.foldChildren(true, function(isEmpty, child) {\n      return isEmpty && child.isEmpty();\n    });\n  };\n\n  _.parser = function() {\n    var block = latexMathParser.block;\n    var self = this;\n\n    return block.times(self.numBlocks()).map(function(blocks) {\n      self.blocks = blocks;\n\n      for (var i = 0; i < blocks.length; i += 1) {\n        blocks[i].adopt(self, self.ends[R], 0);\n      }\n\n      return self;\n    });\n  };\n\n  // createLeftOf(cursor) and the methods it calls\n  _.createLeftOf = function(cursor) {\n    var cmd = this;\n    var replacedFragment = cmd.replacedFragment;\n\n    cmd.createBlocks();\n    super_.createLeftOf.call(cmd, cursor);\n    if (replacedFragment) {\n      replacedFragment.adopt(cmd.ends[L], 0, 0);\n      replacedFragment.jQ.appendTo(cmd.ends[L].jQ);\n    }\n    cmd.finalizeInsert(cursor.options);\n    cmd.placeCursor(cursor);\n  };\n  _.createBlocks = function() {\n    var cmd = this,\n      numBlocks = cmd.numBlocks(),\n      blocks = cmd.blocks = Array(numBlocks);\n\n    for (var i = 0; i < numBlocks; i += 1) {\n      var newBlock = blocks[i] = MathBlock();\n      newBlock.adopt(cmd, cmd.ends[R], 0);\n    }\n  };\n  _.placeCursor = function(cursor) {\n    //insert the cursor at the right end of the first empty child, searching\n    //left-to-right, or if none empty, the right end child\n    cursor.insAtRightEnd(this.foldChildren(this.ends[L], function(leftward, child) {\n      return leftward.isEmpty() ? leftward : child;\n    }));\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveTowards = function(dir, cursor, updown) {\n    var updownInto = updown && this[updown+'Into'];\n    cursor.insAtDirEnd(-dir, updownInto || this.ends[-dir]);\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (this.isEmpty()) cursor[dir] = this.remove()[dir];\n    else this.moveTowards(dir, cursor, null);\n  };\n  _.selectTowards = function(dir, cursor) {\n    cursor[-dir] = this;\n    cursor[dir] = this[dir];\n  };\n  _.selectChildren = function() {\n    return Selection(this, this);\n  };\n  _.unselectInto = function(dir, cursor) {\n    cursor.insAtDirEnd(-dir, cursor.anticursor.ancestors[this.id]);\n  };\n  _.seek = function(pageX, cursor) {\n    function getBounds(node) {\n      var bounds = {}\n      bounds[L] = node.jQ.offset().left;\n      bounds[R] = bounds[L] + node.jQ.outerWidth();\n      return bounds;\n    }\n\n    var cmd = this;\n    var cmdBounds = getBounds(cmd);\n\n    if (pageX < cmdBounds[L]) return cursor.insLeftOf(cmd);\n    if (pageX > cmdBounds[R]) return cursor.insRightOf(cmd);\n\n    var leftLeftBound = cmdBounds[L];\n    cmd.eachChild(function(block) {\n      var blockBounds = getBounds(block);\n      if (pageX < blockBounds[L]) {\n        // closer to this block's left bound, or the bound left of that?\n        if (pageX - leftLeftBound < blockBounds[L] - pageX) {\n          if (block[L]) cursor.insAtRightEnd(block[L]);\n          else cursor.insLeftOf(cmd);\n        }\n        else cursor.insAtLeftEnd(block);\n        return false;\n      }\n      else if (pageX > blockBounds[R]) {\n        if (block[R]) leftLeftBound = blockBounds[R]; // continue to next block\n        else { // last (rightmost) block\n          // closer to this block's right bound, or the cmd's right bound?\n          if (cmdBounds[R] - pageX < pageX - blockBounds[R]) {\n            cursor.insRightOf(cmd);\n          }\n          else cursor.insAtRightEnd(block);\n        }\n      }\n      else {\n        block.seek(pageX, cursor);\n        return false;\n      }\n    });\n  }\n\n  // methods involved in creating and cross-linking with HTML DOM nodes\n  /*\n    They all expect an .htmlTemplate like\n      '<span>&0</span>'\n    or\n      '<span><span>&0</span><span>&1</span></span>'\n\n    See html.test.js for more examples.\n\n    Requirements:\n    - For each block of the command, there must be exactly one \"block content\n      marker\" of the form '&<number>' where <number> is the 0-based index of the\n      block. (Like the LaTeX \\newcommand syntax, but with a 0-based rather than\n      1-based index, because JavaScript because C because Dijkstra.)\n    - The block content marker must be the sole contents of the containing\n      element, there can't even be surrounding whitespace, or else we can't\n      guarantee sticking to within the bounds of the block content marker when\n      mucking with the HTML DOM.\n    - The HTML not only must be well-formed HTML (of course), but also must\n      conform to the XHTML requirements on tags, specifically all tags must\n      either be self-closing (like '<br/>') or come in matching pairs.\n      Close tags are never optional.\n\n    Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',\n    your HTML template would have to have '&amp;123'.\n  */\n  _.numBlocks = function() {\n    var matches = this.htmlTemplate.match(/&\\d+/g);\n    return matches ? matches.length : 0;\n  };\n  _.html = function() {\n    // Render the entire math subtree rooted at this command, as HTML.\n    // Expects .createBlocks() to have been called already, since it uses the\n    // .blocks array of child blocks.\n    //\n    // See html.test.js for example templates and intended outputs.\n    //\n    // Given an .htmlTemplate as described above,\n    // - insert the mathquill-command-id attribute into all top-level tags,\n    //   which will be used to set this.jQ in .jQize().\n    //   This is straightforward:\n    //     * tokenize into tags and non-tags\n    //     * loop through top-level tokens:\n    //         * add #cmdId attribute macro to top-level self-closing tags\n    //         * else add #cmdId attribute macro to top-level open tags\n    //             * skip the matching top-level close tag and all tag pairs\n    //               in between\n    // - for each block content marker,\n    //     + replace it with the contents of the corresponding block,\n    //       rendered as HTML\n    //     + insert the mathquill-block-id attribute into the containing tag\n    //   This is even easier, a quick regex replace, since block tags cannot\n    //   contain anything besides the block content marker.\n    //\n    // Two notes:\n    // - The outermost loop through top-level tokens should never encounter any\n    //   top-level close tags, because we should have first encountered a\n    //   matching top-level open tag, all inner tags should have appeared in\n    //   matching pairs and been skipped, and then we should have skipped the\n    //   close tag in question.\n    // - All open tags should have matching close tags, which means our inner\n    //   loop should always encounter a close tag and drop nesting to 0. If\n    //   a close tag is missing, the loop will continue until i >= tokens.length\n    //   and token becomes undefined. This will not infinite loop, even in\n    //   production without pray(), because it will then TypeError on .slice().\n\n    var cmd = this;\n    var blocks = cmd.blocks;\n    var cmdId = ' mathquill-command-id=' + cmd.id;\n    var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);\n\n    pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);\n\n    // add cmdId to all top-level tags\n    for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {\n      // top-level self-closing tags\n      if (token.slice(-2) === '/>') {\n        tokens[i] = token.slice(0,-2) + cmdId + '/>';\n      }\n      // top-level open tags\n      else if (token.charAt(0) === '<') {\n        pray('not an unmatched top-level close tag', token.charAt(1) !== '/');\n\n        tokens[i] = token.slice(0,-1) + cmdId + '>';\n\n        // skip matching top-level close tag and all tag pairs in between\n        var nesting = 1;\n        do {\n          i += 1, token = tokens[i];\n          pray('no missing close tags', token);\n          // close tags\n          if (token.slice(0,2) === '</') {\n            nesting -= 1;\n          }\n          // non-self-closing open tags\n          else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {\n            nesting += 1;\n          }\n        } while (nesting > 0);\n      }\n    }\n    return tokens.join('').replace(/>&(\\d+)/g, function($0, $1) {\n      return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');\n    });\n  };\n\n  // methods to export a string representation of the math tree\n  _.latex = function() {\n    return this.foldChildren(this.ctrlSeq, function(latex, child) {\n      return latex + '{' + (child.latex() || ' ') + '}';\n    });\n  };\n  _.textTemplate = [''];\n  _.text = function() {\n    var cmd = this, i = 0;\n    return cmd.foldChildren(cmd.textTemplate[i], function(text, child) {\n      i += 1;\n      var child_text = child.text();\n      if (text && cmd.textTemplate[i] === '('\n          && child_text[0] === '(' && child_text.slice(-1) === ')')\n        return text + child_text.slice(1, -1) + cmd.textTemplate[i];\n      return text + child.text() + (cmd.textTemplate[i] || '');\n    });\n  };\n});\n\n/**\n * Lightweight command without blocks or children.\n */\nvar Symbol = P(MathCommand, function(_, super_) {\n  _.init = function(ctrlSeq, html, text) {\n    if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;\n\n    super_.init.call(this, ctrlSeq, html, [ text ]);\n  };\n\n  _.parser = function() { return Parser.succeed(this); };\n  _.numBlocks = function() { return 0; };\n\n  _.replaces = function(replacedFragment) {\n    replacedFragment.remove();\n  };\n  _.createBlocks = noop;\n\n  _.moveTowards = function(dir, cursor) {\n    cursor.jQ.insDirOf(dir, this.jQ);\n    cursor[-dir] = this;\n    cursor[dir] = this[dir];\n  };\n  _.deleteTowards = function(dir, cursor) {\n    cursor[dir] = this.remove()[dir];\n  };\n  _.seek = function(pageX, cursor) {\n    // insert at whichever side the click was closer to\n    if (pageX - this.jQ.offset().left < this.jQ.outerWidth()/2)\n      cursor.insLeftOf(this);\n    else\n      cursor.insRightOf(this);\n  };\n\n  _.latex = function(){ return this.ctrlSeq; };\n  _.text = function(){ return this.textTemplate; };\n  _.placeCursor = noop;\n  _.isEmpty = function(){ return true; };\n});\nvar VanillaSymbol = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<span>'+(html || ch)+'</span>');\n  };\n});\nvar BinaryOperator = P(Symbol, function(_, super_) {\n  _.init = function(ctrlSeq, html, text) {\n    super_.init.call(this,\n      ctrlSeq, '<span class=\"mq-binary-operator\">'+html+'</span>', text\n    );\n  };\n});\n\n/**\n * Children and parent of MathCommand's. Basically partitions all the\n * symbols and operators that descend (in the Math DOM tree) from\n * ancestor operators.\n */\nvar MathBlock = P(MathElement, function(_, super_) {\n  _.join = function(methodName) {\n    return this.foldChildren('', function(fold, child) {\n      return fold + child[methodName]();\n    });\n  };\n  _.html = function() { return this.join('html'); };\n  _.latex = function() { return this.join('latex'); };\n  _.text = function() {\n    return (this.ends[L] === this.ends[R] && this.ends[L] !== 0) ?\n      this.ends[L].text() :\n      this.join('text')\n    ;\n  };\n\n  _.keystroke = function(key, e, ctrlr) {\n    if (ctrlr.options.spaceBehavesLikeTab\n        && (key === 'Spacebar' || key === 'Shift-Spacebar')) {\n      e.preventDefault();\n      ctrlr.escapeDir(key === 'Shift-Spacebar' ? L : R, key, e);\n      return;\n    }\n    return super_.keystroke.apply(this, arguments);\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveOutOf = function(dir, cursor, updown) {\n    var updownInto = updown && this.parent[updown+'Into'];\n    if (!updownInto && this[dir]) cursor.insAtDirEnd(-dir, this[dir]);\n    else cursor.insDirOf(dir, this.parent);\n  };\n  _.selectOutOf = function(dir, cursor) {\n    cursor.insDirOf(dir, this.parent);\n  };\n  _.deleteOutOf = function(dir, cursor) {\n    cursor.unwrapGramp();\n  };\n  _.seek = function(pageX, cursor) {\n    var node = this.ends[R];\n    if (!node || node.jQ.offset().left + node.jQ.outerWidth() < pageX) {\n      return cursor.insAtRightEnd(this);\n    }\n    if (pageX < this.ends[L].jQ.offset().left) return cursor.insAtLeftEnd(this);\n    while (pageX < node.jQ.offset().left) node = node[L];\n    return node.seek(pageX, cursor);\n  };\n  _.chToCmd = function(ch) {\n    var cons;\n    // exclude f because it gets a dedicated command with more spacing\n    if (ch.match(/^[a-eg-zA-Z]$/))\n      return Letter(ch);\n    else if (/^\\d$/.test(ch))\n      return Digit(ch);\n    else if (cons = CharCmds[ch] || LatexCmds[ch])\n      return cons(ch);\n    else\n      return VanillaSymbol(ch);\n  };\n  _.write = function(cursor, ch) {\n    var cmd = this.chToCmd(ch);\n    if (cursor.selection) cmd.replaces(cursor.replaceSelection());\n    cmd.createLeftOf(cursor.show());\n  };\n\n  _.focus = function() {\n    this.jQ.addClass('mq-hasCursor');\n    this.jQ.removeClass('mq-empty');\n\n    return this;\n  };\n  _.blur = function() {\n    this.jQ.removeClass('mq-hasCursor');\n    if (this.isEmpty())\n      this.jQ.addClass('mq-empty');\n\n    return this;\n  };\n});\n\nAPI.StaticMath = function(APIClasses) {\n  return P(APIClasses.AbstractMathQuill, function(_, super_) {\n    this.RootBlock = MathBlock;\n    _.__mathquillify = function() {\n      super_.__mathquillify.call(this, 'mq-math-mode');\n      this.__controller.delegateMouseEvents();\n      this.__controller.staticMathTextareaEvents();\n      return this;\n    };\n    _.init = function() {\n      super_.init.apply(this, arguments);\n      this.__controller.root.postOrder(\n        'registerInnerField', this.innerFields = [], APIClasses.MathField);\n    };\n    _.latex = function() {\n      var returned = super_.latex.apply(this, arguments);\n      if (arguments.length > 0) {\n        this.__controller.root.postOrder(\n          'registerInnerField', this.innerFields = [], APIClasses.MathField);\n      }\n      return returned;\n    };\n  });\n};\n\nvar RootMathBlock = P(MathBlock, RootBlockMixin);\nAPI.MathField = function(APIClasses) {\n  return P(APIClasses.EditableField, function(_, super_) {\n    this.RootBlock = RootMathBlock;\n    _.__mathquillify = function(opts, interfaceVersion) {\n      this.config(opts);\n      if (interfaceVersion > 1) this.__controller.root.reflow = noop;\n      super_.__mathquillify.call(this, 'mq-editable-field mq-math-mode');\n      delete this.__controller.root.reflow;\n      return this;\n    };\n  });\n};\n/*************************************************\n * Abstract classes of text blocks\n ************************************************/\n\n/**\n * Blocks of plain text, with one or two TextPiece's as children.\n * Represents flat strings of typically serif-font Roman characters, as\n * opposed to hierchical, nested, tree-structured math.\n * Wraps a single HTMLSpanElement.\n */\nvar TextBlock = P(Node, function(_, super_) {\n  _.ctrlSeq = '\\\\text';\n\n  _.replaces = function(replacedText) {\n    if (replacedText instanceof Fragment)\n      this.replacedText = replacedText.remove().jQ.text();\n    else if (typeof replacedText === 'string')\n      this.replacedText = replacedText;\n  };\n\n  _.jQadd = function(jQ) {\n    super_.jQadd.call(this, jQ);\n    if (this.ends[L]) this.ends[L].jQadd(this.jQ[0].firstChild);\n  };\n\n  _.createLeftOf = function(cursor) {\n    var textBlock = this;\n    super_.createLeftOf.call(this, cursor);\n\n    if (textBlock[R].siblingCreated) textBlock[R].siblingCreated(cursor.options, L);\n    if (textBlock[L].siblingCreated) textBlock[L].siblingCreated(cursor.options, R);\n    textBlock.bubble('reflow');\n\n    cursor.insAtRightEnd(textBlock);\n\n    if (textBlock.replacedText)\n      for (var i = 0; i < textBlock.replacedText.length; i += 1)\n        textBlock.write(cursor, textBlock.replacedText.charAt(i));\n  };\n\n  _.parser = function() {\n    var textBlock = this;\n\n    // TODO: correctly parse text mode\n    var string = Parser.string;\n    var regex = Parser.regex;\n    var optWhitespace = Parser.optWhitespace;\n    return optWhitespace\n      .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))\n      .map(function(text) {\n        if (text.length === 0) return Fragment();\n\n        TextPiece(text).adopt(textBlock, 0, 0);\n        return textBlock;\n      })\n    ;\n  };\n\n  _.textContents = function() {\n    return this.foldChildren('', function(text, child) {\n      return text + child.text;\n    });\n  };\n  _.text = function() { return '\"' + this.textContents() + '\"'; };\n  _.latex = function() {\n    var contents = this.textContents();\n    if (contents.length === 0) return '';\n    return '\\\\text{' + contents + '}';\n  };\n  _.html = function() {\n    return (\n        '<span class=\"mq-text-mode\" mathquill-command-id='+this.id+'>'\n      +   this.textContents()\n      + '</span>'\n    );\n  };\n\n  // editability methods: called by the cursor for editing, cursor movements,\n  // and selection of the MathQuill tree, these all take in a direction and\n  // the cursor\n  _.moveTowards = function(dir, cursor) { cursor.insAtDirEnd(-dir, this); };\n  _.moveOutOf = function(dir, cursor) { cursor.insDirOf(dir, this); };\n  _.unselectInto = _.moveTowards;\n\n  // TODO: make these methods part of a shared mixin or something.\n  _.selectTowards = MathCommand.prototype.selectTowards;\n  _.deleteTowards = MathCommand.prototype.deleteTowards;\n\n  _.selectOutOf = function(dir, cursor) {\n    cursor.insDirOf(dir, this);\n  };\n  _.deleteOutOf = function(dir, cursor) {\n    // backspace and delete at ends of block don't unwrap\n    if (this.isEmpty()) cursor.insRightOf(this);\n  };\n  _.write = function(cursor, ch) {\n    cursor.show().deleteSelection();\n\n    if (ch !== '$') {\n      if (!cursor[L]) TextPiece(ch).createLeftOf(cursor);\n      else cursor[L].appendText(ch);\n    }\n    else if (this.isEmpty()) {\n      cursor.insRightOf(this);\n      VanillaSymbol('\\\\$','$').createLeftOf(cursor);\n    }\n    else if (!cursor[R]) cursor.insRightOf(this);\n    else if (!cursor[L]) cursor.insLeftOf(this);\n    else { // split apart\n      var leftBlock = TextBlock();\n      var leftPc = this.ends[L];\n      leftPc.disown().jQ.detach();\n      leftPc.adopt(leftBlock, 0, 0);\n\n      cursor.insLeftOf(this);\n      super_.createLeftOf.call(leftBlock, cursor);\n    }\n  };\n\n  _.seek = function(pageX, cursor) {\n    cursor.hide();\n    var textPc = fuseChildren(this);\n\n    // insert cursor at approx position in DOMTextNode\n    var avgChWidth = this.jQ.width()/this.text.length;\n    var approxPosition = Math.round((pageX - this.jQ.offset().left)/avgChWidth);\n    if (approxPosition <= 0) cursor.insAtLeftEnd(this);\n    else if (approxPosition >= textPc.text.length) cursor.insAtRightEnd(this);\n    else cursor.insLeftOf(textPc.splitRight(approxPosition));\n\n    // move towards mousedown (pageX)\n    var displ = pageX - cursor.show().offset().left; // displacement\n    var dir = displ && displ < 0 ? L : R;\n    var prevDispl = dir;\n    // displ * prevDispl > 0 iff displacement direction === previous direction\n    while (cursor[dir] && displ * prevDispl > 0) {\n      cursor[dir].moveTowards(dir, cursor);\n      prevDispl = displ;\n      displ = pageX - cursor.offset().left;\n    }\n    if (dir*displ < -dir*prevDispl) cursor[-dir].moveTowards(-dir, cursor);\n\n    if (!cursor.anticursor) {\n      // about to start mouse-selecting, the anticursor is gonna get put here\n      this.anticursorPosition = cursor[L] && cursor[L].text.length;\n      // ^ get it? 'cos if there's no cursor[L], it's 0... I'm a terrible person.\n    }\n    else if (cursor.anticursor.parent === this) {\n      // mouse-selecting within this TextBlock, re-insert the anticursor\n      var cursorPosition = cursor[L] && cursor[L].text.length;;\n      if (this.anticursorPosition === cursorPosition) {\n        cursor.anticursor = Point.copy(cursor);\n      }\n      else {\n        if (this.anticursorPosition < cursorPosition) {\n          var newTextPc = cursor[L].splitRight(this.anticursorPosition);\n          cursor[L] = newTextPc;\n        }\n        else {\n          var newTextPc = cursor[R].splitRight(this.anticursorPosition - cursorPosition);\n        }\n        cursor.anticursor = Point(this, newTextPc[L], newTextPc);\n      }\n    }\n  };\n\n  _.blur = function(cursor) {\n    MathBlock.prototype.blur.call(this);\n    if (!cursor) return;\n    if (this.textContents() === '') {\n      this.remove();\n      if (cursor[L] === this) cursor[L] = this[L];\n      else if (cursor[R] === this) cursor[R] = this[R];\n    }\n    else fuseChildren(this);\n  };\n\n  function fuseChildren(self) {\n    self.jQ[0].normalize();\n\n    var textPcDom = self.jQ[0].firstChild;\n    if (!textPcDom) return;\n    pray('only node in TextBlock span is Text node', textPcDom.nodeType === 3);\n    // nodeType === 3 has meant a Text node since ancient times:\n    //   http://reference.sitepoint.com/javascript/Node/nodeType\n\n    var textPc = TextPiece(textPcDom.data);\n    textPc.jQadd(textPcDom);\n\n    self.children().disown();\n    return textPc.adopt(self, 0, 0);\n  }\n\n  _.focus = MathBlock.prototype.focus;\n});\n\n/**\n * Piece of plain text, with a TextBlock as a parent and no children.\n * Wraps a single DOMTextNode.\n * For convenience, has a .text property that's just a JavaScript string\n * mirroring the text contents of the DOMTextNode.\n * Text contents must always be nonempty.\n */\nvar TextPiece = P(Node, function(_, super_) {\n  _.init = function(text) {\n    super_.init.call(this);\n    this.text = text;\n  };\n  _.jQadd = function(dom) { this.dom = dom; this.jQ = $(dom); };\n  _.jQize = function() {\n    return this.jQadd(document.createTextNode(this.text));\n  };\n  _.appendText = function(text) {\n    this.text += text;\n    this.dom.appendData(text);\n  };\n  _.prependText = function(text) {\n    this.text = text + this.text;\n    this.dom.insertData(0, text);\n  };\n  _.insTextAtDirEnd = function(text, dir) {\n    prayDirection(dir);\n    if (dir === R) this.appendText(text);\n    else this.prependText(text);\n  };\n  _.splitRight = function(i) {\n    var newPc = TextPiece(this.text.slice(i)).adopt(this.parent, this, this[R]);\n    newPc.jQadd(this.dom.splitText(i));\n    this.text = this.text.slice(0, i);\n    return newPc;\n  };\n\n  function endChar(dir, text) {\n    return text.charAt(dir === L ? 0 : -1 + text.length);\n  }\n\n  _.moveTowards = function(dir, cursor) {\n    prayDirection(dir);\n\n    var ch = endChar(-dir, this.text)\n\n    var from = this[-dir];\n    if (from) from.insTextAtDirEnd(ch, dir);\n    else TextPiece(ch).createDir(-dir, cursor);\n\n    return this.deleteTowards(dir, cursor);\n  };\n\n  _.latex = function() { return this.text; };\n\n  _.deleteTowards = function(dir, cursor) {\n    if (this.text.length > 1) {\n      if (dir === R) {\n        this.dom.deleteData(0, 1);\n        this.text = this.text.slice(1);\n      }\n      else {\n        // note that the order of these 2 lines is annoyingly important\n        // (the second line mutates this.text.length)\n        this.dom.deleteData(-1 + this.text.length, 1);\n        this.text = this.text.slice(0, -1);\n      }\n    }\n    else {\n      this.remove();\n      this.jQ.remove();\n      cursor[dir] = this[dir];\n    }\n  };\n\n  _.selectTowards = function(dir, cursor) {\n    prayDirection(dir);\n    var anticursor = cursor.anticursor;\n\n    var ch = endChar(-dir, this.text)\n\n    if (anticursor[dir] === this) {\n      var newPc = TextPiece(ch).createDir(dir, cursor);\n      anticursor[dir] = newPc;\n      cursor.insDirOf(dir, newPc);\n    }\n    else {\n      var from = this[-dir];\n      if (from) from.insTextAtDirEnd(ch, dir);\n      else {\n        var newPc = TextPiece(ch).createDir(-dir, cursor);\n        newPc.jQ.insDirOf(-dir, cursor.selection.jQ);\n      }\n\n      if (this.text.length === 1 && anticursor[-dir] === this) {\n        anticursor[-dir] = this[-dir]; // `this` will be removed in deleteTowards\n      }\n    }\n\n    return this.deleteTowards(dir, cursor);\n  };\n});\n\nCharCmds.$ =\nLatexCmds.text =\nLatexCmds.textnormal =\nLatexCmds.textrm =\nLatexCmds.textup =\nLatexCmds.textmd = TextBlock;\n\nfunction makeTextBlock(latex, tagName, attrs) {\n  return P(TextBlock, {\n    ctrlSeq: latex,\n    htmlTemplate: '<'+tagName+' '+attrs+'>&0</'+tagName+'>'\n  });\n}\n\nLatexCmds.em = LatexCmds.italic = LatexCmds.italics =\nLatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =\n  makeTextBlock('\\\\textit', 'i', 'class=\"mq-text-mode\"');\nLatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =\n  makeTextBlock('\\\\textbf', 'b', 'class=\"mq-text-mode\"');\nLatexCmds.sf = LatexCmds.textsf =\n  makeTextBlock('\\\\textsf', 'span', 'class=\"mq-sans-serif mq-text-mode\"');\nLatexCmds.tt = LatexCmds.texttt =\n  makeTextBlock('\\\\texttt', 'span', 'class=\"mq-monospace mq-text-mode\"');\nLatexCmds.textsc =\n  makeTextBlock('\\\\textsc', 'span', 'style=\"font-variant:small-caps\" class=\"mq-text-mode\"');\nLatexCmds.uppercase =\n  makeTextBlock('\\\\uppercase', 'span', 'style=\"text-transform:uppercase\" class=\"mq-text-mode\"');\nLatexCmds.lowercase =\n  makeTextBlock('\\\\lowercase', 'span', 'style=\"text-transform:lowercase\" class=\"mq-text-mode\"');\n\n\nvar RootMathCommand = P(MathCommand, function(_, super_) {\n  _.init = function(cursor) {\n    super_.init.call(this, '$');\n    this.cursor = cursor;\n  };\n  _.htmlTemplate = '<span class=\"mq-math-mode\">&0</span>';\n  _.createBlocks = function() {\n    super_.createBlocks.call(this);\n\n    this.ends[L].cursor = this.cursor;\n    this.ends[L].write = function(cursor, ch) {\n      if (ch !== '$')\n        MathBlock.prototype.write.call(this, cursor, ch);\n      else if (this.isEmpty()) {\n        cursor.insRightOf(this.parent);\n        this.parent.deleteTowards(dir, cursor);\n        VanillaSymbol('\\\\$','$').createLeftOf(cursor.show());\n      }\n      else if (!cursor[R])\n        cursor.insRightOf(this.parent);\n      else if (!cursor[L])\n        cursor.insLeftOf(this.parent);\n      else\n        MathBlock.prototype.write.call(this, cursor, ch);\n    };\n  };\n  _.latex = function() {\n    return '$' + this.ends[L].latex() + '$';\n  };\n});\n\nvar RootTextBlock = P(RootMathBlock, function(_, super_) {\n  _.keystroke = function(key) {\n    if (key === 'Spacebar' || key === 'Shift-Spacebar') return;\n    return super_.keystroke.apply(this, arguments);\n  };\n  _.write = function(cursor, ch) {\n    cursor.show().deleteSelection();\n    if (ch === '$')\n      RootMathCommand(cursor).createLeftOf(cursor);\n    else {\n      var html;\n      if (ch === '<') html = '&lt;';\n      else if (ch === '>') html = '&gt;';\n      VanillaSymbol(ch, html).createLeftOf(cursor);\n    }\n  };\n});\nAPI.TextField = function(APIClasses) {\n  return P(APIClasses.EditableField, function(_, super_) {\n    this.RootBlock = RootTextBlock;\n    _.__mathquillify = function() {\n      return super_.__mathquillify.call(this, 'mq-editable-field mq-text-mode');\n    };\n    _.latex = function(latex) {\n      if (arguments.length > 0) {\n        this.__controller.renderLatexText(latex);\n        if (this.__controller.blurred) this.__controller.cursor.hide().parent.blur();\n        return this;\n      }\n      return this.__controller.exportLatex();\n    };\n  });\n};\n/************************************\n * Symbols for Advanced Mathematics\n ***********************************/\n\nLatexCmds.notin =\nLatexCmds.cong =\nLatexCmds.equiv =\nLatexCmds.oplus =\nLatexCmds.otimes = P(BinaryOperator, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this, '\\\\'+latex+' ', '&'+latex+';');\n  };\n});\n\nLatexCmds['\\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator,'\\\\ne ','&ne;');\n\nLatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =\n  bind(BinaryOperator,'\\\\ast ','&lowast;');\n  //case 'there4 = // a special exception for this one, perhaps?\nLatexCmds.therefor = LatexCmds.therefore =\n  bind(BinaryOperator,'\\\\therefore ','&there4;');\n\nLatexCmds.cuz = // l33t\nLatexCmds.because = bind(BinaryOperator,'\\\\because ','&#8757;');\n\nLatexCmds.prop = LatexCmds.propto = bind(BinaryOperator,'\\\\propto ','&prop;');\n\nLatexCmds['\\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator,'\\\\approx ','&asymp;');\n\nLatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator,'\\\\in ','&isin;');\n\nLatexCmds.ni = LatexCmds.contains = bind(BinaryOperator,'\\\\ni ','&ni;');\n\nLatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =\n  bind(BinaryOperator,'\\\\not\\\\ni ','&#8716;');\n\nLatexCmds.sub = LatexCmds.subset = bind(BinaryOperator,'\\\\subset ','&sub;');\n\nLatexCmds.sup = LatexCmds.supset = LatexCmds.superset =\n  bind(BinaryOperator,'\\\\supset ','&sup;');\n\nLatexCmds.nsub = LatexCmds.notsub =\nLatexCmds.nsubset = LatexCmds.notsubset =\n  bind(BinaryOperator,'\\\\not\\\\subset ','&#8836;');\n\nLatexCmds.nsup = LatexCmds.notsup =\nLatexCmds.nsupset = LatexCmds.notsupset =\nLatexCmds.nsuperset = LatexCmds.notsuperset =\n  bind(BinaryOperator,'\\\\not\\\\supset ','&#8837;');\n\nLatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =\n  bind(BinaryOperator,'\\\\subseteq ','&sube;');\n\nLatexCmds.supe = LatexCmds.supeq =\nLatexCmds.supsete = LatexCmds.supseteq =\nLatexCmds.supersete = LatexCmds.superseteq =\n  bind(BinaryOperator,'\\\\supseteq ','&supe;');\n\nLatexCmds.nsube = LatexCmds.nsubeq =\nLatexCmds.notsube = LatexCmds.notsubeq =\nLatexCmds.nsubsete = LatexCmds.nsubseteq =\nLatexCmds.notsubsete = LatexCmds.notsubseteq =\n  bind(BinaryOperator,'\\\\not\\\\subseteq ','&#8840;');\n\nLatexCmds.nsupe = LatexCmds.nsupeq =\nLatexCmds.notsupe = LatexCmds.notsupeq =\nLatexCmds.nsupsete = LatexCmds.nsupseteq =\nLatexCmds.notsupsete = LatexCmds.notsupseteq =\nLatexCmds.nsupersete = LatexCmds.nsuperseteq =\nLatexCmds.notsupersete = LatexCmds.notsuperseteq =\n  bind(BinaryOperator,'\\\\not\\\\supseteq ','&#8841;');\n\n\n//the canonical sets of numbers\nLatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =\n  bind(VanillaSymbol,'\\\\mathbb{N}','&#8469;');\n\nLatexCmds.P =\nLatexCmds.primes = LatexCmds.Primes =\nLatexCmds.projective = LatexCmds.Projective =\nLatexCmds.probability = LatexCmds.Probability =\n  bind(VanillaSymbol,'\\\\mathbb{P}','&#8473;');\n\nLatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =\n  bind(VanillaSymbol,'\\\\mathbb{Z}','&#8484;');\n\nLatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =\n  bind(VanillaSymbol,'\\\\mathbb{Q}','&#8474;');\n\nLatexCmds.R = LatexCmds.reals = LatexCmds.Reals =\n  bind(VanillaSymbol,'\\\\mathbb{R}','&#8477;');\n\nLatexCmds.C =\nLatexCmds.complex = LatexCmds.Complex =\nLatexCmds.complexes = LatexCmds.Complexes =\nLatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =\n  bind(VanillaSymbol,'\\\\mathbb{C}','&#8450;');\n\nLatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =\n  bind(VanillaSymbol,'\\\\mathbb{H}','&#8461;');\n\n//spacing\nLatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\\\quad ','    ');\nLatexCmds.qquad = bind(VanillaSymbol,'\\\\qquad ','        ');\n/* spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow\ncase ',':\n  return VanillaSymbol('\\\\, ',' ');\ncase ':':\n  return VanillaSymbol('\\\\: ','  ');\ncase ';':\n  return VanillaSymbol('\\\\; ','   ');\ncase '!':\n  return Symbol('\\\\! ','<span style=\"margin-right:-.2em\"></span>');\n*/\n\n//binary operators\nLatexCmds.diamond = bind(VanillaSymbol, '\\\\diamond ', '&#9671;');\nLatexCmds.bigtriangleup = bind(VanillaSymbol, '\\\\bigtriangleup ', '&#9651;');\nLatexCmds.ominus = bind(VanillaSymbol, '\\\\ominus ', '&#8854;');\nLatexCmds.uplus = bind(VanillaSymbol, '\\\\uplus ', '&#8846;');\nLatexCmds.bigtriangledown = bind(VanillaSymbol, '\\\\bigtriangledown ', '&#9661;');\nLatexCmds.sqcap = bind(VanillaSymbol, '\\\\sqcap ', '&#8851;');\nLatexCmds.triangleleft = bind(VanillaSymbol, '\\\\triangleleft ', '&#8882;');\nLatexCmds.sqcup = bind(VanillaSymbol, '\\\\sqcup ', '&#8852;');\nLatexCmds.triangleright = bind(VanillaSymbol, '\\\\triangleright ', '&#8883;');\n//circledot is not a not real LaTex command see https://github.com/mathquill/mathquill/pull/552 for more details\nLatexCmds.odot = LatexCmds.circledot = bind(VanillaSymbol, '\\\\odot ', '&#8857;');\nLatexCmds.bigcirc = bind(VanillaSymbol, '\\\\bigcirc ', '&#9711;');\nLatexCmds.dagger = bind(VanillaSymbol, '\\\\dagger ', '&#0134;');\nLatexCmds.ddagger = bind(VanillaSymbol, '\\\\ddagger ', '&#135;');\nLatexCmds.wr = bind(VanillaSymbol, '\\\\wr ', '&#8768;');\nLatexCmds.amalg = bind(VanillaSymbol, '\\\\amalg ', '&#8720;');\n\n//relationship symbols\nLatexCmds.models = bind(VanillaSymbol, '\\\\models ', '&#8872;');\nLatexCmds.prec = bind(VanillaSymbol, '\\\\prec ', '&#8826;');\nLatexCmds.succ = bind(VanillaSymbol, '\\\\succ ', '&#8827;');\nLatexCmds.preceq = bind(VanillaSymbol, '\\\\preceq ', '&#8828;');\nLatexCmds.succeq = bind(VanillaSymbol, '\\\\succeq ', '&#8829;');\nLatexCmds.simeq = bind(VanillaSymbol, '\\\\simeq ', '&#8771;');\nLatexCmds.mid = bind(VanillaSymbol, '\\\\mid ', '&#8739;');\nLatexCmds.ll = bind(VanillaSymbol, '\\\\ll ', '&#8810;');\nLatexCmds.gg = bind(VanillaSymbol, '\\\\gg ', '&#8811;');\nLatexCmds.parallel = bind(VanillaSymbol, '\\\\parallel ', '&#8741;');\nLatexCmds.nparallel = bind(VanillaSymbol, '\\\\nparallel ', '&#8742;');\nLatexCmds.bowtie = bind(VanillaSymbol, '\\\\bowtie ', '&#8904;');\nLatexCmds.sqsubset = bind(VanillaSymbol, '\\\\sqsubset ', '&#8847;');\nLatexCmds.sqsupset = bind(VanillaSymbol, '\\\\sqsupset ', '&#8848;');\nLatexCmds.smile = bind(VanillaSymbol, '\\\\smile ', '&#8995;');\nLatexCmds.sqsubseteq = bind(VanillaSymbol, '\\\\sqsubseteq ', '&#8849;');\nLatexCmds.sqsupseteq = bind(VanillaSymbol, '\\\\sqsupseteq ', '&#8850;');\nLatexCmds.doteq = bind(VanillaSymbol, '\\\\doteq ', '&#8784;');\nLatexCmds.frown = bind(VanillaSymbol, '\\\\frown ', '&#8994;');\nLatexCmds.vdash = bind(VanillaSymbol, '\\\\vdash ', '&#8870;');\nLatexCmds.dashv = bind(VanillaSymbol, '\\\\dashv ', '&#8867;');\nLatexCmds.nless = bind(VanillaSymbol, '\\\\nless ', '&#8814;');\nLatexCmds.ngtr = bind(VanillaSymbol, '\\\\ngtr ', '&#8815;');\n\n//arrows\nLatexCmds.longleftarrow = bind(VanillaSymbol, '\\\\longleftarrow ', '&#8592;');\nLatexCmds.longrightarrow = bind(VanillaSymbol, '\\\\longrightarrow ', '&#8594;');\nLatexCmds.Longleftarrow = bind(VanillaSymbol, '\\\\Longleftarrow ', '&#8656;');\nLatexCmds.Longrightarrow = bind(VanillaSymbol, '\\\\Longrightarrow ', '&#8658;');\nLatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\\\longleftrightarrow ', '&#8596;');\nLatexCmds.updownarrow = bind(VanillaSymbol, '\\\\updownarrow ', '&#8597;');\nLatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\\\Longleftrightarrow ', '&#8660;');\nLatexCmds.Updownarrow = bind(VanillaSymbol, '\\\\Updownarrow ', '&#8661;');\nLatexCmds.mapsto = bind(VanillaSymbol, '\\\\mapsto ', '&#8614;');\nLatexCmds.nearrow = bind(VanillaSymbol, '\\\\nearrow ', '&#8599;');\nLatexCmds.hookleftarrow = bind(VanillaSymbol, '\\\\hookleftarrow ', '&#8617;');\nLatexCmds.hookrightarrow = bind(VanillaSymbol, '\\\\hookrightarrow ', '&#8618;');\nLatexCmds.searrow = bind(VanillaSymbol, '\\\\searrow ', '&#8600;');\nLatexCmds.leftharpoonup = bind(VanillaSymbol, '\\\\leftharpoonup ', '&#8636;');\nLatexCmds.rightharpoonup = bind(VanillaSymbol, '\\\\rightharpoonup ', '&#8640;');\nLatexCmds.swarrow = bind(VanillaSymbol, '\\\\swarrow ', '&#8601;');\nLatexCmds.leftharpoondown = bind(VanillaSymbol, '\\\\leftharpoondown ', '&#8637;');\nLatexCmds.rightharpoondown = bind(VanillaSymbol, '\\\\rightharpoondown ', '&#8641;');\nLatexCmds.nwarrow = bind(VanillaSymbol, '\\\\nwarrow ', '&#8598;');\n\n//Misc\nLatexCmds.ldots = bind(VanillaSymbol, '\\\\ldots ', '&#8230;');\nLatexCmds.cdots = bind(VanillaSymbol, '\\\\cdots ', '&#8943;');\nLatexCmds.vdots = bind(VanillaSymbol, '\\\\vdots ', '&#8942;');\nLatexCmds.ddots = bind(VanillaSymbol, '\\\\ddots ', '&#8945;');\nLatexCmds.surd = bind(VanillaSymbol, '\\\\surd ', '&#8730;');\nLatexCmds.triangle = bind(VanillaSymbol, '\\\\triangle ', '&#9651;');\nLatexCmds.ell = bind(VanillaSymbol, '\\\\ell ', '&#8467;');\nLatexCmds.top = bind(VanillaSymbol, '\\\\top ', '&#8868;');\nLatexCmds.flat = bind(VanillaSymbol, '\\\\flat ', '&#9837;');\nLatexCmds.natural = bind(VanillaSymbol, '\\\\natural ', '&#9838;');\nLatexCmds.sharp = bind(VanillaSymbol, '\\\\sharp ', '&#9839;');\nLatexCmds.wp = bind(VanillaSymbol, '\\\\wp ', '&#8472;');\nLatexCmds.bot = bind(VanillaSymbol, '\\\\bot ', '&#8869;');\nLatexCmds.clubsuit = bind(VanillaSymbol, '\\\\clubsuit ', '&#9827;');\nLatexCmds.diamondsuit = bind(VanillaSymbol, '\\\\diamondsuit ', '&#9826;');\nLatexCmds.heartsuit = bind(VanillaSymbol, '\\\\heartsuit ', '&#9825;');\nLatexCmds.spadesuit = bind(VanillaSymbol, '\\\\spadesuit ', '&#9824;');\n//not real LaTex command see https://github.com/mathquill/mathquill/pull/552 for more details\nLatexCmds.parallelogram = bind(VanillaSymbol, '\\\\parallelogram ', '&#9649;');\nLatexCmds.square = bind(VanillaSymbol, '\\\\square ', '&#11036;');\n\n//variable-sized\nLatexCmds.oint = bind(VanillaSymbol, '\\\\oint ', '&#8750;');\nLatexCmds.bigcap = bind(VanillaSymbol, '\\\\bigcap ', '&#8745;');\nLatexCmds.bigcup = bind(VanillaSymbol, '\\\\bigcup ', '&#8746;');\nLatexCmds.bigsqcup = bind(VanillaSymbol, '\\\\bigsqcup ', '&#8852;');\nLatexCmds.bigvee = bind(VanillaSymbol, '\\\\bigvee ', '&#8744;');\nLatexCmds.bigwedge = bind(VanillaSymbol, '\\\\bigwedge ', '&#8743;');\nLatexCmds.bigodot = bind(VanillaSymbol, '\\\\bigodot ', '&#8857;');\nLatexCmds.bigotimes = bind(VanillaSymbol, '\\\\bigotimes ', '&#8855;');\nLatexCmds.bigoplus = bind(VanillaSymbol, '\\\\bigoplus ', '&#8853;');\nLatexCmds.biguplus = bind(VanillaSymbol, '\\\\biguplus ', '&#8846;');\n\n//delimiters\nLatexCmds.lfloor = bind(VanillaSymbol, '\\\\lfloor ', '&#8970;');\nLatexCmds.rfloor = bind(VanillaSymbol, '\\\\rfloor ', '&#8971;');\nLatexCmds.lceil = bind(VanillaSymbol, '\\\\lceil ', '&#8968;');\nLatexCmds.rceil = bind(VanillaSymbol, '\\\\rceil ', '&#8969;');\nLatexCmds.opencurlybrace = LatexCmds.lbrace = bind(VanillaSymbol, '\\\\lbrace ', '{');\nLatexCmds.closecurlybrace = LatexCmds.rbrace = bind(VanillaSymbol, '\\\\rbrace ', '}');\nLatexCmds.lbrack = bind(VanillaSymbol, '[');\nLatexCmds.rbrack = bind(VanillaSymbol, ']');\n\n//various symbols\nLatexCmds.slash = bind(VanillaSymbol, '/');\nLatexCmds.vert = bind(VanillaSymbol,'|');\nLatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\\\perp ','&perp;');\nLatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\\\nabla ','&nabla;');\nLatexCmds.hbar = bind(VanillaSymbol,'\\\\hbar ','&#8463;');\n\nLatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =\n  bind(VanillaSymbol,'\\\\text\\\\AA ','&#8491;');\n\nLatexCmds.ring = LatexCmds.circ = LatexCmds.circle =\n  bind(VanillaSymbol,'\\\\circ ','&#8728;');\n\nLatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\\\bullet ','&bull;');\n\nLatexCmds.setminus = LatexCmds.smallsetminus =\n  bind(VanillaSymbol,'\\\\setminus ','&#8726;');\n\nLatexCmds.not = //bind(Symbol,'\\\\not ','<span class=\"not\">/</span>');\nLatexCmds['\\u00ac'] = LatexCmds.neg = bind(VanillaSymbol,'\\\\neg ','&not;');\n\nLatexCmds['\\u2026'] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =\nLatexCmds.ellipsis = LatexCmds.hellipsis =\n  bind(VanillaSymbol,'\\\\dots ','&hellip;');\n\nLatexCmds.converges =\nLatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =\n  bind(VanillaSymbol,'\\\\downarrow ','&darr;');\n\nLatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =\n  bind(VanillaSymbol,'\\\\Downarrow ','&dArr;');\n\nLatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =\n  bind(VanillaSymbol,'\\\\uparrow ','&uarr;');\n\nLatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\\\Uparrow ','&uArr;');\n\nLatexCmds.to = bind(BinaryOperator,'\\\\to ','&rarr;');\n\nLatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\\\rightarrow ','&rarr;');\n\nLatexCmds.implies = bind(BinaryOperator,'\\\\Rightarrow ','&rArr;');\n\nLatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\\\Rightarrow ','&rArr;');\n\nLatexCmds.gets = bind(BinaryOperator,'\\\\gets ','&larr;');\n\nLatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\\\leftarrow ','&larr;');\n\nLatexCmds.impliedby = bind(BinaryOperator,'\\\\Leftarrow ','&lArr;');\n\nLatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\\\Leftarrow ','&lArr;');\n\nLatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =\n  bind(VanillaSymbol,'\\\\leftrightarrow ','&harr;');\n\nLatexCmds.iff = bind(BinaryOperator,'\\\\Leftrightarrow ','&hArr;');\n\nLatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =\n  bind(VanillaSymbol,'\\\\Leftrightarrow ','&hArr;');\n\nLatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\\\Re ','&real;');\n\nLatexCmds.Im = LatexCmds.imag =\nLatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =\n  bind(VanillaSymbol,'\\\\Im ','&image;');\n\nLatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\\\partial ','&part;');\n\nLatexCmds.infty = LatexCmds.infin = LatexCmds.infinity =\n  bind(VanillaSymbol,'\\\\infty ','&infin;');\n\nLatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =\n  bind(VanillaSymbol,'\\\\aleph ','&alefsym;');\n\nLatexCmds.xist = //LOL\nLatexCmds.xists = LatexCmds.exist = LatexCmds.exists =\n  bind(VanillaSymbol,'\\\\exists ','&exist;');\n  \nLatexCmds.nexists = LatexCmds.nexist =\n      bind(VanillaSymbol, '\\\\nexists ', '&#8708;');\n\nLatexCmds.and = LatexCmds.land = LatexCmds.wedge =\n  bind(VanillaSymbol,'\\\\wedge ','&and;');\n\nLatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol,'\\\\vee ','&or;');\n\nLatexCmds.o = LatexCmds.O =\nLatexCmds.empty = LatexCmds.emptyset =\nLatexCmds.oslash = LatexCmds.Oslash =\nLatexCmds.nothing = LatexCmds.varnothing =\n  bind(BinaryOperator,'\\\\varnothing ','&empty;');\n\nLatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\\\cup ','&cup;');\n\nLatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =\n  bind(BinaryOperator,'\\\\cap ','&cap;');\n\n// FIXME: the correct LaTeX would be ^\\circ but we can't parse that\nLatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'\\\\degree ','&deg;');\n\nLatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\\\angle ','&ang;');\nLatexCmds.measuredangle = bind(VanillaSymbol,'\\\\measuredangle ','&#8737;');\n/*********************************\n * Symbols for Basic Mathematics\n ********************************/\n\nvar Digit = P(VanillaSymbol, function(_, super_) {\n  _.createLeftOf = function(cursor) {\n    if (cursor.options.autoSubscriptNumerals\n        && cursor.parent !== cursor.parent.parent.sub\n        && ((cursor[L] instanceof Variable && cursor[L].isItalic !== false)\n            || (cursor[L] instanceof SupSub\n                && cursor[L][L] instanceof Variable\n                && cursor[L][L].isItalic !== false))) {\n      LatexCmds._().createLeftOf(cursor);\n      super_.createLeftOf.call(this, cursor);\n      cursor.insRightOf(cursor.parent.parent);\n    }\n    else super_.createLeftOf.call(this, cursor);\n  };\n});\n\nvar Variable = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<var>'+(html || ch)+'</var>');\n  };\n  _.text = function() {\n    var text = this.ctrlSeq;\n    if (this[L] && !(this[L] instanceof Variable)\n        && !(this[L] instanceof BinaryOperator)\n        && this[L].ctrlSeq !== \"\\\\ \")\n      text = '*' + text;\n    if (this[R] && !(this[R] instanceof BinaryOperator)\n        && !(this[R] instanceof SupSub))\n      text += '*';\n    return text;\n  };\n});\n\nOptions.p.autoCommands = { _maxLength: 0 };\noptionProcessors.autoCommands = function(cmds) {\n  if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {\n    throw '\"'+cmds+'\" not a space-delimited list of only letters';\n  }\n  var list = cmds.split(' '), dict = {}, maxLength = 0;\n  for (var i = 0; i < list.length; i += 1) {\n    var cmd = list[i];\n    if (cmd.length < 2) {\n      throw 'autocommand \"'+cmd+'\" not minimum length of 2';\n    }\n    if (LatexCmds[cmd] === OperatorName) {\n      throw '\"' + cmd + '\" is a built-in operator name';\n    }\n    dict[cmd] = 1;\n    maxLength = max(maxLength, cmd.length);\n  }\n  dict._maxLength = maxLength;\n  return dict;\n};\n\nvar Letter = P(Variable, function(_, super_) {\n  _.init = function(ch) { return super_.init.call(this, this.letter = ch); };\n  _.createLeftOf = function(cursor) {\n    super_.createLeftOf.apply(this, arguments);\n    var autoCmds = cursor.options.autoCommands, maxLength = autoCmds._maxLength;\n    if (maxLength > 0) {\n      // want longest possible autocommand, so join together longest\n      // sequence of letters\n      var str = '', l = this, i = 0;\n      // FIXME: l.ctrlSeq === l.letter checks if first or last in an operator name\n      while (l instanceof Letter && l.ctrlSeq === l.letter && i < maxLength) {\n        str = l.letter + str, l = l[L], i += 1;\n      }\n      // check for an autocommand, going thru substrings longest to shortest\n      while (str.length) {\n        if (autoCmds.hasOwnProperty(str)) {\n          for (var i = 1, l = this; i < str.length; i += 1, l = l[L]);\n          Fragment(l, this).remove();\n          cursor[L] = l[L];\n          return LatexCmds[str](str).createLeftOf(cursor);\n        }\n        str = str.slice(1);\n      }\n    }\n  };\n  _.italicize = function(bool) {\n    this.isItalic = bool;\n    this.jQ.toggleClass('mq-operator-name', !bool);\n    return this;\n  };\n  _.finalizeTree = _.siblingDeleted = _.siblingCreated = function(opts, dir) {\n    // don't auto-un-italicize if the sibling to my right changed (dir === R or\n    // undefined) and it's now a Letter, it will un-italicize everyone\n    if (dir !== L && this[R] instanceof Letter) return;\n    this.autoUnItalicize(opts);\n  };\n  _.autoUnItalicize = function(opts) {\n    var autoOps = opts.autoOperatorNames;\n    if (autoOps._maxLength === 0) return;\n    // want longest possible operator names, so join together entire contiguous\n    // sequence of letters\n    var str = this.letter;\n    for (var l = this[L]; l instanceof Letter; l = l[L]) str = l.letter + str;\n    for (var r = this[R]; r instanceof Letter; r = r[R]) str += r.letter;\n\n    // removeClass and delete flags from all letters before figuring out\n    // which, if any, are part of an operator name\n    Fragment(l[R] || this.parent.ends[L], r[L] || this.parent.ends[R]).each(function(el) {\n      el.italicize(true).jQ.removeClass('mq-first mq-last mq-followed-by-supsub');\n      el.ctrlSeq = el.letter;\n    });\n\n    // check for operator names: at each position from left to right, check\n    // substrings from longest to shortest\n    outer: for (var i = 0, first = l[R] || this.parent.ends[L]; i < str.length; i += 1, first = first[R]) {\n      for (var len = min(autoOps._maxLength, str.length - i); len > 0; len -= 1) {\n        var word = str.slice(i, i + len);\n        if (autoOps.hasOwnProperty(word)) {\n          for (var j = 0, letter = first; j < len; j += 1, letter = letter[R]) {\n            letter.italicize(false);\n            var last = letter;\n          }\n\n          var isBuiltIn = BuiltInOpNames.hasOwnProperty(word);\n          first.ctrlSeq = (isBuiltIn ? '\\\\' : '\\\\operatorname{') + first.ctrlSeq;\n          last.ctrlSeq += (isBuiltIn ? ' ' : '}');\n          if (TwoWordOpNames.hasOwnProperty(word)) last[L][L][L].jQ.addClass('mq-last');\n          if (!shouldOmitPadding(first[L])) first.jQ.addClass('mq-first');\n          if (!shouldOmitPadding(last[R])) {\n            if (last[R] instanceof SupSub) {\n              var supsub = last[R]; // XXX monkey-patching, but what's the right thing here?\n              // Have operatorname-specific code in SupSub? A CSS-like language to style the\n              // math tree, but which ignores cursor and selection (which CSS can't)?\n              var respace = supsub.siblingCreated = supsub.siblingDeleted = function() {\n                supsub.jQ.toggleClass('mq-after-operator-name', !(supsub[R] instanceof Bracket));\n              };\n              respace();\n            }\n            else {\n              last.jQ.toggleClass('mq-last', !(last[R] instanceof Bracket));\n            }\n          }\n\n          i += len - 1;\n          first = last;\n          continue outer;\n        }\n      }\n    }\n  };\n  function shouldOmitPadding(node) {\n    // omit padding if no node, or if node already has padding (to avoid double-padding)\n    return !node || (node instanceof BinaryOperator) || (node instanceof SummationNotation);\n  }\n});\nvar BuiltInOpNames = {}; // the set of operator names like \\sin, \\cos, etc that\n  // are built-into LaTeX, see Section 3.17 of the Short Math Guide: http://tinyurl.com/jm9okjc\n  // MathQuill auto-unitalicizes some operator names not in that set, like 'hcf'\n  // and 'arsinh', which must be exported as \\operatorname{hcf} and\n  // \\operatorname{arsinh}. Note: over/under line/arrow \\lim variants like\n  // \\varlimsup are not supported\nvar AutoOpNames = Options.p.autoOperatorNames = { _maxLength: 9 }; // the set\n  // of operator names that MathQuill auto-unitalicizes by default; overridable\nvar TwoWordOpNames = { limsup: 1, liminf: 1, projlim: 1, injlim: 1 };\n(function() {\n  var mostOps = ('arg deg det dim exp gcd hom inf ker lg lim ln log max min sup'\n                 + ' limsup liminf injlim projlim Pr').split(' ');\n  for (var i = 0; i < mostOps.length; i += 1) {\n    BuiltInOpNames[mostOps[i]] = AutoOpNames[mostOps[i]] = 1;\n  }\n\n  var builtInTrigs = // why coth but not sech and csch, LaTeX?\n    'sin cos tan arcsin arccos arctan sinh cosh tanh sec csc cot coth'.split(' ');\n  for (var i = 0; i < builtInTrigs.length; i += 1) {\n    BuiltInOpNames[builtInTrigs[i]] = 1;\n  }\n\n  var autoTrigs = 'sin cos tan sec cosec csc cotan cot ctg'.split(' ');\n  for (var i = 0; i < autoTrigs.length; i += 1) {\n    AutoOpNames[autoTrigs[i]] =\n    AutoOpNames['arc'+autoTrigs[i]] =\n    AutoOpNames[autoTrigs[i]+'h'] =\n    AutoOpNames['ar'+autoTrigs[i]+'h'] =\n    AutoOpNames['arc'+autoTrigs[i]+'h'] = 1;\n  }\n\n  // compat with some of the nonstandard LaTeX exported by MathQuill\n  // before #247. None of these are real LaTeX commands so, seems safe\n  var moreNonstandardOps = 'gcf hcf lcm proj span'.split(' ');\n  for (var i = 0; i < moreNonstandardOps.length; i += 1) {\n    AutoOpNames[moreNonstandardOps[i]] = 1;\n  }\n}());\noptionProcessors.autoOperatorNames = function(cmds) {\n  if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {\n    throw '\"'+cmds+'\" not a space-delimited list of only letters';\n  }\n  var list = cmds.split(' '), dict = {}, maxLength = 0;\n  for (var i = 0; i < list.length; i += 1) {\n    var cmd = list[i];\n    if (cmd.length < 2) {\n      throw '\"'+cmd+'\" not minimum length of 2';\n    }\n    dict[cmd] = 1;\n    maxLength = max(maxLength, cmd.length);\n  }\n  dict._maxLength = maxLength;\n  return dict;\n};\nvar OperatorName = P(Symbol, function(_, super_) {\n  _.init = function(fn) { this.ctrlSeq = fn; };\n  _.createLeftOf = function(cursor) {\n    var fn = this.ctrlSeq;\n    for (var i = 0; i < fn.length; i += 1) {\n      Letter(fn.charAt(i)).createLeftOf(cursor);\n    }\n  };\n  _.parser = function() {\n    var fn = this.ctrlSeq;\n    var block = MathBlock();\n    for (var i = 0; i < fn.length; i += 1) {\n      Letter(fn.charAt(i)).adopt(block, block.ends[R], 0);\n    }\n    return Parser.succeed(block.children());\n  };\n});\nfor (var fn in AutoOpNames) if (AutoOpNames.hasOwnProperty(fn)) {\n  LatexCmds[fn] = OperatorName;\n}\nLatexCmds.operatorname = P(MathCommand, function(_) {\n  _.createLeftOf = noop;\n  _.numBlocks = function() { return 1; };\n  _.parser = function() {\n    return latexMathParser.block.map(function(b) { return b.children(); });\n  };\n});\n\nLatexCmds.f = P(Letter, function(_, super_) {\n  _.init = function() {\n    Symbol.p.init.call(this, this.letter = 'f', '<var class=\"mq-f\">f</var>');\n  };\n  _.italicize = function(bool) {\n    this.jQ.html('f').toggleClass('mq-f', bool);\n    return super_.italicize.apply(this, arguments);\n  };\n});\n\n// VanillaSymbol's\nLatexCmds[' '] = LatexCmds.space = bind(VanillaSymbol, '\\\\ ', '&nbsp;');\n\nLatexCmds[\"'\"] = LatexCmds.prime = bind(VanillaSymbol, \"'\", '&prime;');\n\nLatexCmds.backslash = bind(VanillaSymbol,'\\\\backslash ','\\\\');\nif (!CharCmds['\\\\']) CharCmds['\\\\'] = LatexCmds.backslash;\n\nLatexCmds.$ = bind(VanillaSymbol, '\\\\$', '$');\n\n// does not use Symbola font\nvar NonSymbolaSymbol = P(Symbol, function(_, super_) {\n  _.init = function(ch, html) {\n    super_.init.call(this, ch, '<span class=\"mq-nonSymbola\">'+(html || ch)+'</span>');\n  };\n});\n\nLatexCmds['@'] = NonSymbolaSymbol;\nLatexCmds['&'] = bind(NonSymbolaSymbol, '\\\\&', '&amp;');\nLatexCmds['%'] = bind(NonSymbolaSymbol, '\\\\%', '%');\n\n//the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html\n\n//lowercase Greek letter variables\nLatexCmds.alpha =\nLatexCmds.beta =\nLatexCmds.gamma =\nLatexCmds.delta =\nLatexCmds.zeta =\nLatexCmds.eta =\nLatexCmds.theta =\nLatexCmds.iota =\nLatexCmds.kappa =\nLatexCmds.mu =\nLatexCmds.nu =\nLatexCmds.xi =\nLatexCmds.rho =\nLatexCmds.sigma =\nLatexCmds.tau =\nLatexCmds.chi =\nLatexCmds.psi =\nLatexCmds.omega = P(Variable, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this,'\\\\'+latex+' ','&'+latex+';');\n  };\n});\n\n//why can't anybody FUCKING agree on these\nLatexCmds.phi = //W3C or Unicode?\n  bind(Variable,'\\\\phi ','&#981;');\n\nLatexCmds.phiv = //Elsevier and 9573-13\nLatexCmds.varphi = //AMS and LaTeX\n  bind(Variable,'\\\\varphi ','&phi;');\n\nLatexCmds.epsilon = //W3C or Unicode?\n  bind(Variable,'\\\\epsilon ','&#1013;');\n\nLatexCmds.epsiv = //Elsevier and 9573-13\nLatexCmds.varepsilon = //AMS and LaTeX\n  bind(Variable,'\\\\varepsilon ','&epsilon;');\n\nLatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13\nLatexCmds.varpi = //AMS and LaTeX\n  bind(Variable,'\\\\varpi ','&piv;');\n\nLatexCmds.sigmaf = //W3C/Unicode\nLatexCmds.sigmav = //Elsevier\nLatexCmds.varsigma = //LaTeX\n  bind(Variable,'\\\\varsigma ','&sigmaf;');\n\nLatexCmds.thetav = //Elsevier and 9573-13\nLatexCmds.vartheta = //AMS and LaTeX\nLatexCmds.thetasym = //W3C/Unicode\n  bind(Variable,'\\\\vartheta ','&thetasym;');\n\nLatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode\nLatexCmds.upsi = //Elsevier and 9573-13\n  bind(Variable,'\\\\upsilon ','&upsilon;');\n\n//these aren't even mentioned in the HTML character entity references\nLatexCmds.gammad = //Elsevier\nLatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)\nLatexCmds.digamma = //LaTeX\n  bind(Variable,'\\\\digamma ','&#989;');\n\nLatexCmds.kappav = //Elsevier\nLatexCmds.varkappa = //AMS and LaTeX\n  bind(Variable,'\\\\varkappa ','&#1008;');\n\nLatexCmds.rhov = //Elsevier and 9573-13\nLatexCmds.varrho = //AMS and LaTeX\n  bind(Variable,'\\\\varrho ','&#1009;');\n\n//Greek constants, look best in non-italicized Times New Roman\nLatexCmds.pi = LatexCmds['\\u03c0'] = bind(NonSymbolaSymbol,'\\\\pi ','&pi;');\nLatexCmds.lambda = bind(NonSymbolaSymbol,'\\\\lambda ','&lambda;');\n\n//uppercase greek letters\n\nLatexCmds.Upsilon = //LaTeX\nLatexCmds.Upsi = //Elsevier and 9573-13\nLatexCmds.upsih = //W3C/Unicode \"upsilon with hook\"\nLatexCmds.Upsih = //'cos it makes sense to me\n  bind(Symbol,'\\\\Upsilon ','<var style=\"font-family: serif\">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(\n\n//other symbols with the same LaTeX command and HTML character entity reference\nLatexCmds.Gamma =\nLatexCmds.Delta =\nLatexCmds.Theta =\nLatexCmds.Lambda =\nLatexCmds.Xi =\nLatexCmds.Pi =\nLatexCmds.Sigma =\nLatexCmds.Phi =\nLatexCmds.Psi =\nLatexCmds.Omega =\nLatexCmds.forall = P(VanillaSymbol, function(_, super_) {\n  _.init = function(latex) {\n    super_.init.call(this,'\\\\'+latex+' ','&'+latex+';');\n  };\n});\n\n// symbols that aren't a single MathCommand, but are instead a whole\n// Fragment. Creates the Fragment from a LaTeX string\nvar LatexFragment = P(MathCommand, function(_) {\n  _.init = function(latex) { this.latex = latex; };\n  _.createLeftOf = function(cursor) {\n    var block = latexMathParser.parse(this.latex);\n    block.children().adopt(cursor.parent, cursor[L], cursor[R]);\n    cursor[L] = block.ends[R];\n    block.jQize().insertBefore(cursor.jQ);\n    block.finalizeInsert(cursor.options, cursor);\n    if (block.ends[R][R].siblingCreated) block.ends[R][R].siblingCreated(cursor.options, L);\n    if (block.ends[L][L].siblingCreated) block.ends[L][L].siblingCreated(cursor.options, R);\n    cursor.parent.bubble('reflow');\n  };\n  _.parser = function() {\n    var frag = latexMathParser.parse(this.latex).children();\n    return Parser.succeed(frag);\n  };\n});\n\n// for what seems to me like [stupid reasons][1], Unicode provides\n// subscripted and superscripted versions of all ten Arabic numerals,\n// as well as [so-called \"vulgar fractions\"][2].\n// Nobody really cares about most of them, but some of them actually\n// predate Unicode, dating back to [ISO-8859-1][3], apparently also\n// known as \"Latin-1\", which among other things [Windows-1252][4]\n// largely coincides with, so Microsoft Word sometimes inserts them\n// and they get copy-pasted into MathQuill.\n//\n// (Irrelevant but funny story: though not a superset of Latin-1 aka\n// ISO-8859-1, Windows-1252 **is** a strict superset of the \"closely\n// related but distinct\"[3] \"ISO 8859-1\" -- see the lack of a dash\n// after \"ISO\"? Completely different character set, like elephants vs\n// elephant seals, or \"Zombies\" vs \"Zombie Redneck Torture Family\".\n// What kind of idiot would get them confused.\n// People in fact got them confused so much, it was so common to\n// mislabel Windows-1252 text as ISO-8859-1, that most modern web\n// browsers and email clients treat the MIME charset of ISO-8859-1\n// as actually Windows-1252, behavior now standard in the HTML5 spec.)\n//\n// [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_andsuper_scripts\n// [2]: http://en.wikipedia.org/wiki/Number_Forms\n// [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1\n// [4]: http://en.wikipedia.org/wiki/Windows-1252\nLatexCmds['\\u00b9'] = bind(LatexFragment, '^1');\nLatexCmds['\\u00b2'] = bind(LatexFragment, '^2');\nLatexCmds['\\u00b3'] = bind(LatexFragment, '^3');\nLatexCmds['\\u00bc'] = bind(LatexFragment, '\\\\frac14');\nLatexCmds['\\u00bd'] = bind(LatexFragment, '\\\\frac12');\nLatexCmds['\\u00be'] = bind(LatexFragment, '\\\\frac34');\n\nvar PlusMinus = P(BinaryOperator, function(_) {\n  _.init = VanillaSymbol.prototype.init;\n\n  _.contactWeld = _.siblingCreated = _.siblingDeleted = function(opts, dir) {\n    if (dir === R) return; // ignore if sibling only changed on the right\n    // If the left sibling is a binary operator or a separator (comma, semicolon, colon)\n    // or an open bracket (open parenthesis, open square bracket)\n    // consider the operator to be unary, otherwise binary\n    this.jQ[0].className =\n      (!this[L] || this[L] instanceof BinaryOperator || /^[,;:\\(\\[]$/.test(this[L].ctrlSeq) ? '' : 'mq-binary-operator');\n    return this;\n  };\n});\n\nLatexCmds['+'] = bind(PlusMinus, '+', '+');\n//yes, these are different dashes, I think one is an en dash and the other is a hyphen\nLatexCmds['\\u2013'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');\nLatexCmds['\\u00b1'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =\n  bind(PlusMinus,'\\\\pm ','&plusmn;');\nLatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =\n  bind(PlusMinus,'\\\\mp ','&#8723;');\n\nCharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =\n  bind(BinaryOperator, '\\\\cdot ', '&middot;', '*');\n//semantically should be &sdot;, but &middot; looks better\n\nvar Inequality = P(BinaryOperator, function(_, super_) {\n  _.init = function(data, strict) {\n    this.data = data;\n    this.strict = strict;\n    var strictness = (strict ? 'Strict' : '');\n    super_.init.call(this, data['ctrlSeq'+strictness], data['html'+strictness],\n                     data['text'+strictness]);\n  };\n  _.swap = function(strict) {\n    this.strict = strict;\n    var strictness = (strict ? 'Strict' : '');\n    this.ctrlSeq = this.data['ctrlSeq'+strictness];\n    this.jQ.html(this.data['html'+strictness]);\n    this.textTemplate = [ this.data['text'+strictness] ];\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (dir === L && !this.strict) {\n      this.swap(true);\n      this.bubble('reflow');\n      return;\n    }\n    super_.deleteTowards.apply(this, arguments);\n  };\n});\n\nvar less = { ctrlSeq: '\\\\le ', html: '&le;', text: '\\u2264',\n             ctrlSeqStrict: '<', htmlStrict: '&lt;', textStrict: '<' };\nvar greater = { ctrlSeq: '\\\\ge ', html: '&ge;', text: '\\u2265',\n                ctrlSeqStrict: '>', htmlStrict: '&gt;', textStrict: '>' };\n\nLatexCmds['<'] = LatexCmds.lt = bind(Inequality, less, true);\nLatexCmds['>'] = LatexCmds.gt = bind(Inequality, greater, true);\nLatexCmds['\\u2264'] = LatexCmds.le = LatexCmds.leq = bind(Inequality, less, false);\nLatexCmds['\\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(Inequality, greater, false);\n\nvar Equality = P(BinaryOperator, function(_, super_) {\n  _.init = function() {\n    super_.init.call(this, '=', '=');\n  };\n  _.createLeftOf = function(cursor) {\n    if (cursor[L] instanceof Inequality && cursor[L].strict) {\n      cursor[L].swap(false);\n      cursor[L].bubble('reflow');\n      return;\n    }\n    super_.createLeftOf.apply(this, arguments);\n  };\n});\nLatexCmds['='] = Equality;\n\nLatexCmds['\\u00d7'] = LatexCmds.times = bind(BinaryOperator, '\\\\times ', '&times;', '[x]');\n\nLatexCmds['\\u00f7'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =\n  bind(BinaryOperator,'\\\\div ','&divide;', '[/]');\n\nCharCmds['~'] = LatexCmds.sim = bind(BinaryOperator, '\\\\sim ', '~', '~');\n/***************************\n * Commands and Operators.\n **************************/\n\nvar scale, // = function(jQ, x, y) { ... }\n//will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,\n//or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to\n//increasing the fontSize to match the vertical Y scaling factor.\n\n//ideas from http://github.com/louisremi/jquery.transform.js\n//see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx\n\n  forceIERedraw = noop,\n  div = document.createElement('div'),\n  div_style = div.style,\n  transformPropNames = {\n    transform:1,\n    WebkitTransform:1,\n    MozTransform:1,\n    OTransform:1,\n    msTransform:1\n  },\n  transformPropName;\n\nfor (var prop in transformPropNames) {\n  if (prop in div_style) {\n    transformPropName = prop;\n    break;\n  }\n}\n\nif (transformPropName) {\n  scale = function(jQ, x, y) {\n    jQ.css(transformPropName, 'scale('+x+','+y+')');\n  };\n}\nelse if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms\n  forceIERedraw = function(el){ el.className = el.className; };\n  scale = function(jQ, x, y) { //NOTE: assumes y > x\n    x /= (1+(y-1)/2);\n    jQ.css('fontSize', y + 'em');\n    if (!jQ.hasClass('mq-matrixed-container')) {\n      jQ.addClass('mq-matrixed-container')\n      .wrapInner('<span class=\"mq-matrixed\"></span>');\n    }\n    var innerjQ = jQ.children()\n    .css('filter', 'progid:DXImageTransform.Microsoft'\n        + '.Matrix(M11=' + x + \",SizingMethod='auto expand')\"\n    );\n    function calculateMarginRight() {\n      jQ.css('marginRight', (innerjQ.width()-1)*(x-1)/x + 'px');\n    }\n    calculateMarginRight();\n    var intervalId = setInterval(calculateMarginRight);\n    $(window).load(function() {\n      clearTimeout(intervalId);\n      calculateMarginRight();\n    });\n  };\n}\nelse {\n  scale = function(jQ, x, y) {\n    jQ.css('fontSize', y + 'em');\n  };\n}\n\nvar Style = P(MathCommand, function(_, super_) {\n  _.init = function(ctrlSeq, tagName, attrs) {\n    super_.init.call(this, ctrlSeq, '<'+tagName+' '+attrs+'>&0</'+tagName+'>');\n  };\n});\n\n//fonts\nLatexCmds.mathrm = bind(Style, '\\\\mathrm', 'span', 'class=\"mq-roman mq-font\"');\nLatexCmds.mathit = bind(Style, '\\\\mathit', 'i', 'class=\"mq-font\"');\nLatexCmds.mathbf = bind(Style, '\\\\mathbf', 'b', 'class=\"mq-font\"');\nLatexCmds.mathsf = bind(Style, '\\\\mathsf', 'span', 'class=\"mq-sans-serif mq-font\"');\nLatexCmds.mathtt = bind(Style, '\\\\mathtt', 'span', 'class=\"mq-monospace mq-font\"');\n//text-decoration\nLatexCmds.underline = bind(Style, '\\\\underline', 'span', 'class=\"mq-non-leaf mq-underline\"');\nLatexCmds.overline = LatexCmds.bar = bind(Style, '\\\\overline', 'span', 'class=\"mq-non-leaf mq-overline\"');\nLatexCmds.overrightarrow = bind(Style, '\\\\overrightarrow', 'span', 'class=\"mq-non-leaf mq-overarrow mq-arrow-right\"');\nLatexCmds.overleftarrow = bind(Style, '\\\\overleftarrow', 'span', 'class=\"mq-non-leaf mq-overarrow mq-arrow-left\"');\n\n// `\\textcolor{color}{math}` will apply a color to the given math content, where\n// `color` is any valid CSS Color Value (see [SitePoint docs][] (recommended),\n// [Mozilla docs][], or [W3C spec][]).\n//\n// [SitePoint docs]: http://reference.sitepoint.com/css/colorvalues\n// [Mozilla docs]: https://developer.mozilla.org/en-US/docs/CSS/color_value#Values\n// [W3C spec]: http://dev.w3.org/csswg/css3-color/#colorunits\nvar TextColor = LatexCmds.textcolor = P(MathCommand, function(_, super_) {\n  _.setColor = function(color) {\n    this.color = color;\n    this.htmlTemplate =\n      '<span class=\"mq-textcolor\" style=\"color:' + color + '\">&0</span>';\n  };\n  _.latex = function() {\n    return '\\\\textcolor{' + this.color + '}{' + this.blocks[0].latex() + '}';\n  };\n  _.parser = function() {\n    var self = this;\n    var optWhitespace = Parser.optWhitespace;\n    var string = Parser.string;\n    var regex = Parser.regex;\n\n    return optWhitespace\n      .then(string('{'))\n      .then(regex(/^[#\\w\\s.,()%-]*/))\n      .skip(string('}'))\n      .then(function(color) {\n        self.setColor(color);\n        return super_.parser.call(self);\n      })\n    ;\n  };\n});\n\n// Very similar to the \\textcolor command, but will add the given CSS class.\n// Usage: \\class{classname}{math}\n// Note regex that whitelists valid CSS classname characters:\n// https://github.com/mathquill/mathquill/pull/191#discussion_r4327442\nvar Class = LatexCmds['class'] = P(MathCommand, function(_, super_) {\n  _.parser = function() {\n    var self = this, string = Parser.string, regex = Parser.regex;\n    return Parser.optWhitespace\n      .then(string('{'))\n      .then(regex(/^[-\\w\\s\\\\\\xA0-\\xFF]*/))\n      .skip(string('}'))\n      .then(function(cls) {\n        self.htmlTemplate = '<span class=\"mq-class '+cls+'\">&0</span>';\n        return super_.parser.call(self);\n      })\n    ;\n  };\n});\n\nvar SupSub = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '_{...}^{...}';\n  _.createLeftOf = function(cursor) {\n    if (!cursor[L] && cursor.options.supSubsRequireOperand) return;\n    return super_.createLeftOf.apply(this, arguments);\n  };\n  _.contactWeld = function(cursor) {\n    // Look on either side for a SupSub, if one is found compare my\n    // .sub, .sup with its .sub, .sup. If I have one that it doesn't,\n    // then call .addBlock() on it with my block; if I have one that\n    // it also has, then insert my block's children into its block,\n    // unless my block has none, in which case insert the cursor into\n    // its block (and not mine, I'm about to remove myself) in the case\n    // I was just typed.\n    // TODO: simplify\n\n    // equiv. to [L, R].forEach(function(dir) { ... });\n    for (var dir = L; dir; dir = (dir === L ? R : false)) {\n      if (this[dir] instanceof SupSub) {\n        // equiv. to 'sub sup'.split(' ').forEach(function(supsub) { ... });\n        for (var supsub = 'sub'; supsub; supsub = (supsub === 'sub' ? 'sup' : false)) {\n          var src = this[supsub], dest = this[dir][supsub];\n          if (!src) continue;\n          if (!dest) this[dir].addBlock(src.disown());\n          else if (!src.isEmpty()) { // ins src children at -dir end of dest\n            src.jQ.children().insAtDirEnd(-dir, dest.jQ);\n            var children = src.children().disown();\n            var pt = Point(dest, children.ends[R], dest.ends[L]);\n            if (dir === L) children.adopt(dest, dest.ends[R], 0);\n            else children.adopt(dest, 0, dest.ends[L]);\n          }\n          else var pt = Point(dest, 0, dest.ends[L]);\n          this.placeCursor = (function(dest, src) { // TODO: don't monkey-patch\n            return function(cursor) { cursor.insAtDirEnd(-dir, dest || src); };\n          }(dest, src));\n        }\n        this.remove();\n        if (cursor && cursor[L] === this) {\n          if (dir === R && pt) {\n            pt[L] ? cursor.insRightOf(pt[L]) : cursor.insAtLeftEnd(pt.parent);\n          }\n          else cursor.insRightOf(this[dir]);\n        }\n        break;\n      }\n    }\n  };\n  Options.p.charsThatBreakOutOfSupSub = '';\n  _.finalizeTree = function() {\n    this.ends[L].write = function(cursor, ch) {\n      if (cursor.options.autoSubscriptNumerals && this === this.parent.sub) {\n        if (ch === '_') return;\n        var cmd = this.chToCmd(ch);\n        if (cmd instanceof Symbol) cursor.deleteSelection();\n        else cursor.clearSelection().insRightOf(this.parent);\n        return cmd.createLeftOf(cursor.show());\n      }\n      if (cursor[L] && !cursor[R] && !cursor.selection\n          && cursor.options.charsThatBreakOutOfSupSub.indexOf(ch) > -1) {\n        cursor.insRightOf(this.parent);\n      }\n      MathBlock.p.write.apply(this, arguments);\n    };\n  };\n  _.moveTowards = function(dir, cursor, updown) {\n    if (cursor.options.autoSubscriptNumerals && !this.sup) {\n      cursor.insDirOf(dir, this);\n    }\n    else super_.moveTowards.apply(this, arguments);\n  };\n  _.deleteTowards = function(dir, cursor) {\n    if (cursor.options.autoSubscriptNumerals && this.sub) {\n      var cmd = this.sub.ends[-dir];\n      if (cmd instanceof Symbol) cmd.remove();\n      else if (cmd) cmd.deleteTowards(dir, cursor.insAtDirEnd(-dir, this.sub));\n\n      // TODO: factor out a .removeBlock() or something\n      if (this.sub.isEmpty()) {\n        this.sub.deleteOutOf(L, cursor.insAtLeftEnd(this.sub));\n        if (this.sup) cursor.insDirOf(-dir, this);\n        // Note `-dir` because in e.g. x_1^2| want backspacing (leftward)\n        // to delete the 1 but to end up rightward of x^2; with non-negated\n        // `dir` (try it), the cursor appears to have gone \"through\" the ^2.\n      }\n    }\n    else super_.deleteTowards.apply(this, arguments);\n  };\n  _.latex = function() {\n    function latex(prefix, block) {\n      var l = block && block.latex();\n      return block ? prefix + (l.length === 1 ? l : '{' + (l || ' ') + '}') : '';\n    }\n    return latex('_', this.sub) + latex('^', this.sup);\n  };\n  _.addBlock = function(block) {\n    if (this.supsub === 'sub') {\n      this.sup = this.upInto = this.sub.upOutOf = block;\n      block.adopt(this, this.sub, 0).downOutOf = this.sub;\n      block.jQ = $('<span class=\"mq-sup\"/>').append(block.jQ.children())\n        .attr(mqBlockId, block.id).prependTo(this.jQ);\n    }\n    else {\n      this.sub = this.downInto = this.sup.downOutOf = block;\n      block.adopt(this, 0, this.sup).upOutOf = this.sup;\n      block.jQ = $('<span class=\"mq-sub\"></span>').append(block.jQ.children())\n        .attr(mqBlockId, block.id).appendTo(this.jQ.removeClass('mq-sup-only'));\n      this.jQ.append('<span style=\"display:inline-block;width:0\">&#8203;</span>');\n    }\n    // like 'sub sup'.split(' ').forEach(function(supsub) { ... });\n    for (var i = 0; i < 2; i += 1) (function(cmd, supsub, oppositeSupsub, updown) {\n      cmd[supsub].deleteOutOf = function(dir, cursor) {\n        cursor.insDirOf((this[dir] ? -dir : dir), this.parent);\n        if (!this.isEmpty()) {\n          var end = this.ends[dir];\n          this.children().disown()\n            .withDirAdopt(dir, cursor.parent, cursor[dir], cursor[-dir])\n            .jQ.insDirOf(-dir, cursor.jQ);\n          cursor[-dir] = end;\n        }\n        cmd.supsub = oppositeSupsub;\n        delete cmd[supsub];\n        delete cmd[updown+'Into'];\n        cmd[oppositeSupsub][updown+'OutOf'] = insLeftOfMeUnlessAtEnd;\n        delete cmd[oppositeSupsub].deleteOutOf;\n        if (supsub === 'sub') $(cmd.jQ.addClass('mq-sup-only')[0].lastChild).remove();\n        this.remove();\n      };\n    }(this, 'sub sup'.split(' ')[i], 'sup sub'.split(' ')[i], 'down up'.split(' ')[i]));\n  };\n});\n\nfunction insLeftOfMeUnlessAtEnd(cursor) {\n  // cursor.insLeftOf(cmd), unless cursor at the end of block, and every\n  // ancestor cmd is at the end of every ancestor block\n  var cmd = this.parent, ancestorCmd = cursor;\n  do {\n    if (ancestorCmd[R]) return cursor.insLeftOf(cmd);\n    ancestorCmd = ancestorCmd.parent.parent;\n  } while (ancestorCmd !== cmd);\n  cursor.insRightOf(cmd);\n}\n\nLatexCmds.subscript =\nLatexCmds._ = P(SupSub, function(_, super_) {\n  _.supsub = 'sub';\n  _.htmlTemplate =\n      '<span class=\"mq-supsub mq-non-leaf\">'\n    +   '<span class=\"mq-sub\">&0</span>'\n    +   '<span style=\"display:inline-block;width:0\">&#8203;</span>'\n    + '</span>'\n  ;\n  _.textTemplate = [ '_' ];\n  _.finalizeTree = function() {\n    this.downInto = this.sub = this.ends[L];\n    this.sub.upOutOf = insLeftOfMeUnlessAtEnd;\n    super_.finalizeTree.call(this);\n  };\n});\n\nLatexCmds.superscript =\nLatexCmds.supscript =\nLatexCmds['^'] = P(SupSub, function(_, super_) {\n  _.supsub = 'sup';\n  _.htmlTemplate =\n      '<span class=\"mq-supsub mq-non-leaf mq-sup-only\">'\n    +   '<span class=\"mq-sup\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = [ '^' ];\n  _.finalizeTree = function() {\n    this.upInto = this.sup = this.ends[R];\n    this.sup.downOutOf = insLeftOfMeUnlessAtEnd;\n    super_.finalizeTree.call(this);\n  };\n});\n\nvar SummationNotation = P(MathCommand, function(_, super_) {\n  _.init = function(ch, html) {\n    var htmlTemplate =\n      '<span class=\"mq-large-operator mq-non-leaf\">'\n    +   '<span class=\"mq-to\"><span>&1</span></span>'\n    +   '<big>'+html+'</big>'\n    +   '<span class=\"mq-from\"><span>&0</span></span>'\n    + '</span>'\n    ;\n    Symbol.prototype.init.call(this, ch, htmlTemplate);\n  };\n  _.createLeftOf = function(cursor) {\n    super_.createLeftOf.apply(this, arguments);\n    if (cursor.options.sumStartsWithNEquals) {\n      Letter('n').createLeftOf(cursor);\n      Equality().createLeftOf(cursor);\n    }\n  };\n  _.latex = function() {\n    function simplify(latex) {\n      return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';\n    }\n    return this.ctrlSeq + '_' + simplify(this.ends[L].latex()) +\n      '^' + simplify(this.ends[R].latex());\n  };\n  _.parser = function() {\n    var string = Parser.string;\n    var optWhitespace = Parser.optWhitespace;\n    var succeed = Parser.succeed;\n    var block = latexMathParser.block;\n\n    var self = this;\n    var blocks = self.blocks = [ MathBlock(), MathBlock() ];\n    for (var i = 0; i < blocks.length; i += 1) {\n      blocks[i].adopt(self, self.ends[R], 0);\n    }\n\n    return optWhitespace.then(string('_').or(string('^'))).then(function(supOrSub) {\n      var child = blocks[supOrSub === '_' ? 0 : 1];\n      return block.then(function(block) {\n        block.children().adopt(child, child.ends[R], 0);\n        return succeed(self);\n      });\n    }).many().result(self);\n  };\n  _.finalizeTree = function() {\n    this.downInto = this.ends[L];\n    this.upInto = this.ends[R];\n    this.ends[L].upOutOf = this.ends[R];\n    this.ends[R].downOutOf = this.ends[L];\n  };\n});\n\nLatexCmds['\\u2211'] =\nLatexCmds.sum =\nLatexCmds.summation = bind(SummationNotation,'\\\\sum ','&sum;');\n\nLatexCmds['\\u220f'] =\nLatexCmds.prod =\nLatexCmds.product = bind(SummationNotation,'\\\\prod ','&prod;');\n\nLatexCmds.coprod =\nLatexCmds.coproduct = bind(SummationNotation,'\\\\coprod ','&#8720;');\n\nLatexCmds['\\u222b'] =\nLatexCmds['int'] =\nLatexCmds.integral = P(SummationNotation, function(_, super_) {\n  _.init = function() {\n    var htmlTemplate =\n      '<span class=\"mq-int mq-non-leaf\">'\n    +   '<big>&int;</big>'\n    +   '<span class=\"mq-supsub mq-non-leaf\">'\n    +     '<span class=\"mq-sup\"><span class=\"mq-sup-inner\">&1</span></span>'\n    +     '<span class=\"mq-sub\">&0</span>'\n    +     '<span style=\"display:inline-block;width:0\">&#8203</span>'\n    +   '</span>'\n    + '</span>'\n    ;\n    Symbol.prototype.init.call(this, '\\\\int ', htmlTemplate);\n  };\n  // FIXME: refactor rather than overriding\n  _.createLeftOf = MathCommand.p.createLeftOf;\n});\n\nvar Fraction =\nLatexCmds.frac =\nLatexCmds.dfrac =\nLatexCmds.cfrac =\nLatexCmds.fraction = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\frac';\n  _.htmlTemplate =\n      '<span class=\"mq-fraction mq-non-leaf\">'\n    +   '<span class=\"mq-numerator\">&0</span>'\n    +   '<span class=\"mq-denominator\">&1</span>'\n    +   '<span style=\"display:inline-block;width:0\">&#8203;</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['(', ')/(', ')'];\n  _.finalizeTree = function() {\n    this.upInto = this.ends[R].upOutOf = this.ends[L];\n    this.downInto = this.ends[L].downOutOf = this.ends[R];\n  };\n});\n\nvar LiveFraction =\nLatexCmds.over =\nCharCmds['/'] = P(Fraction, function(_, super_) {\n  _.createLeftOf = function(cursor) {\n    if (!this.replacedFragment) {\n      var leftward = cursor[L];\n      while (leftward &&\n        !(\n          leftward instanceof BinaryOperator ||\n          leftward instanceof (LatexCmds.text || noop) ||\n          leftward instanceof SummationNotation ||\n          leftward.ctrlSeq === '\\\\ ' ||\n          /^[,;:]$/.test(leftward.ctrlSeq)\n        ) //lookbehind for operator\n      ) leftward = leftward[L];\n\n      if (leftward instanceof SummationNotation && leftward[R] instanceof SupSub) {\n        leftward = leftward[R];\n        if (leftward[R] instanceof SupSub && leftward[R].ctrlSeq != leftward.ctrlSeq)\n          leftward = leftward[R];\n      }\n\n      if (leftward !== cursor[L]) {\n        this.replaces(Fragment(leftward[R] || cursor.parent.ends[L], cursor[L]));\n        cursor[L] = leftward;\n      }\n    }\n    super_.createLeftOf.call(this, cursor);\n  };\n});\n\nvar SquareRoot =\nLatexCmds.sqrt =\nLatexCmds['\\u221a'] = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\sqrt';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-scaled mq-sqrt-prefix\">&radic;</span>'\n    +   '<span class=\"mq-non-leaf mq-sqrt-stem\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['sqrt(', ')'];\n  _.parser = function() {\n    return latexMathParser.optBlock.then(function(optBlock) {\n      return latexMathParser.block.map(function(block) {\n        var nthroot = NthRoot();\n        nthroot.blocks = [ optBlock, block ];\n        optBlock.adopt(nthroot, 0, 0);\n        block.adopt(nthroot, optBlock, 0);\n        return nthroot;\n      });\n    }).or(super_.parser.call(this));\n  };\n  _.reflow = function() {\n    var block = this.ends[R].jQ;\n    scale(block.prev(), 1, block.innerHeight()/+block.css('fontSize').slice(0,-2) - .1);\n  };\n});\n\nvar Vec = LatexCmds.vec = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\vec';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-vector-prefix\">&rarr;</span>'\n    +   '<span class=\"mq-vector-stem\">&0</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['vec(', ')'];\n});\n\nvar NthRoot =\nLatexCmds.nthroot = P(SquareRoot, function(_, super_) {\n  _.htmlTemplate =\n      '<sup class=\"mq-nthroot mq-non-leaf\">&0</sup>'\n    + '<span class=\"mq-scaled\">'\n    +   '<span class=\"mq-sqrt-prefix mq-scaled\">&radic;</span>'\n    +   '<span class=\"mq-sqrt-stem mq-non-leaf\">&1</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['sqrt[', '](', ')'];\n  _.latex = function() {\n    return '\\\\sqrt['+this.ends[L].latex()+']{'+this.ends[R].latex()+'}';\n  };\n});\n\nfunction DelimsMixin(_, super_) {\n  _.jQadd = function() {\n    super_.jQadd.apply(this, arguments);\n    this.delimjQs = this.jQ.children(':first').add(this.jQ.children(':last'));\n    this.contentjQ = this.jQ.children(':eq(1)');\n  };\n  _.reflow = function() {\n    var height = this.contentjQ.outerHeight()\n                 / parseFloat(this.contentjQ.css('fontSize'));\n    scale(this.delimjQs, min(1 + .2*(height - 1), 1.2), 1.2*height);\n  };\n}\n\n// Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)\n//   first typed as one-sided bracket with matching \"ghost\" bracket at\n//   far end of current block, until you type an opposing one\nvar Bracket = P(P(MathCommand, DelimsMixin), function(_, super_) {\n  _.init = function(side, open, close, ctrlSeq, end) {\n    super_.init.call(this, '\\\\left'+ctrlSeq, undefined, [open, close]);\n    this.side = side;\n    this.sides = {};\n    this.sides[L] = { ch: open, ctrlSeq: ctrlSeq };\n    this.sides[R] = { ch: close, ctrlSeq: end };\n  };\n  _.numBlocks = function() { return 1; };\n  _.html = function() { // wait until now so that .side may\n    this.htmlTemplate = // be set by createLeftOf or parser\n        '<span class=\"mq-non-leaf\">'\n      +   '<span class=\"mq-scaled mq-paren'+(this.side === R ? ' mq-ghost' : '')+'\">'\n      +     this.sides[L].ch\n      +   '</span>'\n      +   '<span class=\"mq-non-leaf\">&0</span>'\n      +   '<span class=\"mq-scaled mq-paren'+(this.side === L ? ' mq-ghost' : '')+'\">'\n      +     this.sides[R].ch\n      +   '</span>'\n      + '</span>'\n    ;\n    return super_.html.call(this);\n  };\n  _.latex = function() {\n    return '\\\\left'+this.sides[L].ctrlSeq+this.ends[L].latex()+'\\\\right'+this.sides[R].ctrlSeq;\n  };\n  _.oppBrack = function(opts, node, expectedSide) {\n    // return node iff it's a 1-sided bracket of expected side (if any, may be\n    // undefined), and of opposite side from me if I'm not a pipe\n    return node instanceof Bracket && node.side && node.side !== -expectedSide\n      && (this.sides[this.side].ch === '|' || node.side === -this.side)\n      && (!opts.restrictMismatchedBrackets\n        || OPP_BRACKS[this.sides[this.side].ch] === node.sides[node.side].ch\n        || { '(': ']', '[': ')' }[this.sides[L].ch] === node.sides[R].ch) && node;\n  };\n  _.closeOpposing = function(brack) {\n    brack.side = 0;\n    brack.sides[this.side] = this.sides[this.side]; // copy over my info (may be\n    brack.delimjQs.eq(this.side === L ? 0 : 1) // mismatched, like [a, b))\n      .removeClass('mq-ghost').html(this.sides[this.side].ch);\n  };\n  _.createLeftOf = function(cursor) {\n    if (!this.replacedFragment) { // unless wrapping seln in brackets,\n        // check if next to or inside an opposing one-sided bracket\n        // (must check both sides 'cos I might be a pipe)\n      var opts = cursor.options;\n      var brack = this.oppBrack(opts, cursor[L], L)\n                  || this.oppBrack(opts, cursor[R], R)\n                  || this.oppBrack(opts, cursor.parent.parent);\n    }\n    if (brack) {\n      var side = this.side = -brack.side; // may be pipe with .side not yet set\n      this.closeOpposing(brack);\n      if (brack === cursor.parent.parent && cursor[side]) { // move the stuff between\n        Fragment(cursor[side], cursor.parent.ends[side], -side) // me and ghost outside\n          .disown().withDirAdopt(-side, brack.parent, brack, brack[side])\n          .jQ.insDirOf(side, brack.jQ);\n        brack.bubble('reflow');\n      }\n    }\n    else {\n      brack = this, side = brack.side;\n      if (brack.replacedFragment) brack.side = 0; // wrapping seln, don't be one-sided\n      else if (cursor[-side]) { // elsewise, auto-expand so ghost is at far end\n        brack.replaces(Fragment(cursor[-side], cursor.parent.ends[-side], side));\n        cursor[-side] = 0;\n      }\n      super_.createLeftOf.call(brack, cursor);\n    }\n    if (side === L) cursor.insAtLeftEnd(brack.ends[L]);\n    else cursor.insRightOf(brack);\n  };\n  _.placeCursor = noop;\n  _.unwrap = function() {\n    this.ends[L].children().disown().adopt(this.parent, this, this[R])\n      .jQ.insertAfter(this.jQ);\n    this.remove();\n  };\n  _.deleteSide = function(side, outward, cursor) {\n    var parent = this.parent, sib = this[side], farEnd = parent.ends[side];\n\n    if (side === this.side) { // deleting non-ghost of one-sided bracket, unwrap\n      this.unwrap();\n      sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n      return;\n    }\n\n    var opts = cursor.options, wasSolid = !this.side;\n    this.side = -side;\n    // if deleting like, outer close-brace of [(1+2)+3} where inner open-paren\n    if (this.oppBrack(opts, this.ends[L].ends[this.side], side)) { // is ghost,\n      this.closeOpposing(this.ends[L].ends[this.side]); // then become [1+2)+3\n      var origEnd = this.ends[L].ends[side];\n      this.unwrap();\n      if (origEnd.siblingCreated) origEnd.siblingCreated(cursor.options, side);\n      sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n    }\n    else { // if deleting like, inner close-brace of ([1+2}+3) where outer\n      if (this.oppBrack(opts, this.parent.parent, side)) { // open-paren is\n        this.parent.parent.closeOpposing(this); // ghost, then become [1+2+3)\n        this.parent.parent.unwrap();\n      } // else if deleting outward from a solid pair, unwrap\n      else if (outward && wasSolid) {\n        this.unwrap();\n        sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);\n        return;\n      }\n      else { // else deleting just one of a pair of brackets, become one-sided\n        this.sides[side] = { ch: OPP_BRACKS[this.sides[this.side].ch],\n                             ctrlSeq: OPP_BRACKS[this.sides[this.side].ctrlSeq] };\n        this.delimjQs.removeClass('mq-ghost')\n          .eq(side === L ? 0 : 1).addClass('mq-ghost').html(this.sides[side].ch);\n      }\n      if (sib) { // auto-expand so ghost is at far end\n        var origEnd = this.ends[L].ends[side];\n        Fragment(sib, farEnd, -side).disown()\n          .withDirAdopt(-side, this.ends[L], origEnd, 0)\n          .jQ.insAtDirEnd(side, this.ends[L].jQ.removeClass('mq-empty'));\n        if (origEnd.siblingCreated) origEnd.siblingCreated(cursor.options, side);\n        cursor.insDirOf(-side, sib);\n      } // didn't auto-expand, cursor goes just outside or just inside parens\n      else (outward ? cursor.insDirOf(side, this)\n                    : cursor.insAtDirEnd(side, this.ends[L]));\n    }\n  };\n  _.deleteTowards = function(dir, cursor) {\n    this.deleteSide(-dir, false, cursor);\n  };\n  _.finalizeTree = function() {\n    this.ends[L].deleteOutOf = function(dir, cursor) {\n      this.parent.deleteSide(dir, true, cursor);\n    };\n    // FIXME HACK: after initial creation/insertion, finalizeTree would only be\n    // called if the paren is selected and replaced, e.g. by LiveFraction\n    this.finalizeTree = this.intentionalBlur = function() {\n      this.delimjQs.eq(this.side === L ? 1 : 0).removeClass('mq-ghost');\n      this.side = 0;\n    };\n  };\n  _.siblingCreated = function(opts, dir) { // if something typed between ghost and far\n    if (dir === -this.side) this.finalizeTree(); // end of its block, solidify\n  };\n});\n\nvar OPP_BRACKS = {\n  '(': ')',\n  ')': '(',\n  '[': ']',\n  ']': '[',\n  '{': '}',\n  '}': '{',\n  '\\\\{': '\\\\}',\n  '\\\\}': '\\\\{',\n  '&lang;': '&rang;',\n  '&rang;': '&lang;',\n  '\\\\langle ': '\\\\rangle ',\n  '\\\\rangle ': '\\\\langle ',\n  '|': '|'\n};\n\nfunction bindCharBracketPair(open, ctrlSeq) {\n  var ctrlSeq = ctrlSeq || open, close = OPP_BRACKS[open], end = OPP_BRACKS[ctrlSeq];\n  CharCmds[open] = bind(Bracket, L, open, close, ctrlSeq, end);\n  CharCmds[close] = bind(Bracket, R, open, close, ctrlSeq, end);\n}\nbindCharBracketPair('(');\nbindCharBracketPair('[');\nbindCharBracketPair('{', '\\\\{');\nLatexCmds.langle = bind(Bracket, L, '&lang;', '&rang;', '\\\\langle ', '\\\\rangle ');\nLatexCmds.rangle = bind(Bracket, R, '&lang;', '&rang;', '\\\\langle ', '\\\\rangle ');\nCharCmds['|'] = bind(Bracket, L, '|', '|', '|', '|');\n\nLatexCmds.left = P(MathCommand, function(_) {\n  _.parser = function() {\n    var regex = Parser.regex;\n    var string = Parser.string;\n    var succeed = Parser.succeed;\n    var optWhitespace = Parser.optWhitespace;\n\n    return optWhitespace.then(regex(/^(?:[([|]|\\\\\\{)/))\n      .then(function(ctrlSeq) { // TODO: \\langle, \\rangle\n        var open = (ctrlSeq.charAt(0) === '\\\\' ? ctrlSeq.slice(1) : ctrlSeq);\n        return latexMathParser.then(function (block) {\n          return string('\\\\right').skip(optWhitespace)\n            .then(regex(/^(?:[\\])|]|\\\\\\})/)).map(function(end) {\n              var close = (end.charAt(0) === '\\\\' ? end.slice(1) : end);\n              var cmd = Bracket(0, open, close, ctrlSeq, end);\n              cmd.blocks = [ block ];\n              block.adopt(cmd, 0, 0);\n              return cmd;\n            })\n          ;\n        });\n      })\n    ;\n  };\n});\n\nLatexCmds.right = P(MathCommand, function(_) {\n  _.parser = function() {\n    return Parser.fail('unmatched \\\\right');\n  };\n});\n\nvar Binomial =\nLatexCmds.binom =\nLatexCmds.binomial = P(P(MathCommand, DelimsMixin), function(_, super_) {\n  _.ctrlSeq = '\\\\binom';\n  _.htmlTemplate =\n      '<span class=\"mq-non-leaf\">'\n    +   '<span class=\"mq-paren mq-scaled\">(</span>'\n    +   '<span class=\"mq-non-leaf\">'\n    +     '<span class=\"mq-array mq-non-leaf\">'\n    +       '<span>&0</span>'\n    +       '<span>&1</span>'\n    +     '</span>'\n    +   '</span>'\n    +   '<span class=\"mq-paren mq-scaled\">)</span>'\n    + '</span>'\n  ;\n  _.textTemplate = ['choose(',',',')'];\n});\n\nvar Choose =\nLatexCmds.choose = P(Binomial, function(_) {\n  _.createLeftOf = LiveFraction.prototype.createLeftOf;\n});\n\nLatexCmds.editable = // backcompat with before cfd3620 on #233\nLatexCmds.MathQuillMathField = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\MathQuillMathField';\n  _.htmlTemplate =\n      '<span class=\"mq-editable-field\">'\n    +   '<span class=\"mq-root-block\">&0</span>'\n    + '</span>'\n  ;\n  _.parser = function() {\n    var self = this,\n      string = Parser.string, regex = Parser.regex, succeed = Parser.succeed;\n    return string('[').then(regex(/^[a-z][a-z0-9]*/i)).skip(string(']'))\n      .map(function(name) { self.name = name; }).or(succeed())\n      .then(super_.parser.call(self));\n  };\n  _.finalizeTree = function() {\n    var ctrlr = Controller(this.ends[L], this.jQ, Options());\n    ctrlr.KIND_OF_MQ = 'MathField';\n    ctrlr.editable = true;\n    ctrlr.createTextarea();\n    ctrlr.editablesTextareaEvents();\n    ctrlr.cursor.insAtRightEnd(ctrlr.root);\n    RootBlockMixin(ctrlr.root);\n  };\n  _.registerInnerField = function(innerFields, MathField) {\n    innerFields.push(innerFields[this.name] = MathField(this.ends[L].controller));\n  };\n  _.latex = function(){ return this.ends[L].latex(); };\n  _.text = function(){ return this.ends[L].text(); };\n});\n\n// Embed arbitrary things\n// Probably the closest DOM analogue would be an iframe?\n// From MathQuill's perspective, it's a Symbol, it can be\n// anywhere and the cursor can go around it but never in it.\n// Create by calling public API method .dropEmbedded(),\n// or by calling the global public API method .registerEmbed()\n// and rendering LaTeX like \\embed{registeredName} (see test).\nvar Embed = LatexCmds.embed = P(Symbol, function(_, super_) {\n  _.setOptions = function(options) {\n    function noop () { return \"\"; }\n    this.text = options.text || noop;\n    this.htmlTemplate = options.htmlString || \"\";\n    this.latex = options.latex || noop;\n    return this;\n  };\n  _.parser = function() {\n    var self = this;\n      string = Parser.string, regex = Parser.regex, succeed = Parser.succeed;\n    return string('{').then(regex(/^[a-z][a-z0-9]*/i)).skip(string('}'))\n      .then(function(name) {\n        // the chars allowed in the optional data block are arbitrary other than\n        // excluding curly braces and square brackets (which'd be too confusing)\n        return string('[').then(regex(/^[-\\w\\s]*/)).skip(string(']'))\n          .or(succeed()).map(function(data) {\n            return self.setOptions(EMBEDS[name](data));\n          })\n        ;\n      })\n    ;\n  };\n});\n/****************************************\n * Input box to type backslash commands\n ***************************************/\n\nvar LatexCommandInput =\nCharCmds['\\\\'] = P(MathCommand, function(_, super_) {\n  _.ctrlSeq = '\\\\';\n  _.replaces = function(replacedFragment) {\n    this._replacedFragment = replacedFragment.disown();\n    this.isEmpty = function() { return false; };\n  };\n  _.htmlTemplate = '<span class=\"mq-latex-command-input mq-non-leaf\">\\\\<span>&0</span></span>';\n  _.textTemplate = ['\\\\'];\n  _.createBlocks = function() {\n    super_.createBlocks.call(this);\n    this.ends[L].focus = function() {\n      this.parent.jQ.addClass('mq-hasCursor');\n      if (this.isEmpty())\n        this.parent.jQ.removeClass('mq-empty');\n\n      return this;\n    };\n    this.ends[L].blur = function() {\n      this.parent.jQ.removeClass('mq-hasCursor');\n      if (this.isEmpty())\n        this.parent.jQ.addClass('mq-empty');\n\n      return this;\n    };\n    this.ends[L].write = function(cursor, ch) {\n      cursor.show().deleteSelection();\n\n      if (ch.match(/[a-z]/i)) VanillaSymbol(ch).createLeftOf(cursor);\n      else {\n        this.parent.renderCommand(cursor);\n        if (ch !== '\\\\' || !this.isEmpty()) this.parent.parent.write(cursor, ch);\n      }\n    };\n    this.ends[L].keystroke = function(key, e, ctrlr) {\n      if (key === 'Tab' || key === 'Enter' || key === 'Spacebar') {\n        this.parent.renderCommand(ctrlr.cursor);\n        e.preventDefault();\n        return;\n      }\n      return super_.keystroke.apply(this, arguments);\n    };\n  };\n  _.createLeftOf = function(cursor) {\n    super_.createLeftOf.call(this, cursor);\n\n    if (this._replacedFragment) {\n      var el = this.jQ[0];\n      this.jQ =\n        this._replacedFragment.jQ.addClass('mq-blur').bind(\n          'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?\n          function(e) {\n            $(e.target = el).trigger(e);\n            return false;\n          }\n        ).insertBefore(this.jQ).add(this.jQ);\n    }\n  };\n  _.latex = function() {\n    return '\\\\' + this.ends[L].latex() + ' ';\n  };\n  _.renderCommand = function(cursor) {\n    this.jQ = this.jQ.last();\n    this.remove();\n    if (this[R]) {\n      cursor.insLeftOf(this[R]);\n    } else {\n      cursor.insAtRightEnd(this.parent);\n    }\n\n    var latex = this.ends[L].latex();\n    if (!latex) latex = ' ';\n    var cmd = LatexCmds[latex];\n    if (cmd) {\n      cmd = cmd(latex);\n      if (this._replacedFragment) cmd.replaces(this._replacedFragment);\n      cmd.createLeftOf(cursor);\n    }\n    else {\n      cmd = TextBlock();\n      cmd.replaces(latex);\n      cmd.createLeftOf(cursor);\n      cursor.insRightOf(cmd);\n      if (this._replacedFragment)\n        this._replacedFragment.remove();\n    }\n  };\n});\n\nvar MQ1 = getInterface(1);\nfor (var key in MQ1) (function(key, val) {\n  if (typeof val === 'function') {\n    MathQuill[key] = function() {\n      insistOnInterVer();\n      return val.apply(this, arguments);\n    };\n    MathQuill[key].prototype = val.prototype;\n  }\n  else MathQuill[key] = val;\n}(key, MQ1[key]));\n\n}());\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL21hdGhxdWlsbC5qcz9hZjMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLEVBQUU7QUFDbEUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCLHFDQUFxQyxFQUFFO0FBQzVFLDJCQUEyQjtBQUMzQjtBQUNBLGlCQUFpQixvQ0FBb0Msd0JBQXdCLEVBQUU7QUFDL0UseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QixjQUFjLEVBQUUsRUFBRTtBQUNuRCxRQUFRLHlCQUF5QixjQUFjLEVBQUUsRUFBRTtBQUNuRCxRQUFRLHlCQUF5QixjQUFjLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsa0JBQWtCLEVBQUU7OztBQUdoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsQ0FBQzs7QUFFRCxzRkFBc0Y7O0FBRXRGO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0EsNkRBQTZEOztBQUU3RCwyRUFBMkU7O0FBRTNFLG1HQUFtRzs7QUFFbkcsc0VBQXNFOztBQUV0RSxxRUFBcUU7O0FBRXJFO0FBQ0EsMkNBQTJDOztBQUUzQyx5RUFBeUU7O0FBRXpFO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7OztBQUdqRDtBQUNBO0FBQ0EsK0JBQStCLEVBQUUsVUFBVTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRSxVQUFVOztBQUUzQztBQUNBLCtCQUErQixFQUFFLFVBQVU7O0FBRTNDO0FBQ0EsK0JBQStCLEVBQUUsVUFBVTs7QUFFM0M7QUFDQSwrQkFBK0IsRUFBRSxVQUFVOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFLFVBQVU7O0FBRTNDO0FBQ0EsK0JBQStCLEVBQUUsVUFBVTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELDBFQUEwRTtBQUMxRSw0REFBNEQ7QUFDNUQsMERBQTBEO0FBQzFELDhFQUE4RTtBQUM5RSwwREFBMEQ7QUFDMUQsd0VBQXdFO0FBQ3hFLDBEQUEwRDtBQUMxRCwwRUFBMEU7QUFDMUU7QUFDQSw4RUFBOEU7QUFDOUUsOERBQThEO0FBQzlELDREQUE0RDtBQUM1RCw2REFBNkQ7QUFDN0Qsb0RBQW9EO0FBQ3BELDBEQUEwRDs7QUFFMUQ7QUFDQSw0REFBNEQ7QUFDNUQsd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDBEQUEwRDtBQUMxRCxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxnRUFBZ0U7QUFDaEUsa0VBQWtFO0FBQ2xFLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLDBEQUEwRDtBQUMxRCxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsd0RBQXdEOztBQUV4RDtBQUNBLDBFQUEwRTtBQUMxRSw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLDRFQUE0RTtBQUM1RSxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsNERBQTREO0FBQzVELDhEQUE4RDtBQUM5RCwwRUFBMEU7QUFDMUUsNEVBQTRFO0FBQzVFLDhEQUE4RDtBQUM5RCwwRUFBMEU7QUFDMUUsNEVBQTRFO0FBQzVFLDhEQUE4RDtBQUM5RCw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDhEQUE4RDs7QUFFOUQ7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsd0RBQXdEO0FBQ3hELGdFQUFnRTtBQUNoRSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHdEQUF3RDtBQUN4RCw4REFBOEQ7QUFDOUQsMERBQTBEO0FBQzFELG9EQUFvRDtBQUNwRCxzREFBc0Q7QUFDdEQsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFO0FBQ0EsMEVBQTBFO0FBQzFFLDZEQUE2RDs7QUFFN0Q7QUFDQSx3REFBd0Q7QUFDeEQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsNERBQTREO0FBQzVELGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQsa0VBQWtFO0FBQ2xFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7O0FBRWhFO0FBQ0EsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELGlGQUFpRjtBQUNqRixrRkFBa0Y7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0Usd0VBQXdFO0FBQ3hFLHNEQUFzRDs7QUFFdEQ7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0EsdUNBQXVDOztBQUV2QywwRUFBMEU7O0FBRTFFO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0EseUNBQXlDOztBQUV6Qyw0RUFBNEU7O0FBRTVFLGtEQUFrRDs7QUFFbEQsa0ZBQWtGOztBQUVsRiwrREFBK0Q7O0FBRS9ELGtGQUFrRjs7QUFFbEYsc0RBQXNEOztBQUV0RCxnRkFBZ0Y7O0FBRWhGLGdFQUFnRTs7QUFFaEUsZ0ZBQWdGOztBQUVoRjtBQUNBLGdEQUFnRDs7QUFFaEQsK0RBQStEOztBQUUvRDtBQUNBLGdEQUFnRDs7QUFFaEQsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyw0RUFBNEU7O0FBRTVFO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0Esc0NBQXNDOztBQUV0QyxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QyxxRUFBcUU7O0FBRXJFO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBLHdFQUF3RTs7QUFFeEUsc0VBQXNFO0FBQ3RFLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixpREFBaUQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLHlCQUF5QixxQkFBcUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrREFBK0QsZ0JBQWdCO0FBQy9FLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9ELG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRSxtRUFBbUU7QUFDbkUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLGtEQUFrRCxxQkFBcUIsRUFBRTtBQUN6RTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxxRUFBcUU7O0FBRXJFLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBLHdFQUF3RTtBQUN4RSw4REFBOEQ7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQixjQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxZQUFZLDhCQUE4QjtBQUMxQyxrREFBa0Q7QUFDbEQsZUFBZSw4QkFBOEI7QUFDN0MscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsaUZBQWlGOztBQUVqRjtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0IsNkJBQTZCO0FBQzVELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CLCtCQUErQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGlCQUFpQixJQUFJLEVBQUUsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxNQUFNO0FBQ3JELHFCQUFxQixLQUFLO0FBQzFCO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUUsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHFDQUFxQyx1Q0FBdUM7QUFDNUUsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxrRUFBa0U7QUFDbEUsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlEQUFpRDtBQUMzRCwwREFBMEQ7QUFDMUQsK0NBQStDO0FBQy9DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsZ0RBQWdEO0FBQ2hEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLO0FBQ1QsSUFBSSxLQUFLO0FBQ1QsTUFBTSxPQUFPO0FBQ2IsTUFBTSxPQUFPO0FBQ2IsU0FBUyxVQUFVO0FBQ25CLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLDJDQUEyQyxVQUFVO0FBQ3JELDJDQUEyQyxVQUFVO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQsc0JBQXNCLDRCQUE0QjtBQUNsRCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFpRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWF0aFF1aWxsIHYwLjEwLjEgICAgICAgICAgICAgICBodHRwOi8vbWF0aHF1aWxsLmNvbVxuICogYnkgSGFuLCBKZWFuaW5lLCBhbmQgTWFyeSAgbWFpbnRhaW5lcnNAbWF0aHF1aWxsLmNvbVxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGVcbiAqIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUExcbiAqIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluXG4gKiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5cbihmdW5jdGlvbigpIHtcblxudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG4gIHVuZGVmaW5lZCxcbiAgbXFDbWRJZCA9ICdtYXRocXVpbGwtY29tbWFuZC1pZCcsXG4gIG1xQmxvY2tJZCA9ICdtYXRocXVpbGwtYmxvY2staWQnLFxuICBtaW4gPSBNYXRoLm1pbixcbiAgbWF4ID0gTWF0aC5tYXg7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIEEgdXRpbGl0eSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCBtYWtlcyBkZWZpbmluZyB2YXJpYWRpY1xuICogZnVuY3Rpb25zIG1vcmUgY29udmVuaWVudCBieSBsZXR0aW5nIHlvdSBlc3NlbnRpYWxseSBkZWZpbmUgZnVuY3Rpb25zXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50IGFzIGEgc3BsYXQsIGkuZS4gdGhlIGxhc3QgYXJndW1lbnQgXCJnYXRoZXJzIHVwXCJcbiAqIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uOlxuICogICB2YXIgZG9TdHVmZiA9IHZhcmlhZGljKGZ1bmN0aW9uKGZpcnN0LCByZXN0KSB7IHJldHVybiByZXN0OyB9KTtcbiAqICAgZG9TdHVmZigxLCAyLCAzKTsgLy8gPT4gWzIsIDNdXG4gKi9cbnZhciBfX3NsaWNlID0gW10uc2xpY2U7XG5mdW5jdGlvbiB2YXJpYWRpYyhmbikge1xuICB2YXIgbnVtRml4ZWRBcmdzID0gZm4ubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgbnVtRml4ZWRBcmdzKTtcbiAgICB2YXIgdmFyQXJnID0gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgbnVtRml4ZWRBcmdzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncy5jb25jYXQoWyB2YXJBcmcgXSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCBtYWtlcyBjb21iaW5pbmcgb2JqZWN0LW9yaWVudGVkXG4gKiBwcm9ncmFtbWluZyBhbmQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyB0ZWNobmlxdWVzIG1vcmUgY29udmVuaWVudDpcbiAqIGdpdmVuIGEgbWV0aG9kIG5hbWUgYW5kIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIGJvdW5kLCByZXR1cm5zXG4gKiBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgaXQncyBmaXJzdCBhcmd1bWVudCdzIG1ldGhvZCBvZiB0aGF0IG5hbWUgKGlmXG4gKiBpdCBleGlzdHMpIHdpdGggdGhlIGJvdW5kIGFyZ3VtZW50cyBhbmQgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXRcbiAqIGFyZSBwYXNzZWQ6XG4gKiAgIHZhciBzZW5kTWV0aG9kID0gc2VuZCgnbWV0aG9kJywgMSwgMik7XG4gKiAgIHZhciBvYmogPSB7IG1ldGhvZDogZnVuY3Rpb24oKSB7IHJldHVybiBBcnJheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IH07XG4gKiAgIHNlbmRNZXRob2Qob2JqLCAzLCA0KTsgLy8gPT4gWzEsIDIsIDMsIDRdXG4gKiAgIC8vIG9yIG1vcmUgc3BlY2lmaWNhbGx5LFxuICogICB2YXIgb2JqMiA9IHsgbWV0aG9kOiBmdW5jdGlvbihvbmUsIHR3bywgdGhyZWUpIHsgcmV0dXJuIG9uZSp0d28gKyB0aHJlZTsgfSB9O1xuICogICBzZW5kTWV0aG9kKG9iajIsIDMpOyAvLyA9PiA1XG4gKiAgIHNlbmRNZXRob2Qob2JqMiwgNCk7IC8vID0+IDZcbiAqL1xudmFyIHNlbmQgPSB2YXJpYWRpYyhmdW5jdGlvbihtZXRob2QsIGFyZ3MpIHtcbiAgcmV0dXJuIHZhcmlhZGljKGZ1bmN0aW9uKG9iaiwgbW9yZUFyZ3MpIHtcbiAgICBpZiAobWV0aG9kIGluIG9iaikgcmV0dXJuIG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncy5jb25jYXQobW9yZUFyZ3MpKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBBIHV0aWxpdHkgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBcImltcGxpY2l0IGl0ZXJhdG9yc1wiXG4gKiBmcm9tIFwiZ2VuZXJhdG9yc1wiOiBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gYSBzb2xlIGFyZ3VtZW50LFxuICogYSBcInlpZWxkX1wiIGZ1bmN0aW9uLCB0aGF0IGNhbGxzIFwieWllbGRfXCIgcmVwZWF0ZWRseSB3aXRoIGFuIG9iamVjdCBhc1xuICogYSBzb2xlIGFyZ3VtZW50IChwcmVzdW1hYmx5IG9iamVjdHMgYmVpbmcgaXRlcmF0ZWQgb3ZlciksIHJldHVybnNcbiAqIGEgZnVuY3Rpb24gdGhhdCBjYWxscyBpdCdzIGZpcnN0IGFyZ3VtZW50IG9uIGVhY2ggb2YgdGhvc2Ugb2JqZWN0c1xuICogKGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBjYWxsZWQgcmVwZWF0ZWRseSB3aXRoXG4gKiBlYWNoIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIG90aGVyd2lzZSBpdCBpcyBzdHJpbmdpZmllZCBhbmRcbiAqIHRoZSBtZXRob2Qgb2YgdGhhdCBuYW1lIGlzIGNhbGxlZCBvbiBlYWNoIG9iamVjdCAoaWYgc3VjaCBhIG1ldGhvZFxuICogZXhpc3RzKSksIHBhc3NpbmcgYWxvbmcgYWxsIGFkZGl0aW9uYWwgYXJndW1lbnRzOlxuICogICB2YXIgYSA9IFtcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMSk7IH0gfSxcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMik7IH0gfSxcbiAqICAgICB7IG1ldGhvZDogZnVuY3Rpb24obGlzdCkgeyBsaXN0LnB1c2goMyk7IH0gfVxuICogICBdO1xuICogICBhLmVhY2ggPSBpdGVyYXRvcihmdW5jdGlvbih5aWVsZF8pIHtcbiAqICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHlpZWxkXyh0aGlzW2ldKTtcbiAqICAgfSk7XG4gKiAgIHZhciBsaXN0ID0gW107XG4gKiAgIGEuZWFjaCgnbWV0aG9kJywgbGlzdCk7XG4gKiAgIGxpc3Q7IC8vID0+IFsxLCAyLCAzXVxuICogICAvLyBOb3RlIHRoYXQgdGhlIGZvci1pbiBsb29wIHdpbGwgeWllbGQgJ2VhY2gnLCBidXQgJ2VhY2gnIG1hcHMgdG9cbiAqICAgLy8gdGhlIGZ1bmN0aW9uIG9iamVjdCBjcmVhdGVkIGJ5IGl0ZXJhdG9yKCkgd2hpY2ggZG9lcyBub3QgaGF2ZSBhXG4gKiAgIC8vIC5tZXRob2QoKSBtZXRob2QsIHNvIHRoYXQganVzdCBmYWlscyBzaWxlbnRseS5cbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gIHJldHVybiB2YXJpYWRpYyhmdW5jdGlvbihmbiwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIGZuID0gc2VuZChmbik7XG4gICAgdmFyIHlpZWxkXyA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gZm4uYXBwbHkob2JqLCBbIG9iaiBdLmNvbmNhdChhcmdzKSk7IH07XG4gICAgcmV0dXJuIGdlbmVyYXRvci5jYWxsKHRoaXMsIHlpZWxkXyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIHN1Z2FyIHRvIG1ha2UgZGVmaW5pbmcgbG90cyBvZiBjb21tYW5kcyBlYXNpZXIuXG4gKiBUT0RPOiByZXRoaW5rIHRoaXMuXG4gKi9cbmZ1bmN0aW9uIGJpbmQoY29ucyAvKiwgYXJncy4uLiAqLykge1xuICB2YXIgYXJncyA9IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnMuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogYSBkZXZlbG9wbWVudC1vbmx5IGRlYnVnIG1ldGhvZC4gIFRoaXMgZGVmaW5pdGlvbiBhbmQgYWxsXG4gKiBjYWxscyB0byBgcHJheWAgd2lsbCBiZSBzdHJpcHBlZCBmcm9tIHRoZSBtaW5pZmllZFxuICogYnVpbGQgb2YgbWF0aHF1aWxsLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYnkgbmFtZSB0byBiZSByZW1vdmVkXG4gKiBhdCBjb21waWxlIHRpbWUuICBEbyBub3QgZGVmaW5lIGFub3RoZXIgZnVuY3Rpb25cbiAqIHdpdGggdGhlIHNhbWUgbmFtZSwgYW5kIG9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGJ5XG4gKiBuYW1lLlxuICovXG5mdW5jdGlvbiBwcmF5KG1lc3NhZ2UsIGNvbmQpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IoJ3ByYXllciBmYWlsZWQ6ICcrbWVzc2FnZSk7XG59XG52YXIgUCA9IChmdW5jdGlvbihwcm90b3R5cGUsIG93blByb3BlcnR5LCB1bmRlZmluZWQpIHtcbiAgLy8gaGVscGVyIGZ1bmN0aW9ucyB0aGF0IGFsc28gaGVscCBtaW5pZmljYXRpb25cbiAgZnVuY3Rpb24gaXNPYmplY3QobykgeyByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnOyB9XG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZikgeyByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7IH1cblxuICAvLyB1c2VkIHRvIGV4dGVuZCB0aGUgcHJvdG90eXBlcyBvZiBzdXBlcmNsYXNzZXMgKHdoaWNoIG1pZ2h0IG5vdFxuICAvLyBoYXZlIGAuQmFyZWBzKVxuICBmdW5jdGlvbiBTdXBlcmNsYXNzQmFyZSgpIHt9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIFAoX3N1cGVyY2xhc3MgLyogPSBPYmplY3QgKi8sIGRlZmluaXRpb24pIHtcbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgbm8gc3VwZXJjbGFzcyBpcyBnaXZlblxuICAgIGlmIChkZWZpbml0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmluaXRpb24gPSBfc3VwZXJjbGFzcztcbiAgICAgIF9zdXBlcmNsYXNzID0gT2JqZWN0O1xuICAgIH1cblxuICAgIC8vIEMgaXMgdGhlIGNsYXNzIHRvIGJlIHJldHVybmVkLlxuICAgIC8vXG4gICAgLy8gSXQgZGVsZWdhdGVzIHRvIGluc3RhbnRpYXRpbmcgYW4gaW5zdGFuY2Ugb2YgYEJhcmVgLCBzbyB0aGF0IGl0XG4gICAgLy8gd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3IGluc3RhbmNlIHJlZ2FyZGxlc3Mgb2YgdGhlIGNhbGxpbmdcbiAgICAvLyBjb250ZXh0LlxuICAgIC8vXG4gICAgLy8gIFRPRE86IHRoZSBDaHJvbWUgaW5zcGVjdG9yIHNob3dzIGFsbCBjcmVhdGVkIG9iamVjdHMgYXMgYENgXG4gICAgLy8gICAgICAgIHJhdGhlciB0aGFuIGBPYmplY3RgLiAgU2V0dGluZyB0aGUgLm5hbWUgcHJvcGVydHkgc2VlbXMgdG9cbiAgICAvLyAgICAgICAgaGF2ZSBubyBlZmZlY3QuICBJcyB0aGVyZSBhIHdheSB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yP1xuICAgIGZ1bmN0aW9uIEMoKSB7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBCYXJlO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZi5pbml0KSkgc2VsZi5pbml0LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBDLkJhcmUgaXMgYSBjbGFzcyB3aXRoIGEgbm9vcCBjb25zdHJ1Y3Rvci4gIEl0cyBwcm90b3R5cGUgaXMgdGhlXG4gICAgLy8gc2FtZSBhcyBDLCBzbyB0aGF0IGluc3RhbmNlcyBvZiBDLkJhcmUgYXJlIGFsc28gaW5zdGFuY2VzIG9mIEMuXG4gICAgLy8gTmV3IG9iamVjdHMgY2FuIGJlIGFsbG9jYXRlZCB3aXRob3V0IGluaXRpYWxpemF0aW9uIGJ5IGNhbGxpbmdcbiAgICAvLyBgbmV3IE15Q2xhc3MuQmFyZWAuXG4gICAgZnVuY3Rpb24gQmFyZSgpIHt9XG4gICAgQy5CYXJlID0gQmFyZTtcblxuICAgIC8vIFNldCB1cCB0aGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgY2xhc3MuXG4gICAgdmFyIF9zdXBlciA9IFN1cGVyY2xhc3NCYXJlW3Byb3RvdHlwZV0gPSBfc3VwZXJjbGFzc1twcm90b3R5cGVdO1xuICAgIHZhciBwcm90byA9IEJhcmVbcHJvdG90eXBlXSA9IENbcHJvdG90eXBlXSA9IEMucCA9IG5ldyBTdXBlcmNsYXNzQmFyZTtcblxuICAgIC8vIG90aGVyIHZhcmlhYmxlcywgYXMgYSBtaW5pZmllciBvcHRpbWl6YXRpb25cbiAgICB2YXIgZXh0ZW5zaW9ucztcblxuXG4gICAgLy8gc2V0IHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlLCBmb3IgY29udmVuaWVuY2VcbiAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG5cbiAgICBDLmV4dGVuZCA9IGZ1bmN0aW9uKGRlZikgeyByZXR1cm4gUChDLCBkZWYpOyB9XG5cbiAgICByZXR1cm4gKEMub3BlbiA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihkZWYpKSB7XG4gICAgICAgIC8vIGNhbGwgdGhlIGRlZmluaW5nIGZ1bmN0aW9uIHdpdGggYWxsIHRoZSBhcmd1bWVudHMgeW91IG5lZWRcbiAgICAgICAgLy8gZXh0ZW5zaW9ucyBjYXB0dXJlcyB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAgICBleHRlbnNpb25zID0gZGVmLmNhbGwoQywgcHJvdG8sIF9zdXBlciwgQywgX3N1cGVyY2xhc3MpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgICAgICAvLyBpZiB5b3UgcGFzc2VkIGFuIG9iamVjdCBpbnN0ZWFkLCB3ZSdsbCB0YWtlIGl0XG4gICAgICAgIGV4dGVuc2lvbnMgPSBkZWY7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCBleHRlbmQgaXRcbiAgICAgIGlmIChpc09iamVjdChleHRlbnNpb25zKSkge1xuICAgICAgICBmb3IgKHZhciBleHQgaW4gZXh0ZW5zaW9ucykge1xuICAgICAgICAgIGlmIChvd25Qcm9wZXJ0eS5jYWxsKGV4dGVuc2lvbnMsIGV4dCkpIHtcbiAgICAgICAgICAgIHByb3RvW2V4dF0gPSBleHRlbnNpb25zW2V4dF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gaW5pdCwgd2UgYXNzdW1lIHdlJ3JlIGluaGVyaXRpbmcgYSBub24tcGpzIGNsYXNzLCBzb1xuICAgICAgLy8gd2UgZGVmYXVsdCB0byBhcHBseWluZyB0aGUgc3VwZXJjbGFzcydzIGNvbnN0cnVjdG9yLlxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHByb3RvLmluaXQpKSB7XG4gICAgICAgIHByb3RvLmluaXQgPSBfc3VwZXJjbGFzcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEM7XG4gICAgfSkoZGVmaW5pdGlvbik7XG4gIH1cblxuICAvLyBhcyBhIG1pbmlmaWVyIG9wdGltaXphdGlvbiwgd2UndmUgY2xvc3VyZWQgaW4gYSBmZXcgaGVscGVyIGZ1bmN0aW9uc1xuICAvLyBhbmQgdGhlIHN0cmluZyAncHJvdG90eXBlJyAoQ1twXSBpcyBtdWNoIHNob3J0ZXIgdGhhbiBDLnByb3RvdHlwZSlcbn0pKCdwcm90b3R5cGUnLCAoe30pLmhhc093blByb3BlcnR5KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBCYXNlIGNsYXNzZXMgb2YgZWRpdCB0cmVlLXJlbGF0ZWQgb2JqZWN0c1xuICpcbiAqIE9ubHkgZG9pbmcgdHJlZSBub2RlIG1hbmlwdWxhdGlvbiB2aWEgdGhlc2VcbiAqIGFkb3B0LyBkaXNvd24gbWV0aG9kcyBndWFyYW50ZWVzIHdlbGwtZm9ybWVkbmVzc1xuICogb2YgdGhlIHRyZWUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBMID0gJ2xlZnQnXG4vLyBSID0gJ3JpZ2h0J1xuLy9cbi8vIHRoZSBjb250cmFjdCBpcyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgYXMgb2JqZWN0IHByb3BlcnRpZXNcbi8vIGFuZCAoLUwpID09PSBSLCBhbmQgKC1SKSA9PT0gTC5cbnZhciBMID0gLTE7XG52YXIgUiA9IDE7XG5cbmZ1bmN0aW9uIHByYXlEaXJlY3Rpb24oZGlyKSB7XG4gIHByYXkoJ2EgZGlyZWN0aW9uIHdhcyBwYXNzZWQnLCBkaXIgPT09IEwgfHwgZGlyID09PSBSKTtcbn1cblxuLyoqXG4gKiBUaW55IGV4dGVuc2lvbiBvZiBqUXVlcnkgYWRkaW5nIGRpcmVjdGlvbmFsaXplZCBET00gbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKlxuICogRnVubnkgaG93IFBqcyB2MyBhbG1vc3QganVzdCB3b3JrcyB3aXRoIGBqUXVlcnkuZm4uaW5pdGAuXG4gKlxuICogalF1ZXJ5IGZlYXR1cmVzIHRoYXQgZG9uJ3Qgd29yayBvbiAkOlxuICogICAtIGpRdWVyeS4qLCBsaWtlIGpRdWVyeS5hamF4LCBvYnZpb3VzbHkgKFBqcyBkb2Vzbid0IGFuZCBzaG91bGRuJ3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5IGNvbnN0cnVjdG9yIHByb3BlcnRpZXMpXG4gKlxuICogICAtIGpRdWVyeShmdW5jdGlvbiksIHRoZSBzaG9ydGN1dCBmb3IgYGpRdWVyeShkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24pYCxcbiAqICAgICBiZWNhdXNlIGBqUXVlcnkuZm4uaW5pdGAgaXMgaWRpb3N5bmNyYXRpYyBhbmQgUGpzIGRvaW5nLCBlc3NlbnRpYWxseSxcbiAqICAgICBgalF1ZXJ5LmZuLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKWAgaXNuJ3QgcXVpdGUgcmlnaHQsIHlvdSBuZWVkOlxuICpcbiAqICAgICAgIF8uaW5pdCA9IGZ1bmN0aW9uKHMsIGMpIHsgalF1ZXJ5LmZuLmluaXQuY2FsbCh0aGlzLCBzLCBjLCAkKGRvY3VtZW50KSk7IH07XG4gKlxuICogICAgIGlmIHlvdSBhY3R1YWxseSBnaXZlIGEgc2hpdCAocmVhbGx5LCBkb24ndCBib3RoZXIpLFxuICogICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzEuNy4yL3NyYy9jb3JlLmpzI0w4ODlcbiAqXG4gKiAgIC0galF1ZXJ5KHNlbGVjdG9yKSwgYmVjYXVzZSBqUXVlcnkgdHJhbnNsYXRlcyB0aGF0IHRvXG4gKiAgICAgYGpRdWVyeShkb2N1bWVudCkuZmluZChzZWxlY3RvcilgLCBidXQgUGpzIGRvZXNuJ3QgKHNob3VsZCBpdD8pIGxldFxuICogICAgIHlvdSBvdmVycmlkZSB0aGUgcmVzdWx0IG9mIGEgY29uc3RydWN0b3IgY2FsbFxuICogICAgICAgKyBub3RlIHRoYXQgYmVjYXVzZSBvZiB0aGUgalF1ZXJ5KGRvY3VtZW50KSBzaG9ydGN1dC1uZXNzLCB0aGVyZSdzIGFsc29cbiAqICAgICAgICAgdGhlIDNyZC1hcmd1bWVudC1uZWVkcy10by1iZS1gJChkb2N1bWVudClgIHRoaW5nIGFib3ZlLCBidXQgdGhlIGZpeFxuICogICAgICAgICBmb3IgdGhhdCAoYXMgY2FuIGJlIHNlZW4gYWJvdmUpIGlzIHJlYWxseSBlYXN5LiBUaGlzIHByb2JsZW0gcmVxdWlyZXNcbiAqICAgICAgICAgYSB3YXkgbW9yZSBpbnRydXNpdmUgZml4XG4gKlxuICogQW5kIHRoYXQncyBpdCEgRXZlcnl0aGluZyBlbHNlIGp1c3QgbWFnaWNhbGx5IHdvcmtzIGJlY2F1c2UgalF1ZXJ5IGludGVybmFsbHlcbiAqIHVzZXMgYHRoaXMuY29uc3RydWN0b3IoKWAgZXZlcnl3aGVyZSAoaGVuY2UgY2FsbGluZyBgJGApLCBidXQgbmV2ZXIgZXZlciBkb2VzXG4gKiBgdGhpcy5jb25zdHJ1Y3Rvci5maW5kYCBvciBhbnl0aGluZyBsaWtlIHRoYXQsIGFsd2F5cyBkb2luZyBgalF1ZXJ5LmZpbmRgLlxuICovXG52YXIgJCA9IFAoalF1ZXJ5LCBmdW5jdGlvbihfKSB7XG4gIF8uaW5zRGlyT2YgPSBmdW5jdGlvbihkaXIsIGVsKSB7XG4gICAgcmV0dXJuIGRpciA9PT0gTCA/XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShlbC5maXJzdCgpKSA6IHRoaXMuaW5zZXJ0QWZ0ZXIoZWwubGFzdCgpKTtcbiAgfTtcbiAgXy5pbnNBdERpckVuZCA9IGZ1bmN0aW9uKGRpciwgZWwpIHtcbiAgICByZXR1cm4gZGlyID09PSBMID8gdGhpcy5wcmVwZW5kVG8oZWwpIDogdGhpcy5hcHBlbmRUbyhlbCk7XG4gIH07XG59KTtcblxudmFyIFBvaW50ID0gUChmdW5jdGlvbihfKSB7XG4gIF8ucGFyZW50ID0gMDtcbiAgX1tMXSA9IDA7XG4gIF9bUl0gPSAwO1xuXG4gIF8uaW5pdCA9IGZ1bmN0aW9uKHBhcmVudCwgbGVmdHdhcmQsIHJpZ2h0d2FyZCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXNbTF0gPSBsZWZ0d2FyZDtcbiAgICB0aGlzW1JdID0gcmlnaHR3YXJkO1xuICB9O1xuXG4gIHRoaXMuY29weSA9IGZ1bmN0aW9uKHB0KSB7XG4gICAgcmV0dXJuIFBvaW50KHB0LnBhcmVudCwgcHRbTF0sIHB0W1JdKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIE1hdGhRdWlsbCB2aXJ0dWFsLURPTSB0cmVlLW5vZGUgYWJzdHJhY3QgYmFzZSBjbGFzc1xuICovXG52YXIgTm9kZSA9IFAoZnVuY3Rpb24oXykge1xuICBfW0xdID0gMDtcbiAgX1tSXSA9IDBcbiAgXy5wYXJlbnQgPSAwO1xuXG4gIHZhciBpZCA9IDA7XG4gIGZ1bmN0aW9uIHVuaXF1ZU5vZGVJZCgpIHsgcmV0dXJuIGlkICs9IDE7IH1cbiAgdGhpcy5ieUlkID0ge307XG5cbiAgXy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pZCA9IHVuaXF1ZU5vZGVJZCgpO1xuICAgIE5vZGUuYnlJZFt0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICB0aGlzLmVuZHMgPSB7fTtcbiAgICB0aGlzLmVuZHNbTF0gPSAwO1xuICAgIHRoaXMuZW5kc1tSXSA9IDA7XG4gIH07XG5cbiAgXy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IGRlbGV0ZSBOb2RlLmJ5SWRbdGhpcy5pZF07IH07XG5cbiAgXy50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3t7IE1hdGhRdWlsbCBOb2RlICMnK3RoaXMuaWQrJyB9fSc7IH07XG5cbiAgXy5qUSA9ICQoKTtcbiAgXy5qUWFkZCA9IGZ1bmN0aW9uKGpRKSB7IHJldHVybiB0aGlzLmpRID0gdGhpcy5qUS5hZGQoalEpOyB9O1xuICBfLmpRaXplID0gZnVuY3Rpb24oalEpIHtcbiAgICAvLyBqUXVlcnktaWZpZXMgdGhpcy5odG1sKCkgYW5kIGxpbmtzIHVwIHRoZSAualEgb2YgYWxsIGNvcnJlc3BvbmRpbmcgTm9kZXNcbiAgICB2YXIgalEgPSAkKGpRIHx8IHRoaXMuaHRtbCgpKTtcblxuICAgIGZ1bmN0aW9uIGpRYWRkKGVsKSB7XG4gICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBjbWRJZCA9IGVsLmdldEF0dHJpYnV0ZSgnbWF0aHF1aWxsLWNvbW1hbmQtaWQnKTtcbiAgICAgICAgdmFyIGJsb2NrSWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ21hdGhxdWlsbC1ibG9jay1pZCcpO1xuICAgICAgICBpZiAoY21kSWQpIE5vZGUuYnlJZFtjbWRJZF0ualFhZGQoZWwpO1xuICAgICAgICBpZiAoYmxvY2tJZCkgTm9kZS5ieUlkW2Jsb2NrSWRdLmpRYWRkKGVsKTtcbiAgICAgIH1cbiAgICAgIGZvciAoZWwgPSBlbC5maXJzdENoaWxkOyBlbDsgZWwgPSBlbC5uZXh0U2libGluZykge1xuICAgICAgICBqUWFkZChlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqUS5sZW5ndGg7IGkgKz0gMSkgalFhZGQoalFbaV0pO1xuICAgIHJldHVybiBqUTtcbiAgfTtcblxuICBfLmNyZWF0ZURpciA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBub2RlID0gdGhpcztcbiAgICBub2RlLmpRaXplKCk7XG4gICAgbm9kZS5qUS5pbnNEaXJPZihkaXIsIGN1cnNvci5qUSk7XG4gICAgY3Vyc29yW2Rpcl0gPSBub2RlLmFkb3B0KGN1cnNvci5wYXJlbnQsIGN1cnNvcltMXSwgY3Vyc29yW1JdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihlbCkgeyByZXR1cm4gdGhpcy5jcmVhdGVEaXIoTCwgZWwpOyB9O1xuXG4gIF8uc2VsZWN0Q2hpbGRyZW4gPSBmdW5jdGlvbihsZWZ0RW5kLCByaWdodEVuZCkge1xuICAgIHJldHVybiBTZWxlY3Rpb24obGVmdEVuZCwgcmlnaHRFbmQpO1xuICB9O1xuXG4gIF8uYnViYmxlID0gaXRlcmF0b3IoZnVuY3Rpb24oeWllbGRfKSB7XG4gICAgZm9yICh2YXIgYW5jZXN0b3IgPSB0aGlzOyBhbmNlc3RvcjsgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB5aWVsZF8oYW5jZXN0b3IpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBfLnBvc3RPcmRlciA9IGl0ZXJhdG9yKGZ1bmN0aW9uKHlpZWxkXykge1xuICAgIChmdW5jdGlvbiByZWN1cnNlKGRlc2NlbmRhbnQpIHtcbiAgICAgIGRlc2NlbmRhbnQuZWFjaENoaWxkKHJlY3Vyc2UpO1xuICAgICAgeWllbGRfKGRlc2NlbmRhbnQpO1xuICAgIH0pKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNbTF0gPT09IDAgJiYgdGhpcy5lbmRzW1JdID09PSAwO1xuICB9O1xuXG4gIF8uY2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnJhZ21lbnQodGhpcy5lbmRzW0xdLCB0aGlzLmVuZHNbUl0pO1xuICB9O1xuXG4gIF8uZWFjaENoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmVhY2guYXBwbHkoY2hpbGRyZW4sIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXy5mb2xkQ2hpbGRyZW4gPSBmdW5jdGlvbihmb2xkLCBmbikge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuKCkuZm9sZChmb2xkLCBmbik7XG4gIH07XG5cbiAgXy53aXRoRGlyQWRvcHQgPSBmdW5jdGlvbihkaXIsIHBhcmVudCwgd2l0aERpciwgb3BwRGlyKSB7XG4gICAgRnJhZ21lbnQodGhpcywgdGhpcykud2l0aERpckFkb3B0KGRpciwgcGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF8uYWRvcHQgPSBmdW5jdGlvbihwYXJlbnQsIGxlZnR3YXJkLCByaWdodHdhcmQpIHtcbiAgICBGcmFnbWVudCh0aGlzLCB0aGlzKS5hZG9wdChwYXJlbnQsIGxlZnR3YXJkLCByaWdodHdhcmQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF8uZGlzb3duID0gZnVuY3Rpb24oKSB7XG4gICAgRnJhZ21lbnQodGhpcywgdGhpcykuZGlzb3duKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRLnJlbW92ZSgpO1xuICAgIHRoaXMucG9zdE9yZGVyKCdkaXNwb3NlJyk7XG4gICAgcmV0dXJuIHRoaXMuZGlzb3duKCk7XG4gIH07XG59KTtcblxuZnVuY3Rpb24gcHJheVdlbGxGb3JtZWQocGFyZW50LCBsZWZ0d2FyZCwgcmlnaHR3YXJkKSB7XG4gIHByYXkoJ2EgcGFyZW50IGlzIGFsd2F5cyBwcmVzZW50JywgcGFyZW50KTtcbiAgcHJheSgnbGVmdHdhcmQgaXMgcHJvcGVybHkgc2V0IHVwJywgKGZ1bmN0aW9uKCkge1xuICAgIC8vIGVpdGhlciBpdCdzIGVtcHR5IGFuZCBgcmlnaHR3YXJkYCBpcyB0aGUgbGVmdCBlbmQgY2hpbGQgKHBvc3NpYmx5IGVtcHR5KVxuICAgIGlmICghbGVmdHdhcmQpIHJldHVybiBwYXJlbnQuZW5kc1tMXSA9PT0gcmlnaHR3YXJkO1xuXG4gICAgLy8gb3IgaXQncyB0aGVyZSBhbmQgaXRzIFtSXSBhbmQgLnBhcmVudCBhcmUgcHJvcGVybHkgc2V0IHVwXG4gICAgcmV0dXJuIGxlZnR3YXJkW1JdID09PSByaWdodHdhcmQgJiYgbGVmdHdhcmQucGFyZW50ID09PSBwYXJlbnQ7XG4gIH0pKCkpO1xuXG4gIHByYXkoJ3JpZ2h0d2FyZCBpcyBwcm9wZXJseSBzZXQgdXAnLCAoZnVuY3Rpb24oKSB7XG4gICAgLy8gZWl0aGVyIGl0J3MgZW1wdHkgYW5kIGBsZWZ0d2FyZGAgaXMgdGhlIHJpZ2h0IGVuZCBjaGlsZCAocG9zc2libHkgZW1wdHkpXG4gICAgaWYgKCFyaWdodHdhcmQpIHJldHVybiBwYXJlbnQuZW5kc1tSXSA9PT0gbGVmdHdhcmQ7XG5cbiAgICAvLyBvciBpdCdzIHRoZXJlIGFuZCBpdHMgW0xdIGFuZCAucGFyZW50IGFyZSBwcm9wZXJseSBzZXQgdXBcbiAgICByZXR1cm4gcmlnaHR3YXJkW0xdID09PSBsZWZ0d2FyZCAmJiByaWdodHdhcmQucGFyZW50ID09PSBwYXJlbnQ7XG4gIH0pKCkpO1xufVxuXG5cbi8qKlxuICogQW4gZW50aXR5IG91dHNpZGUgdGhlIHZpcnR1YWwgdHJlZSB3aXRoIG9uZS13YXkgcG9pbnRlcnMgKHNvIGl0J3Mgb25seSBhXG4gKiBcInZpZXdcIiBvZiBwYXJ0IG9mIHRoZSB0cmVlLCBub3QgYW4gYWN0dWFsIG5vZGUvZW50aXR5IGluIHRoZSB0cmVlKSB0aGF0XG4gKiBkZWxpbWl0cyBhIGRvdWJseS1saW5rZWQgbGlzdCBvZiBzaWJsaW5nIG5vZGVzLlxuICogSXQncyBsaWtlIGEgZmFuZmljIGxvdmUtY2hpbGQgYmV0d2VlbiBIVE1MIERPTSBEb2N1bWVudEZyYWdtZW50IGFuZCB0aGUgUmFuZ2VcbiAqIGNsYXNzZXM6IGxpa2UgRG9jdW1lbnRGcmFnbWVudCwgaXRzIGNvbnRlbnRzIG11c3QgYmUgc2libGluZyBub2Rlc1xuICogKHVubGlrZSBSYW5nZSwgd2hvc2UgY29udGVudHMgYXJlIGFyYml0cmFyeSBjb250aWd1b3VzIHBpZWNlcyBvZiBzdWJ0cmVlcyksXG4gKiBidXQgbGlrZSBSYW5nZSwgaXQgaGFzIG9ubHkgb25lLXdheSBwb2ludGVycyB0byBpdHMgY29udGVudHMsIGl0cyBjb250ZW50c1xuICogaGF2ZSBubyByZWZlcmVuY2UgdG8gaXQgYW5kIGluIGZhY3QgbWF5IHN0aWxsIGJlIGluIHRoZSB2aXNpYmxlIHRyZWUgKHVubGlrZVxuICogRG9jdW1lbnRGcmFnbWVudCwgd2hvc2UgY29udGVudHMgbXVzdCBiZSBkZXRhY2hlZCBmcm9tIHRoZSB2aXNpYmxlIHRyZWVcbiAqIGFuZCBoYXZlIHRoZWlyICdwYXJlbnQnIHBvaW50ZXJzIHNldCB0byB0aGUgRG9jdW1lbnRGcmFnbWVudCkuXG4gKi9cbnZhciBGcmFnbWVudCA9IFAoZnVuY3Rpb24oXykge1xuICBfLmluaXQgPSBmdW5jdGlvbih3aXRoRGlyLCBvcHBEaXIsIGRpcikge1xuICAgIGlmIChkaXIgPT09IHVuZGVmaW5lZCkgZGlyID0gTDtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG5cbiAgICBwcmF5KCdubyBoYWxmLWVtcHR5IGZyYWdtZW50cycsICF3aXRoRGlyID09PSAhb3BwRGlyKTtcblxuICAgIHRoaXMuZW5kcyA9IHt9O1xuXG4gICAgaWYgKCF3aXRoRGlyKSByZXR1cm47XG5cbiAgICBwcmF5KCd3aXRoRGlyIGlzIHBhc3NlZCB0byBGcmFnbWVudCcsIHdpdGhEaXIgaW5zdGFuY2VvZiBOb2RlKTtcbiAgICBwcmF5KCdvcHBEaXIgaXMgcGFzc2VkIHRvIEZyYWdtZW50Jywgb3BwRGlyIGluc3RhbmNlb2YgTm9kZSk7XG4gICAgcHJheSgnd2l0aERpciBhbmQgb3BwRGlyIGhhdmUgdGhlIHNhbWUgcGFyZW50JyxcbiAgICAgICAgIHdpdGhEaXIucGFyZW50ID09PSBvcHBEaXIucGFyZW50KTtcblxuICAgIHRoaXMuZW5kc1tkaXJdID0gd2l0aERpcjtcbiAgICB0aGlzLmVuZHNbLWRpcl0gPSBvcHBEaXI7XG5cbiAgICAvLyBUbyBidWlsZCB0aGUganF1ZXJ5IGNvbGxlY3Rpb24gZm9yIGEgZnJhZ21lbnQsIGFjY3VtdWxhdGUgZWxlbWVudHNcbiAgICAvLyBpbnRvIGFuIGFycmF5IGFuZCB0aGVuIGNhbGwgalEuYWRkIG9uY2Ugb24gdGhlIHJlc3VsdC4galEuYWRkIHNvcnRzIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gYWNjb3JkaW5nIHRvIGRvY3VtZW50IG9yZGVyIGVhY2ggdGltZSBpdCBpcyBjYWxsZWQsIHNvXG4gICAgLy8gYnVpbGRpbmcgYSBjb2xsZWN0aW9uIGJ5IGZvbGRpbmcgalEuYWRkIGRpcmVjdGx5IHRha2VzIG1vcmUgdGhhblxuICAgIC8vIHF1YWRyYXRpYyB0aW1lIGluIHRoZSBudW1iZXIgb2YgZWxlbWVudHMuXG4gICAgLy9cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMS40L3NyYy90cmF2ZXJzaW5nLmpzI0wxMTJcbiAgICB2YXIgYWNjdW0gPSB0aGlzLmZvbGQoW10sIGZ1bmN0aW9uIChhY2N1bSwgZWwpIHtcbiAgICAgIGFjY3VtLnB1c2guYXBwbHkoYWNjdW0sIGVsLmpRLmdldCgpKTtcbiAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9KTtcblxuICAgIHRoaXMualEgPSB0aGlzLmpRLmFkZChhY2N1bSk7XG4gIH07XG4gIF8ualEgPSAkKCk7XG5cbiAgLy8gbGlrZSBDdXJzb3I6OndpdGhEaXJJbnNlcnRBdChkaXIsIHBhcmVudCwgd2l0aERpciwgb3BwRGlyKVxuICBfLndpdGhEaXJBZG9wdCA9IGZ1bmN0aW9uKGRpciwgcGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpIHtcbiAgICByZXR1cm4gKGRpciA9PT0gTCA/IHRoaXMuYWRvcHQocGFyZW50LCB3aXRoRGlyLCBvcHBEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmFkb3B0KHBhcmVudCwgb3BwRGlyLCB3aXRoRGlyKSk7XG4gIH07XG4gIF8uYWRvcHQgPSBmdW5jdGlvbihwYXJlbnQsIGxlZnR3YXJkLCByaWdodHdhcmQpIHtcbiAgICBwcmF5V2VsbEZvcm1lZChwYXJlbnQsIGxlZnR3YXJkLCByaWdodHdhcmQpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZGlzb3duZWQgPSBmYWxzZTtcblxuICAgIHZhciBsZWZ0RW5kID0gc2VsZi5lbmRzW0xdO1xuICAgIGlmICghbGVmdEVuZCkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgcmlnaHRFbmQgPSBzZWxmLmVuZHNbUl07XG5cbiAgICBpZiAobGVmdHdhcmQpIHtcbiAgICAgIC8vIE5COiB0aGlzIGlzIGhhbmRsZWQgaW4gdGhlIDo6ZWFjaCgpIGJsb2NrXG4gICAgICAvLyBsZWZ0d2FyZFtSXSA9IGxlZnRFbmRcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmVuZHNbTF0gPSBsZWZ0RW5kO1xuICAgIH1cblxuICAgIGlmIChyaWdodHdhcmQpIHtcbiAgICAgIHJpZ2h0d2FyZFtMXSA9IHJpZ2h0RW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZW5kc1tSXSA9IHJpZ2h0RW5kO1xuICAgIH1cblxuICAgIHNlbGYuZW5kc1tSXVtSXSA9IHJpZ2h0d2FyZDtcblxuICAgIHNlbGYuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgZWxbTF0gPSBsZWZ0d2FyZDtcbiAgICAgIGVsLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIGlmIChsZWZ0d2FyZCkgbGVmdHdhcmRbUl0gPSBlbDtcblxuICAgICAgbGVmdHdhcmQgPSBlbDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIF8uZGlzb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsZWZ0RW5kID0gc2VsZi5lbmRzW0xdO1xuXG4gICAgLy8gZ3VhcmQgZm9yIGVtcHR5IGFuZCBhbHJlYWR5LWRpc293bmVkIGZyYWdtZW50c1xuICAgIGlmICghbGVmdEVuZCB8fCBzZWxmLmRpc293bmVkKSByZXR1cm4gc2VsZjtcblxuICAgIHNlbGYuZGlzb3duZWQgPSB0cnVlO1xuXG4gICAgdmFyIHJpZ2h0RW5kID0gc2VsZi5lbmRzW1JdXG4gICAgdmFyIHBhcmVudCA9IGxlZnRFbmQucGFyZW50O1xuXG4gICAgcHJheVdlbGxGb3JtZWQocGFyZW50LCBsZWZ0RW5kW0xdLCBsZWZ0RW5kKTtcbiAgICBwcmF5V2VsbEZvcm1lZChwYXJlbnQsIHJpZ2h0RW5kLCByaWdodEVuZFtSXSk7XG5cbiAgICBpZiAobGVmdEVuZFtMXSkge1xuICAgICAgbGVmdEVuZFtMXVtSXSA9IHJpZ2h0RW5kW1JdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZW5kc1tMXSA9IHJpZ2h0RW5kW1JdO1xuICAgIH1cblxuICAgIGlmIChyaWdodEVuZFtSXSkge1xuICAgICAgcmlnaHRFbmRbUl1bTF0gPSBsZWZ0RW5kW0xdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuZW5kc1tSXSA9IGxlZnRFbmRbTF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgXy5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRLnJlbW92ZSgpO1xuICAgIHRoaXMuZWFjaCgncG9zdE9yZGVyJywgJ2Rpc3Bvc2UnKTtcbiAgICByZXR1cm4gdGhpcy5kaXNvd24oKTtcbiAgfTtcblxuICBfLmVhY2ggPSBpdGVyYXRvcihmdW5jdGlvbih5aWVsZF8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gc2VsZi5lbmRzW0xdO1xuICAgIGlmICghZWwpIHJldHVybiBzZWxmO1xuXG4gICAgZm9yICg7IGVsICE9PSBzZWxmLmVuZHNbUl1bUl07IGVsID0gZWxbUl0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB5aWVsZF8oZWwpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9KTtcblxuICBfLmZvbGQgPSBmdW5jdGlvbihmb2xkLCBmbikge1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgZm9sZCA9IGZuLmNhbGwodGhpcywgZm9sZCwgZWwpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvbGQ7XG4gIH07XG59KTtcblxuXG4vKipcbiAqIFJlZ2lzdHJ5IG9mIExhVGVYIGNvbW1hbmRzIGFuZCBjb21tYW5kcyBjcmVhdGVkIHdoZW4gdHlwaW5nXG4gKiBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKlxuICogKENvbW1hbmRzIGFyZSBhbGwgc3ViY2xhc3NlcyBvZiBOb2RlLilcbiAqL1xudmFyIExhdGV4Q21kcyA9IHt9LCBDaGFyQ21kcyA9IHt9O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDdXJzb3IgYW5kIFNlbGVjdGlvbiBcInNpbmdsZXRvblwiIGNsYXNzZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiBUaGUgbWFpbiB0aGluZyB0aGF0IG1hbmlwdWxhdGVzIHRoZSBNYXRoIERPTS4gTWFrZXMgc3VyZSB0byBtYW5pcHVsYXRlIHRoZVxuSFRNTCBET00gdG8gbWF0Y2guICovXG5cbi8qIFNvcnQgb2Ygc2luZ2xldG9ucywgc2luY2UgdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIHBlciBlZGl0YWJsZSBtYXRoXG50ZXh0Ym94LCBidXQgYW55IG9uZSBIVE1MIGRvY3VtZW50IGNhbiBjb250YWluIG1hbnkgc3VjaCB0ZXh0Ym94ZXMsIHNvIGFueSBvbmVcbkpTIGVudmlyb25tZW50IGNvdWxkIGFjdHVhbGx5IGNvbnRhaW4gbWFueSBpbnN0YW5jZXMuICovXG5cbi8vQSBmYWtlIGN1cnNvciBpbiB0aGUgZmFrZSB0ZXh0Ym94IHRoYXQgdGhlIG1hdGggaXMgcmVuZGVyZWQgaW4uXG52YXIgQ3Vyc29yID0gUChQb2ludCwgZnVuY3Rpb24oXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihpbml0UGFyZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBpbml0UGFyZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB2YXIgalEgPSB0aGlzLmpRID0gdGhpcy5falEgPSAkKCc8c3BhbiBjbGFzcz1cIm1xLWN1cnNvclwiPiYjODIwMzs8L3NwYW4+Jyk7XG4gICAgLy9jbG9zdXJlZCBmb3Igc2V0SW50ZXJ2YWxcbiAgICB0aGlzLmJsaW5rID0gZnVuY3Rpb24oKXsgalEudG9nZ2xlQ2xhc3MoJ21xLWJsaW5rJyk7IH07XG5cbiAgICB0aGlzLnVwRG93bkNhY2hlID0ge307XG4gIH07XG5cbiAgXy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5qUSA9IHRoaXMuX2pRLnJlbW92ZUNsYXNzKCdtcS1ibGluaycpO1xuICAgIGlmICgnaW50ZXJ2YWxJZCcgaW4gdGhpcykgLy9hbHJlYWR5IHdhcyBzaG93biwganVzdCByZXN0YXJ0IGludGVydmFsXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgZWxzZSB7IC8vd2FzIGhpZGRlbiBhbmQgZGV0YWNoZWQsIGluc2VydCB0aGlzLmpRIGJhY2sgaW50byBIVE1MIERPTVxuICAgICAgaWYgKHRoaXNbUl0pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuc2VsZWN0aW9uLmVuZHNbTF1bTF0gPT09IHRoaXNbTF0pXG4gICAgICAgICAgdGhpcy5qUS5pbnNlcnRCZWZvcmUodGhpcy5zZWxlY3Rpb24ualEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5qUS5pbnNlcnRCZWZvcmUodGhpc1tSXS5qUS5maXJzdCgpKTtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5qUS5hcHBlbmRUbyh0aGlzLnBhcmVudC5qUSk7XG4gICAgICB0aGlzLnBhcmVudC5mb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLmJsaW5rLCA1MDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2ludGVydmFsSWQnIGluIHRoaXMpXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgZGVsZXRlIHRoaXMuaW50ZXJ2YWxJZDtcbiAgICB0aGlzLmpRLmRldGFjaCgpO1xuICAgIHRoaXMualEgPSAkKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXy53aXRoRGlySW5zZXJ0QXQgPSBmdW5jdGlvbihkaXIsIHBhcmVudCwgd2l0aERpciwgb3BwRGlyKSB7XG4gICAgdmFyIG9sZFBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXNbZGlyXSA9IHdpdGhEaXI7XG4gICAgdGhpc1stZGlyXSA9IG9wcERpcjtcbiAgICAvLyBieSBjb250cmFjdCwgLmJsdXIoKSBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGhhcyBiZWVuIHNhaWQgYW5kIGRvbmVcbiAgICAvLyBhbmQgdGhlIGN1cnNvciBoYXMgYWN0dWFsbHkgYmVlbiBtb3ZlZFxuICAgIC8vIEZJWE1FIHBhc3MgY3Vyc29yIHRvIC5ibHVyKCkgc28gdGV4dCBjYW4gZml4IGN1cnNvciBwb2ludGVycyB3aGVuIHJlbW92aW5nIGl0c2VsZlxuICAgIGlmIChvbGRQYXJlbnQgIT09IHBhcmVudCAmJiBvbGRQYXJlbnQuYmx1cikgb2xkUGFyZW50LmJsdXIodGhpcyk7XG4gIH07XG4gIF8uaW5zRGlyT2YgPSBmdW5jdGlvbihkaXIsIGVsKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHRoaXMualEuaW5zRGlyT2YoZGlyLCBlbC5qUSk7XG4gICAgdGhpcy53aXRoRGlySW5zZXJ0QXQoZGlyLCBlbC5wYXJlbnQsIGVsW2Rpcl0sIGVsKTtcbiAgICB0aGlzLnBhcmVudC5qUS5hZGRDbGFzcygnbXEtaGFzQ3Vyc29yJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uaW5zTGVmdE9mID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHRoaXMuaW5zRGlyT2YoTCwgZWwpOyB9O1xuICBfLmluc1JpZ2h0T2YgPSBmdW5jdGlvbihlbCkgeyByZXR1cm4gdGhpcy5pbnNEaXJPZihSLCBlbCk7IH07XG5cbiAgXy5pbnNBdERpckVuZCA9IGZ1bmN0aW9uKGRpciwgZWwpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG4gICAgdGhpcy5qUS5pbnNBdERpckVuZChkaXIsIGVsLmpRKTtcbiAgICB0aGlzLndpdGhEaXJJbnNlcnRBdChkaXIsIGVsLCAwLCBlbC5lbmRzW2Rpcl0pO1xuICAgIGVsLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uaW5zQXRMZWZ0RW5kID0gZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHRoaXMuaW5zQXREaXJFbmQoTCwgZWwpOyB9O1xuICBfLmluc0F0UmlnaHRFbmQgPSBmdW5jdGlvbihlbCkgeyByZXR1cm4gdGhpcy5pbnNBdERpckVuZChSLCBlbCk7IH07XG5cbiAgLyoqXG4gICAqIGp1bXAgdXAgb3IgZG93biBmcm9tIG9uZSBibG9jayBOb2RlIHRvIGFub3RoZXI6XG4gICAqIC0gY2FjaGUgdGhlIGN1cnJlbnQgUG9pbnQgaW4gdGhlIG5vZGUgd2UncmUganVtcGluZyBmcm9tXG4gICAqIC0gY2hlY2sgaWYgdGhlcmUncyBhIFBvaW50IGluIGl0IGNhY2hlZCBmb3IgdGhlIG5vZGUgd2UncmUganVtcGluZyB0b1xuICAgKiAgICsgaWYgc28gcHV0IHRoZSBjdXJzb3IgdGhlcmUsXG4gICAqICAgKyBpZiBub3Qgc2VlayBhIHBvc2l0aW9uIGluIHRoZSBub2RlIHRoYXQgaXMgaG9yaXpvbnRhbGx5IGNsb3Nlc3QgdG9cbiAgICogICAgIHRoZSBjdXJzb3IncyBjdXJyZW50IHBvc2l0aW9uXG4gICAqL1xuICBfLmp1bXBVcERvd24gPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnVwRG93bkNhY2hlW2Zyb20uaWRdID0gUG9pbnQuY29weShzZWxmKTtcbiAgICB2YXIgY2FjaGVkID0gc2VsZi51cERvd25DYWNoZVt0by5pZF07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgY2FjaGVkW1JdID8gc2VsZi5pbnNMZWZ0T2YoY2FjaGVkW1JdKSA6IHNlbGYuaW5zQXRSaWdodEVuZChjYWNoZWQucGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFnZVggPSBzZWxmLm9mZnNldCgpLmxlZnQ7XG4gICAgICB0by5zZWVrKHBhZ2VYLCBzZWxmKTtcbiAgICB9XG4gIH07XG4gIF8ub2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy9pbiBPcGVyYSAxMS42MiwgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGFuZCBoZW5jZSBqUXVlcnk6Om9mZnNldCgpXG4gICAgLy9yZXR1cm5zIGFsbCAwJ3Mgb24gaW5saW5lIGVsZW1lbnRzIHdpdGggbmVnYXRpdmUgbWFyZ2luLXJpZ2h0IChsaWtlXG4gICAgLy90aGUgY3Vyc29yKSBhdCB0aGUgZW5kIG9mIHRoZWlyIHBhcmVudCwgc28gdGVtcG9yYXJpbHkgcmVtb3ZlIHRoZVxuICAgIC8vbmVnYXRpdmUgbWFyZ2luLXJpZ2h0IHdoZW4gY2FsbGluZyBqUXVlcnk6Om9mZnNldCgpXG4gICAgLy9PcGVyYSBidWcgRFNLLTM2MDA0M1xuICAgIC8vaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTE1MjNcbiAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzE3XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBvZmZzZXQgPSBzZWxmLmpRLnJlbW92ZUNsYXNzKCdtcS1jdXJzb3InKS5vZmZzZXQoKTtcbiAgICBzZWxmLmpRLmFkZENsYXNzKCdtcS1jdXJzb3InKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIF8udW53cmFwR3JhbXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3JhbXAgPSB0aGlzLnBhcmVudC5wYXJlbnQ7XG4gICAgdmFyIGdyZWF0Z3JhbXAgPSBncmFtcC5wYXJlbnQ7XG4gICAgdmFyIHJpZ2h0d2FyZCA9IGdyYW1wW1JdO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzO1xuXG4gICAgdmFyIGxlZnR3YXJkID0gZ3JhbXBbTF07XG4gICAgZ3JhbXAuZGlzb3duKCkuZWFjaENoaWxkKGZ1bmN0aW9uKHVuY2xlKSB7XG4gICAgICBpZiAodW5jbGUuaXNFbXB0eSgpKSByZXR1cm47XG5cbiAgICAgIHVuY2xlLmNoaWxkcmVuKClcbiAgICAgICAgLmFkb3B0KGdyZWF0Z3JhbXAsIGxlZnR3YXJkLCByaWdodHdhcmQpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKGNvdXNpbikge1xuICAgICAgICAgIGNvdXNpbi5qUS5pbnNlcnRCZWZvcmUoZ3JhbXAualEuZmlyc3QoKSk7XG4gICAgICAgIH0pXG4gICAgICA7XG5cbiAgICAgIGxlZnR3YXJkID0gdW5jbGUuZW5kc1tSXTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpc1tSXSkgeyAvL3RoZW4gZmluZCBzb21ldGhpbmcgdG8gYmUgcmlnaHR3YXJkIHRvIGluc0xlZnRPZlxuICAgICAgaWYgKHRoaXNbTF0pXG4gICAgICAgIHRoaXNbUl0gPSB0aGlzW0xdW1JdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICghdGhpc1tSXSkge1xuICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5wYXJlbnRbUl07XG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpc1tSXSA9IHRoaXMucGFyZW50LmVuZHNbTF07XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW1JdID0gZ3JhbXBbUl07XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGdyZWF0Z3JhbXA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXNbUl0pXG4gICAgICB0aGlzLmluc0xlZnRPZih0aGlzW1JdKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmluc0F0UmlnaHRFbmQoZ3JlYXRncmFtcCk7XG5cbiAgICBncmFtcC5qUS5yZW1vdmUoKTtcblxuICAgIGlmIChncmFtcFtMXS5zaWJsaW5nRGVsZXRlZCkgZ3JhbXBbTF0uc2libGluZ0RlbGV0ZWQoY3Vyc29yLm9wdGlvbnMsIFIpO1xuICAgIGlmIChncmFtcFtSXS5zaWJsaW5nRGVsZXRlZCkgZ3JhbXBbUl0uc2libGluZ0RlbGV0ZWQoY3Vyc29yLm9wdGlvbnMsIEwpO1xuICB9O1xuICBfLnN0YXJ0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFudGljdXJzb3IgPSB0aGlzLmFudGljdXJzb3IgPSBQb2ludC5jb3B5KHRoaXMpO1xuICAgIHZhciBhbmNlc3RvcnMgPSBhbnRpY3Vyc29yLmFuY2VzdG9ycyA9IHt9OyAvLyBhIG1hcCBmcm9tIGVhY2ggYW5jZXN0b3Igb2ZcbiAgICAgIC8vIHRoZSBhbnRpY3Vyc29yLCB0byBpdHMgY2hpbGQgdGhhdCBpcyBhbHNvIGFuIGFuY2VzdG9yOyBpbiBvdGhlciB3b3JkcyxcbiAgICAgIC8vIHRoZSBhbnRpY3Vyc29yJ3MgYW5jZXN0b3IgY2hhaW4gaW4gcmV2ZXJzZSBvcmRlclxuICAgIGZvciAodmFyIGFuY2VzdG9yID0gYW50aWN1cnNvcjsgYW5jZXN0b3IucGFyZW50OyBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCkge1xuICAgICAgYW5jZXN0b3JzW2FuY2VzdG9yLnBhcmVudC5pZF0gPSBhbmNlc3RvcjtcbiAgICB9XG4gIH07XG4gIF8uZW5kU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMuYW50aWN1cnNvcjtcbiAgfTtcbiAgXy5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYW50aWN1cnNvciA9IHRoaXMuYW50aWN1cnNvcjtcbiAgICBpZiAodGhpc1tMXSA9PT0gYW50aWN1cnNvcltMXSAmJiB0aGlzLnBhcmVudCA9PT0gYW50aWN1cnNvci5wYXJlbnQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEZpbmQgdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3IgKGBsY2FgKSwgYW5kIHRoZSBhbmNlc3RvciBvZiB0aGUgY3Vyc29yXG4gICAgLy8gd2hvc2UgcGFyZW50IGlzIHRoZSBMQ0EgKHdoaWNoJ2xsIGJlIGFuIGVuZCBvZiB0aGUgc2VsZWN0aW9uIGZyYWdtZW50KS5cbiAgICBmb3IgKHZhciBhbmNlc3RvciA9IHRoaXM7IGFuY2VzdG9yLnBhcmVudDsgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5wYXJlbnQuaWQgaW4gYW50aWN1cnNvci5hbmNlc3RvcnMpIHtcbiAgICAgICAgdmFyIGxjYSA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHByYXkoJ2N1cnNvciBhbmQgYW50aWN1cnNvciBpbiB0aGUgc2FtZSB0cmVlJywgbGNhKTtcbiAgICAvLyBUaGUgY3Vyc29yIGFuZCB0aGUgYW50aWN1cnNvciBzaG91bGQgYmUgaW4gdGhlIHNhbWUgdHJlZSwgYmVjYXVzZSB0aGVcbiAgICAvLyBtb3VzZW1vdmUgaGFuZGxlciBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHVubGlrZSB0aGUgb25lIGF0dGFjaGVkIHRvXG4gICAgLy8gdGhlIHJvb3QgSFRNTCBET00gZWxlbWVudCwgZG9lc24ndCB0cnkgdG8gZ2V0IHRoZSBtYXRoIHRyZWUgbm9kZSBvZiB0aGVcbiAgICAvLyBtb3VzZW1vdmUgdGFyZ2V0LCBhbmQgQ3Vyc29yOjpzZWVrKCkgYmFzZWQgc29sZWx5IG9uIGNvb3JkaW5hdGVzIHN0YXlzXG4gICAgLy8gd2l0aGluIHRoZSB0cmVlIG9mIGB0aGlzYCBjdXJzb3IncyByb290LlxuXG4gICAgLy8gVGhlIG90aGVyIGVuZCBvZiB0aGUgc2VsZWN0aW9uIGZyYWdtZW50LCB0aGUgYW5jZXN0b3Igb2YgdGhlIGFudGljdXJzb3JcbiAgICAvLyB3aG9zZSBwYXJlbnQgaXMgdGhlIExDQS5cbiAgICB2YXIgYW50aUFuY2VzdG9yID0gYW50aWN1cnNvci5hbmNlc3RvcnNbbGNhLmlkXTtcblxuICAgIC8vIE5vdyB3ZSBoYXZlIHR3byBlaXRoZXIgTm9kZXMgb3IgUG9pbnRzLCBndWFyYW50ZWVkIHRvIGhhdmUgYSBjb21tb25cbiAgICAvLyBwYXJlbnQgYW5kIGd1YXJhbnRlZWQgdGhhdCBpZiBib3RoIGFyZSBQb2ludHMsIHRoZXkgYXJlIG5vdCB0aGUgc2FtZSxcbiAgICAvLyBhbmQgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IHdoaWNoIGlzIHRoZSBsZWZ0IGVuZCBhbmQgd2hpY2ggdGhlIHJpZ2h0IGVuZFxuICAgIC8vIG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgdmFyIGxlZnRFbmQsIHJpZ2h0RW5kLCBkaXIgPSBSO1xuXG4gICAgLy8gVGhpcyBpcyBhbiBleHRyZW1lbHkgc3VidGxlIGFsZ29yaXRobS5cbiAgICAvLyBBcyBhIHNwZWNpYWwgY2FzZSwgYGFuY2VzdG9yYCBjb3VsZCBiZSBhIFBvaW50IGFuZCBgYW50aUFuY2VzdG9yYCBhIE5vZGVcbiAgICAvLyBpbW1lZGlhdGVseSB0byBgYW5jZXN0b3JgJ3MgbGVmdC5cbiAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsXG4gICAgLy8gLSBib3RoIE5vZGVzXG4gICAgLy8gLSBgYW5jZXN0b3JgIGEgUG9pbnQgYW5kIGBhbnRpQW5jZXN0b3JgIGEgTm9kZVxuICAgIC8vIC0gYGFuY2VzdG9yYCBhIE5vZGUgYW5kIGBhbnRpQW5jZXN0b3JgIGEgUG9pbnRcbiAgICAvLyBgYW50aUFuY2VzdG9yW1JdID09PSByaWdodHdhcmRbUl1gIGZvciBzb21lIGByaWdodHdhcmRgIHRoYXQgaXNcbiAgICAvLyBgYW5jZXN0b3JgIG9yIHRvIGl0cyByaWdodCwgaWYgYW5kIG9ubHkgaWYgYGFudGlBbmNlc3RvcmAgaXMgdG9cbiAgICAvLyB0aGUgcmlnaHQgb2YgYGFuY2VzdG9yYC5cbiAgICBpZiAoYW5jZXN0b3JbTF0gIT09IGFudGlBbmNlc3Rvcikge1xuICAgICAgZm9yICh2YXIgcmlnaHR3YXJkID0gYW5jZXN0b3I7IHJpZ2h0d2FyZDsgcmlnaHR3YXJkID0gcmlnaHR3YXJkW1JdKSB7XG4gICAgICAgIGlmIChyaWdodHdhcmRbUl0gPT09IGFudGlBbmNlc3RvcltSXSkge1xuICAgICAgICAgIGRpciA9IEw7XG4gICAgICAgICAgbGVmdEVuZCA9IGFuY2VzdG9yO1xuICAgICAgICAgIHJpZ2h0RW5kID0gYW50aUFuY2VzdG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXIgPT09IFIpIHtcbiAgICAgIGxlZnRFbmQgPSBhbnRpQW5jZXN0b3I7XG4gICAgICByaWdodEVuZCA9IGFuY2VzdG9yO1xuICAgIH1cblxuICAgIC8vIG9ubHkgd2FudCB0byBzZWxlY3QgTm9kZXMgdXAgdG8gUG9pbnRzLCBjYW4ndCBzZWxlY3QgUG9pbnRzIHRoZW1zZWx2ZXNcbiAgICBpZiAobGVmdEVuZCBpbnN0YW5jZW9mIFBvaW50KSBsZWZ0RW5kID0gbGVmdEVuZFtSXTtcbiAgICBpZiAocmlnaHRFbmQgaW5zdGFuY2VvZiBQb2ludCkgcmlnaHRFbmQgPSByaWdodEVuZFtMXTtcblxuICAgIHRoaXMuaGlkZSgpLnNlbGVjdGlvbiA9IGxjYS5zZWxlY3RDaGlsZHJlbihsZWZ0RW5kLCByaWdodEVuZCk7XG4gICAgdGhpcy5pbnNEaXJPZihkaXIsIHRoaXMuc2VsZWN0aW9uLmVuZHNbZGlyXSk7XG4gICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgXy5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5kZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2VsZWN0aW9uKSByZXR1cm47XG5cbiAgICB0aGlzW0xdID0gdGhpcy5zZWxlY3Rpb24uZW5kc1tMXVtMXTtcbiAgICB0aGlzW1JdID0gdGhpcy5zZWxlY3Rpb24uZW5kc1tSXVtSXTtcbiAgICB0aGlzLnNlbGVjdGlvbi5yZW1vdmUoKTtcbiAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICBkZWxldGUgdGhpcy5zZWxlY3Rpb247XG4gIH07XG4gIF8ucmVwbGFjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxuID0gdGhpcy5zZWxlY3Rpb247XG4gICAgaWYgKHNlbG4pIHtcbiAgICAgIHRoaXNbTF0gPSBzZWxuLmVuZHNbTF1bTF07XG4gICAgICB0aGlzW1JdID0gc2Vsbi5lbmRzW1JdW1JdO1xuICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gc2VsbjtcbiAgfTtcbn0pO1xuXG52YXIgU2VsZWN0aW9uID0gUChGcmFnbWVudCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyXy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5qUSA9IHRoaXMualEud3JhcEFsbCgnPHNwYW4gY2xhc3M9XCJtcS1zZWxlY3Rpb25cIj48L3NwYW4+JykucGFyZW50KCk7XG4gICAgICAvL2Nhbid0IGRvIHdyYXBBbGwodGhpcy5qUSA9ICQoLi4uKSkgYmVjYXVzZSB3cmFwQWxsIHdpbGwgY2xvbmUgaXRcbiAgfTtcbiAgXy5hZG9wdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMualEucmVwbGFjZVdpdGgodGhpcy5qUSA9IHRoaXMualEuY2hpbGRyZW4oKSk7XG4gICAgcmV0dXJuIHN1cGVyXy5hZG9wdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBfLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXNpbmcgdGhlIGJyb3dzZXIncyBuYXRpdmUgLmNoaWxkTm9kZXMgcHJvcGVydHkgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IGRpc2NhcmQgdGV4dCBub2Rlcy5cbiAgICB0aGlzLmpRLnJlcGxhY2VXaXRoKHRoaXMualFbMF0uY2hpbGROb2Rlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uam9pbiA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkKCcnLCBmdW5jdGlvbihmb2xkLCBjaGlsZCkge1xuICAgICAgcmV0dXJuIGZvbGQgKyBjaGlsZFttZXRob2ROYW1lXSgpO1xuICAgIH0pO1xuICB9O1xufSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb250cm9sbGVyIGZvciBhIE1hdGhRdWlsbCBpbnN0YW5jZSxcbiAqIG9uIHdoaWNoIHNlcnZpY2VzIGFyZSByZWdpc3RlcmVkIHdpdGhcbiAqXG4gKiAgIENvbnRyb2xsZXIub3BlbihmdW5jdGlvbihfKSB7IC4uLiB9KTtcbiAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBDb250cm9sbGVyID0gUChmdW5jdGlvbihfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKHJvb3QsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSByb290LmlkO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgcm9vdC5jb250cm9sbGVyID0gdGhpcztcblxuICAgIHRoaXMuY3Vyc29yID0gcm9vdC5jdXJzb3IgPSBDdXJzb3Iocm9vdCwgb3B0aW9ucyk7XG4gICAgLy8gVE9ETzogc3RvcCBkZXBlbmRpbmcgb24gcm9vdC5jdXJzb3IsIGFuZCBybSBpdFxuICB9O1xuXG4gIF8uaGFuZGxlID0gZnVuY3Rpb24obmFtZSwgZGlyKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5vcHRpb25zLmhhbmRsZXJzO1xuICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5mbnNbbmFtZV0pIHtcbiAgICAgIHZhciBtcSA9IGhhbmRsZXJzLkFQSUNsYXNzZXNbdGhpcy5LSU5EX09GX01RXSh0aGlzKTtcbiAgICAgIGlmIChkaXIgPT09IEwgfHwgZGlyID09PSBSKSBoYW5kbGVycy5mbnNbbmFtZV0oZGlyLCBtcSk7XG4gICAgICBlbHNlIGhhbmRsZXJzLmZuc1tuYW1lXShtcSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBub3RpZnllZXMgPSBbXTtcbiAgdGhpcy5vbk5vdGlmeSA9IGZ1bmN0aW9uKGYpIHsgbm90aWZ5ZWVzLnB1c2goZik7IH07XG4gIF8ubm90aWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RpZnllZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG5vdGlmeWVlc1tpXS5hcHBseSh0aGlzLmN1cnNvciwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoZSBwdWJsaWNseSBleHBvc2VkIE1hdGhRdWlsbCBBUEkuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBBUEkgPSB7fSwgT3B0aW9ucyA9IFAoKSwgb3B0aW9uUHJvY2Vzc29ycyA9IHt9LCBQcm9nZW5vdGUgPSBQKCksIEVNQkVEUyA9IHt9O1xuXG4vKipcbiAqIEludGVyZmFjZSBWZXJzaW9uaW5nICgjNDU5LCAjNDk1KSB0byBhbGxvdyB1cyB0byB2aXJ0dWFsbHkgZ3VhcmFudGVlXG4gKiBiYWNrY29tcGF0LiB2MC4xMC54IGludHJvZHVjZXMgaXQsIHNvIGZvciBub3csIGRvbid0IGNvbXBsZXRlbHkgYnJlYWsgdGhlXG4gKiBBUEkgZm9yIHBlb3BsZSB3aG8gZG9uJ3Qga25vdyBhYm91dCBpdCwganVzdCBjb21wbGFpbiB3aXRoIGNvbnNvbGUud2FybigpLlxuICpcbiAqIFRoZSBtZXRob2RzIGFyZSBzaGltbWVkIGluIG91dHJvLmpzIHNvIHRoYXQgTVEuTWF0aEZpZWxkLnByb3RvdHlwZSBldGMgY2FuXG4gKiBiZSBhY2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gaW5zaXN0T25JbnRlclZlcigpIHtcbiAgaWYgKHdpbmRvdy5jb25zb2xlKSBjb25zb2xlLndhcm4oXG4gICAgJ1lvdSBhcmUgdXNpbmcgdGhlIE1hdGhRdWlsbCBBUEkgd2l0aG91dCBzcGVjaWZ5aW5nIGFuIGludGVyZmFjZSB2ZXJzaW9uLCAnICtcbiAgICAnd2hpY2ggd2lsbCBmYWlsIGluIHYxLjAuMC4gRWFzaWVzdCBmaXggaXMgdG8gZG8gdGhlIGZvbGxvd2luZyBiZWZvcmUgJyArXG4gICAgJ2RvaW5nIGFueXRoaW5nIGVsc2U6XFxuJyArXG4gICAgJ1xcbicgK1xuICAgICcgICAgTWF0aFF1aWxsID0gTWF0aFF1aWxsLmdldEludGVyZmFjZSgxKTtcXG4nICtcbiAgICAnICAgIC8vIG5vdyBNYXRoUXVpbGwuTWF0aEZpZWxkKCkgd29ya3MgbGlrZSBpdCB1c2VkIHRvXFxuJyArXG4gICAgJ1xcbicgK1xuICAgICdTZWUgYWxzbyB0aGUgXCJgZGV2YCBicmFuY2ggKDIwMTRcXHUyMDEzMjAxNSkgXFx1MjE5MiB2MC4xMC4wIE1pZ3JhdGlvbiBHdWlkZVwiIGF0XFxuJyArXG4gICAgJyAgaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvd2lraS8lNjBkZXYlNjAtYnJhbmNoLSgyMDE0JUUyJTgwJTkzMjAxNSktJUUyJTg2JTkyLXYwLjEwLjAtTWlncmF0aW9uLUd1aWRlJ1xuICApO1xufVxuLy8gZ2xvYmFsbHkgZXhwb3J0ZWQgQVBJIG9iamVjdFxuZnVuY3Rpb24gTWF0aFF1aWxsKGVsKSB7XG4gIGluc2lzdE9uSW50ZXJWZXIoKTtcbiAgcmV0dXJuIE1RMShlbCk7XG59O1xuTWF0aFF1aWxsLnByb3RvdHlwZSA9IFByb2dlbm90ZS5wO1xuTWF0aFF1aWxsLmludGVyZmFjZVZlcnNpb24gPSBmdW5jdGlvbih2KSB7XG4gIC8vIHNoaW0gZm9yICM0NTktZXJhIGludGVyZmFjZSB2ZXJzaW9uaW5nIChlbmRlZCB3aXRoICM0OTUpXG4gIGlmICh2ICE9PSAxKSB0aHJvdyAnT25seSBpbnRlcmZhY2UgdmVyc2lvbiAxIHN1cHBvcnRlZC4gWW91IHNwZWNpZmllZDogJyArIHY7XG4gIGluc2lzdE9uSW50ZXJWZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAod2luZG93LmNvbnNvbGUpIGNvbnNvbGUud2FybihcbiAgICAgICdZb3UgY2FsbGVkIE1hdGhRdWlsbC5pbnRlcmZhY2VWZXJzaW9uKDEpOyB0byBzcGVjaWZ5IHRoZSBpbnRlcmZhY2UgJyArXG4gICAgICAndmVyc2lvbiwgd2hpY2ggd2lsbCBmYWlsIGluIHYxLjAuMC4gWW91IGNhbiBmaXggdGhpcyBlYXNpbHkgYnkgZG9pbmcgJyArXG4gICAgICAndGhpcyBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZTpcXG4nICtcbiAgICAgICdcXG4nICtcbiAgICAgICcgICAgTWF0aFF1aWxsID0gTWF0aFF1aWxsLmdldEludGVyZmFjZSgxKTtcXG4nICtcbiAgICAgICcgICAgLy8gbm93IE1hdGhRdWlsbC5NYXRoRmllbGQoKSB3b3JrcyBsaWtlIGl0IHVzZWQgdG9cXG4nICtcbiAgICAgICdcXG4nICtcbiAgICAgICdTZWUgYWxzbyB0aGUgXCJgZGV2YCBicmFuY2ggKDIwMTRcXHUyMDEzMjAxNSkgXFx1MjE5MiB2MC4xMC4wIE1pZ3JhdGlvbiBHdWlkZVwiIGF0XFxuJyArXG4gICAgICAnICBodHRwczovL2dpdGh1Yi5jb20vbWF0aHF1aWxsL21hdGhxdWlsbC93aWtpLyU2MGRldiU2MC1icmFuY2gtKDIwMTQlRTIlODAlOTMyMDE1KS0lRTIlODYlOTItdjAuMTAuMC1NaWdyYXRpb24tR3VpZGUnXG4gICAgKTtcbiAgfTtcbiAgaW5zaXN0T25JbnRlclZlcigpO1xuICByZXR1cm4gTWF0aFF1aWxsO1xufTtcbk1hdGhRdWlsbC5nZXRJbnRlcmZhY2UgPSBnZXRJbnRlcmZhY2U7XG5cbnZhciBNSU4gPSBnZXRJbnRlcmZhY2UuTUlOID0gMSwgTUFYID0gZ2V0SW50ZXJmYWNlLk1BWCA9IDI7XG5mdW5jdGlvbiBnZXRJbnRlcmZhY2Uodikge1xuICBpZiAoIShNSU4gPD0gdiAmJiB2IDw9IE1BWCkpIHRocm93ICdPbmx5IGludGVyZmFjZSB2ZXJzaW9ucyBiZXR3ZWVuICcgK1xuICAgIE1JTiArICcgYW5kICcgKyBNQVggKyAnIHN1cHBvcnRlZC4gWW91IHNwZWNpZmllZDogJyArIHY7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCwgaWYgaXQncyB0aGUgcm9vdCBIVE1MIGVsZW1lbnQgb2YgYVxuICAgKiBzdGF0aWMgbWF0aCBvciBtYXRoIG9yIHRleHQgZmllbGQsIHJldHVybnMgYW4gQVBJIG9iamVjdCBmb3IgaXQgKGVsc2UsIG51bGwpLlxuICAgKlxuICAgKiAgIHZhciBtYXRoZmllbGQgPSBNUS5NYXRoRmllbGQobWF0aEZpZWxkU3Bhbik7XG4gICAqICAgYXNzZXJ0KE1RKG1hdGhGaWVsZFNwYW4pLmlkID09PSBtYXRoZmllbGQuaWQpO1xuICAgKiAgIGFzc2VydChNUShtYXRoRmllbGRTcGFuKS5pZCA9PT0gTVEobWF0aEZpZWxkU3BhbikuaWQpO1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTVEoZWwpIHtcbiAgICBpZiAoIWVsIHx8ICFlbC5ub2RlVHlwZSkgcmV0dXJuIG51bGw7IC8vIGNoZWNrIHRoYXQgYGVsYCBpcyBhIEhUTUwgZWxlbWVudCwgdXNpbmcgdGhlXG4gICAgICAvLyBzYW1lIHRlY2huaXF1ZSBhcyBqUXVlcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvNjc5NTM2ZWU0YjdhOTJhZTY0YTVmNThkOTBlOWNjMzhjMDAxZTgwNy9zcmMvY29yZS9pbml0LmpzI0w5MlxuICAgIHZhciBibG9ja0lkID0gJChlbCkuY2hpbGRyZW4oJy5tcS1yb290LWJsb2NrJykuYXR0cihtcUJsb2NrSWQpO1xuICAgIHZhciBjdHJsciA9IGJsb2NrSWQgJiYgTm9kZS5ieUlkW2Jsb2NrSWRdLmNvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGN0cmxyID8gQVBJQ2xhc3Nlc1tjdHJsci5LSU5EX09GX01RXShjdHJscikgOiBudWxsO1xuICB9O1xuICB2YXIgQVBJQ2xhc3NlcyA9IHt9O1xuXG4gIE1RLkwgPSBMO1xuICBNUS5SID0gUjtcblxuICBmdW5jdGlvbiBjb25maWcoY3VycmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAobmV3T3B0aW9ucyAmJiBuZXdPcHRpb25zLmhhbmRsZXJzKSB7XG4gICAgICBuZXdPcHRpb25zLmhhbmRsZXJzID0geyBmbnM6IG5ld09wdGlvbnMuaGFuZGxlcnMsIEFQSUNsYXNzZXM6IEFQSUNsYXNzZXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXdPcHRpb25zKSBpZiAobmV3T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV3T3B0aW9uc1tuYW1lXSwgcHJvY2Vzc29yID0gb3B0aW9uUHJvY2Vzc29yc1tuYW1lXTtcbiAgICAgIGN1cnJlbnRPcHRpb25zW25hbWVdID0gKHByb2Nlc3NvciA/IHByb2Nlc3Nvcih2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIE1RLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHsgY29uZmlnKE9wdGlvbnMucCwgb3B0cyk7IHJldHVybiB0aGlzOyB9O1xuICBNUS5yZWdpc3RlckVtYmVkID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghL15bYS16XVthLXowLTldKiQvaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyAnRW1iZWQgbmFtZSBtdXN0IHN0YXJ0IHdpdGggbGV0dGVyIGFuZCBiZSBvbmx5IGxldHRlcnMgYW5kIGRpZ2l0cyc7XG4gICAgfVxuICAgIEVNQkVEU1tuYW1lXSA9IG9wdGlvbnM7XG4gIH07XG5cbiAgdmFyIEFic3RyYWN0TWF0aFF1aWxsID0gQVBJQ2xhc3Nlcy5BYnN0cmFjdE1hdGhRdWlsbCA9IFAoUHJvZ2Vub3RlLCBmdW5jdGlvbihfKSB7XG4gICAgXy5pbml0ID0gZnVuY3Rpb24oY3RybHIpIHtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyID0gY3RybHI7XG4gICAgICB0aGlzLl9fb3B0aW9ucyA9IGN0cmxyLm9wdGlvbnM7XG4gICAgICB0aGlzLmlkID0gY3RybHIuaWQ7XG4gICAgICB0aGlzLmRhdGEgPSBjdHJsci5kYXRhO1xuICAgIH07XG4gICAgXy5fX21hdGhxdWlsbGlmeSA9IGZ1bmN0aW9uKGNsYXNzTmFtZXMpIHtcbiAgICAgIHZhciBjdHJsciA9IHRoaXMuX19jb250cm9sbGVyLCByb290ID0gY3RybHIucm9vdCwgZWwgPSBjdHJsci5jb250YWluZXI7XG4gICAgICBjdHJsci5jcmVhdGVUZXh0YXJlYSgpO1xuXG4gICAgICB2YXIgY29udGVudHMgPSBlbC5hZGRDbGFzcyhjbGFzc05hbWVzKS5jb250ZW50cygpLmRldGFjaCgpO1xuICAgICAgcm9vdC5qUSA9XG4gICAgICAgICQoJzxzcGFuIGNsYXNzPVwibXEtcm9vdC1ibG9ja1wiLz4nKS5hdHRyKG1xQmxvY2tJZCwgcm9vdC5pZCkuYXBwZW5kVG8oZWwpO1xuICAgICAgdGhpcy5sYXRleChjb250ZW50cy50ZXh0KCkpO1xuXG4gICAgICB0aGlzLnJldmVydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZWwuZW1wdHkoKS51bmJpbmQoJy5tYXRocXVpbGwnKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ21xLWVkaXRhYmxlLWZpZWxkIG1xLW1hdGgtbW9kZSBtcS10ZXh0LW1vZGUnKVxuICAgICAgICAuYXBwZW5kKGNvbnRlbnRzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBfLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHsgY29uZmlnKHRoaXMuX19vcHRpb25zLCBvcHRzKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgXy5lbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fX2NvbnRyb2xsZXIuY29udGFpbmVyWzBdOyB9O1xuICAgIF8udGV4dCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fX2NvbnRyb2xsZXIuZXhwb3J0VGV4dCgpOyB9O1xuICAgIF8ubGF0ZXggPSBmdW5jdGlvbihsYXRleCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX19jb250cm9sbGVyLnJlbmRlckxhdGV4TWF0aChsYXRleCk7XG4gICAgICAgIGlmICh0aGlzLl9fY29udHJvbGxlci5ibHVycmVkKSB0aGlzLl9fY29udHJvbGxlci5jdXJzb3IuaGlkZSgpLnBhcmVudC5ibHVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19jb250cm9sbGVyLmV4cG9ydExhdGV4KCk7XG4gICAgfTtcbiAgICBfLmh0bWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY29udHJvbGxlci5yb290LmpRLmh0bWwoKVxuICAgICAgICAucmVwbGFjZSgvIG1hdGhxdWlsbC0oPzpjb21tYW5kfGJsb2NrKS1pZD1cIj9cXGQrXCI/L2csICcnKVxuICAgICAgICAucmVwbGFjZSgvPHNwYW4gY2xhc3M9XCI/bXEtY3Vyc29yKCBtcS1ibGluayk/XCI/Pi4/PFxcL3NwYW4+L2ksICcnKVxuICAgICAgICAucmVwbGFjZSgvIG1xLWhhc0N1cnNvcnxtcS1oYXNDdXJzb3IgPy8sICcnKVxuICAgICAgICAucmVwbGFjZSgvIGNsYXNzPShcIlwifCg/PSB8PikpL2csICcnKTtcbiAgICB9O1xuICAgIF8ucmVmbG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fY29udHJvbGxlci5yb290LnBvc3RPcmRlcigncmVmbG93Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9KTtcbiAgTVEucHJvdG90eXBlID0gQWJzdHJhY3RNYXRoUXVpbGwucHJvdG90eXBlO1xuXG4gIEFQSUNsYXNzZXMuRWRpdGFibGVGaWVsZCA9IFAoQWJzdHJhY3RNYXRoUXVpbGwsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICAgIF8uX19tYXRocXVpbGxpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN1cGVyXy5fX21hdGhxdWlsbGlmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuZWRpdGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuZGVsZWdhdGVNb3VzZUV2ZW50cygpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuZWRpdGFibGVzVGV4dGFyZWFFdmVudHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXy5mb2N1cyA9IGZ1bmN0aW9uKCkgeyB0aGlzLl9fY29udHJvbGxlci50ZXh0YXJlYS5mb2N1cygpOyByZXR1cm4gdGhpczsgfTtcbiAgICBfLmJsdXIgPSBmdW5jdGlvbigpIHsgdGhpcy5fX2NvbnRyb2xsZXIudGV4dGFyZWEuYmx1cigpOyByZXR1cm4gdGhpczsgfTtcbiAgICBfLndyaXRlID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLndyaXRlTGF0ZXgobGF0ZXgpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuc2Nyb2xsSG9yaXooKTtcbiAgICAgIGlmICh0aGlzLl9fY29udHJvbGxlci5ibHVycmVkKSB0aGlzLl9fY29udHJvbGxlci5jdXJzb3IuaGlkZSgpLnBhcmVudC5ibHVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8uY21kID0gZnVuY3Rpb24oY21kKSB7XG4gICAgICB2YXIgY3RybHIgPSB0aGlzLl9fY29udHJvbGxlci5ub3RpZnkoKSwgY3Vyc29yID0gY3RybHIuY3Vyc29yO1xuICAgICAgaWYgKC9eXFxcXFthLXpdKyQvaS50ZXN0KGNtZCkpIHtcbiAgICAgICAgY21kID0gY21kLnNsaWNlKDEpO1xuICAgICAgICB2YXIga2xhc3MgPSBMYXRleENtZHNbY21kXTtcbiAgICAgICAgaWYgKGtsYXNzKSB7XG4gICAgICAgICAgY21kID0ga2xhc3MoY21kKTtcbiAgICAgICAgICBpZiAoY3Vyc29yLnNlbGVjdGlvbikgY21kLnJlcGxhY2VzKGN1cnNvci5yZXBsYWNlU2VsZWN0aW9uKCkpO1xuICAgICAgICAgIGNtZC5jcmVhdGVMZWZ0T2YoY3Vyc29yLnNob3coKSk7XG4gICAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuc2Nyb2xsSG9yaXooKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIC8qIFRPRE86IEFQSSBuZWVkcyBiZXR0ZXIgZXJyb3IgcmVwb3J0aW5nICovO1xuICAgICAgfVxuICAgICAgZWxzZSBjdXJzb3IucGFyZW50LndyaXRlKGN1cnNvciwgY21kKTtcbiAgICAgIGlmIChjdHJsci5ibHVycmVkKSBjdXJzb3IuaGlkZSgpLnBhcmVudC5ibHVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8uc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3RybHIgPSB0aGlzLl9fY29udHJvbGxlcjtcbiAgICAgIGN0cmxyLm5vdGlmeSgnbW92ZScpLmN1cnNvci5pbnNBdFJpZ2h0RW5kKGN0cmxyLnJvb3QpO1xuICAgICAgd2hpbGUgKGN0cmxyLmN1cnNvcltMXSkgY3RybHIuc2VsZWN0TGVmdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fY29udHJvbGxlci5jdXJzb3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfLm1vdmVUb0RpckVuZCA9IGZ1bmN0aW9uKGRpcikge1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIubm90aWZ5KCdtb3ZlJykuY3Vyc29yLmluc0F0RGlyRW5kKGRpciwgdGhpcy5fX2NvbnRyb2xsZXIucm9vdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8ubW92ZVRvTGVmdEVuZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tb3ZlVG9EaXJFbmQoTCk7IH07XG4gICAgXy5tb3ZlVG9SaWdodEVuZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tb3ZlVG9EaXJFbmQoUik7IH07XG5cbiAgICBfLmtleXN0cm9rZSA9IGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgIHZhciBrZXlzID0ga2V5cy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykuc3BsaXQoL1xccysvKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlci5rZXlzdHJva2Uoa2V5c1tpXSwgeyBwcmV2ZW50RGVmYXVsdDogbm9vcCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXy50eXBlZFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpICs9IDEpIHRoaXMuX19jb250cm9sbGVyLnR5cGVkVGV4dCh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8uZHJvcEVtYmVkZGVkID0gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IHBhZ2VYIC0gJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcbiAgICAgIHZhciBjbGllbnRZID0gcGFnZVkgLSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG5cbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICB0aGlzLl9fY29udHJvbGxlci5zZWVrKCQoZWwpLCBwYWdlWCwgcGFnZVkpO1xuICAgICAgdmFyIGNtZCA9IEVtYmVkKCkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGNtZC5jcmVhdGVMZWZ0T2YodGhpcy5fX2NvbnRyb2xsZXIuY3Vyc29yKTtcbiAgICB9O1xuICAgIF8uY2xpY2tBdCA9IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFksIHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG5cbiAgICAgIHZhciBjdHJsciA9IHRoaXMuX19jb250cm9sbGVyLCByb290ID0gY3RybHIucm9vdDtcbiAgICAgIGlmICghalF1ZXJ5LmNvbnRhaW5zKHJvb3QualFbMF0sIHRhcmdldCkpIHRhcmdldCA9IHJvb3QualFbMF07XG4gICAgICBjdHJsci5zZWVrKCQodGFyZ2V0KSwgY2xpZW50WCArIHBhZ2VYT2Zmc2V0LCBjbGllbnRZICsgcGFnZVlPZmZzZXQpO1xuICAgICAgaWYgKGN0cmxyLmJsdXJyZWQpIHRoaXMuZm9jdXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXy5pZ25vcmVOZXh0TW91c2Vkb3duID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLmN1cnNvci5vcHRpb25zLmlnbm9yZU5leHRNb3VzZWRvd24gPSBmbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuICBNUS5FZGl0YWJsZUZpZWxkID0gZnVuY3Rpb24oKSB7IHRocm93IFwid3RmIGRvbid0IGNhbGwgbWUsIEknbSAnYWJzdHJhY3QnXCI7IH07XG4gIE1RLkVkaXRhYmxlRmllbGQucHJvdG90eXBlID0gQVBJQ2xhc3Nlcy5FZGl0YWJsZUZpZWxkLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogRXhwb3J0IHRoZSBBUEkgZnVuY3Rpb25zIHRoYXQgTWF0aFF1aWxsLWlmeSBhbiBIVE1MIGVsZW1lbnQgaW50byBBUEkgb2JqZWN0c1xuICAgKiBvZiBlYWNoIGNsYXNzLiBJZiB0aGUgZWxlbWVudCBoYWQgYWxyZWFkeSBiZWVuIE1hdGhRdWlsbC1pZmllZCBidXQgaW50byBhXG4gICAqIGRpZmZlcmVudCBraW5kIChvciBpdCdzIG5vdCBhbiBIVE1MIGVsZW1lbnQpLCByZXR1cm4gbnVsbC5cbiAgICovXG4gIGZvciAodmFyIGtpbmQgaW4gQVBJKSAoZnVuY3Rpb24oa2luZCwgZGVmQVBJQ2xhc3MpIHtcbiAgICB2YXIgQVBJQ2xhc3MgPSBBUElDbGFzc2VzW2tpbmRdID0gZGVmQVBJQ2xhc3MoQVBJQ2xhc3Nlcyk7XG4gICAgTVFba2luZF0gPSBmdW5jdGlvbihlbCwgb3B0cykge1xuICAgICAgdmFyIG1xID0gTVEoZWwpO1xuICAgICAgaWYgKG1xIGluc3RhbmNlb2YgQVBJQ2xhc3MgfHwgIWVsIHx8ICFlbC5ub2RlVHlwZSkgcmV0dXJuIG1xO1xuICAgICAgdmFyIGN0cmxyID0gQ29udHJvbGxlcihBUElDbGFzcy5Sb290QmxvY2soKSwgJChlbCksIE9wdGlvbnMoKSk7XG4gICAgICBjdHJsci5LSU5EX09GX01RID0ga2luZDtcbiAgICAgIHJldHVybiBBUElDbGFzcyhjdHJscikuX19tYXRocXVpbGxpZnkob3B0cywgdik7XG4gICAgfTtcbiAgICBNUVtraW5kXS5wcm90b3R5cGUgPSBBUElDbGFzcy5wcm90b3R5cGU7XG4gIH0oa2luZCwgQVBJW2tpbmRdKSk7XG5cbiAgcmV0dXJuIE1RO1xufVxuXG5NYXRoUXVpbGwubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuTWF0aFF1aWxsID0gb3JpZ01hdGhRdWlsbDtcbiAgcmV0dXJuIE1hdGhRdWlsbDtcbn07XG52YXIgb3JpZ01hdGhRdWlsbCA9IHdpbmRvdy5NYXRoUXVpbGw7XG53aW5kb3cuTWF0aFF1aWxsID0gTWF0aFF1aWxsO1xuXG5mdW5jdGlvbiBSb290QmxvY2tNaXhpbihfKSB7XG4gIHZhciBuYW1lcyA9ICdtb3ZlT3V0T2YgZGVsZXRlT3V0T2Ygc2VsZWN0T3V0T2YgdXBPdXRPZiBkb3duT3V0T2YnLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIChmdW5jdGlvbihuYW1lKSB7XG4gICAgX1tuYW1lXSA9IGZ1bmN0aW9uKGRpcikgeyB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlKG5hbWUsIGRpcik7IH07XG4gIH0obmFtZXNbaV0pKTtcbiAgXy5yZWZsb3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlKCdyZWZsb3cnKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlKCdlZGl0ZWQnKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlKCdlZGl0Jyk7XG4gIH07XG59XG52YXIgUGFyc2VyID0gUChmdW5jdGlvbihfLCBzdXBlcl8sIFBhcnNlcikge1xuICAvLyBUaGUgUGFyc2VyIG9iamVjdCBpcyBhIHdyYXBwZXIgZm9yIGEgcGFyc2VyIGZ1bmN0aW9uLlxuICAvLyBFeHRlcm5hbGx5LCB5b3UgdXNlIG9uZSB0byBwYXJzZSBhIHN0cmluZyBieSBjYWxsaW5nXG4gIC8vICAgdmFyIHJlc3VsdCA9IFNvbWVQYXJzZXIucGFyc2UoJ01lIE1lIE1lISBQYXJzZSBNZSEnKTtcbiAgLy8gWW91IHNob3VsZCBuZXZlciBjYWxsIHRoZSBjb25zdHJ1Y3RvciwgcmF0aGVyIHlvdSBzaG91bGRcbiAgLy8gY29uc3RydWN0IHlvdXIgUGFyc2VyIGZyb20gdGhlIGJhc2UgcGFyc2VycyBhbmQgdGhlXG4gIC8vIHBhcnNlciBjb21iaW5hdG9yIG1ldGhvZHMuXG5cbiAgZnVuY3Rpb24gcGFyc2VFcnJvcihzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW0gPSBcIidcIitzdHJlYW0rXCInXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyZWFtID0gJ0VPRic7XG4gICAgfVxuXG4gICAgdGhyb3cgJ1BhcnNlIEVycm9yOiAnK21lc3NhZ2UrJyBhdCAnK3N0cmVhbTtcbiAgfVxuXG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGJvZHkpIHsgdGhpcy5fID0gYm9keTsgfTtcblxuICBfLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcChlb2YpLl8oJycrc3RyZWFtLCBzdWNjZXNzLCBwYXJzZUVycm9yKTtcblxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3Moc3RyZWFtLCByZXN1bHQpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICB9O1xuXG4gIC8vIC0qLSBwcmltaXRpdmUgY29tYmluYXRvcnMgLSotIC8vXG4gIF8ub3IgPSBmdW5jdGlvbihhbHRlcm5hdGl2ZSkge1xuICAgIHByYXkoJ29yIGlzIHBhc3NlZCBhIHBhcnNlcicsIGFsdGVybmF0aXZlIGluc3RhbmNlb2YgUGFyc2VyKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgICAgcmV0dXJuIHNlbGYuXyhzdHJlYW0sIG9uU3VjY2VzcywgZmFpbHVyZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUobmV3U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGl2ZS5fKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF8udGhlbiA9IGZ1bmN0aW9uKG5leHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICAgIHJldHVybiBzZWxmLl8oc3RyZWFtLCBzdWNjZXNzLCBvbkZhaWx1cmUpO1xuXG4gICAgICBmdW5jdGlvbiBzdWNjZXNzKG5ld1N0cmVhbSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBuZXh0UGFyc2VyID0gKG5leHQgaW5zdGFuY2VvZiBQYXJzZXIgPyBuZXh0IDogbmV4dChyZXN1bHQpKTtcbiAgICAgICAgcHJheSgnYSBwYXJzZXIgaXMgcmV0dXJuZWQnLCBuZXh0UGFyc2VyIGluc3RhbmNlb2YgUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIG5leHRQYXJzZXIuXyhuZXdTdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyAtKi0gb3B0aW1pemVkIGl0ZXJhdGl2ZSBjb21iaW5hdG9ycyAtKi0gLy9cbiAgXy5tYW55ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICB2YXIgeHMgPSBbXTtcbiAgICAgIHdoaWxlIChzZWxmLl8oc3RyZWFtLCBzdWNjZXNzLCBmYWlsdXJlKSk7XG4gICAgICByZXR1cm4gb25TdWNjZXNzKHN0cmVhbSwgeHMpO1xuXG4gICAgICBmdW5jdGlvbiBzdWNjZXNzKG5ld1N0cmVhbSwgeCkge1xuICAgICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgICAgIHhzLnB1c2goeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBtYXggPSBtaW47XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICB2YXIgeHMgPSBbXTtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgdmFyIGZhaWx1cmU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5fKHN0cmVhbSwgc3VjY2VzcywgZmlyc3RGYWlsdXJlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBvbkZhaWx1cmUoc3RyZWFtLCBmYWlsdXJlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBtYXggJiYgcmVzdWx0OyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5fKHN0cmVhbSwgc3VjY2Vzcywgc2Vjb25kRmFpbHVyZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLCB4cyk7XG5cbiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MobmV3U3RyZWFtLCB4KSB7XG4gICAgICAgIHhzLnB1c2goeCk7XG4gICAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZpcnN0RmFpbHVyZShuZXdTdHJlYW0sIG1zZykge1xuICAgICAgICBmYWlsdXJlID0gbXNnO1xuICAgICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2Vjb25kRmFpbHVyZShuZXdTdHJlYW0sIG1zZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gLSotIGhpZ2hlci1sZXZlbCBjb21iaW5hdG9ycyAtKi0gLy9cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihyZXMpIHsgcmV0dXJuIHRoaXMudGhlbihzdWNjZWVkKHJlcykpOyB9O1xuICBfLmF0TW9zdCA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIHRoaXMudGltZXMoMCwgbik7IH07XG4gIF8uYXRMZWFzdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHNlbGYudGltZXMobikudGhlbihmdW5jdGlvbihzdGFydCkge1xuICAgICAgcmV0dXJuIHNlbGYubWFueSgpLm1hcChmdW5jdGlvbihlbmQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmNvbmNhdChlbmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgXy5tYXAgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7IHJldHVybiBzdWNjZWVkKGZuKHJlc3VsdCkpOyB9KTtcbiAgfTtcblxuICBfLnNraXAgPSBmdW5jdGlvbih0d28pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHJlc3VsdCkgeyByZXR1cm4gdHdvLnJlc3VsdChyZXN1bHQpOyB9KTtcbiAgfTtcblxuICAvLyAtKi0gcHJpbWl0aXZlIHBhcnNlcnMgLSotIC8vXG4gIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBleHBlY3RlZCA9IFwiZXhwZWN0ZWQgJ1wiK3N0citcIidcIjtcblxuICAgIHJldHVybiBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgICAgdmFyIGhlYWQgPSBzdHJlYW0uc2xpY2UoMCwgbGVuKTtcblxuICAgICAgaWYgKGhlYWQgPT09IHN0cikge1xuICAgICAgICByZXR1cm4gb25TdWNjZXNzKHN0cmVhbS5zbGljZShsZW4pLCBoZWFkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb25GYWlsdXJlKHN0cmVhbSwgZXhwZWN0ZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZWdleCA9IHRoaXMucmVnZXggPSBmdW5jdGlvbihyZSkge1xuICAgIHByYXkoJ3JlZ2V4cCBwYXJzZXIgaXMgYW5jaG9yZWQnLCByZS50b1N0cmluZygpLmNoYXJBdCgxKSA9PT0gJ14nKTtcblxuICAgIHZhciBleHBlY3RlZCA9ICdleHBlY3RlZCAnK3JlO1xuXG4gICAgcmV0dXJuIFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cmVhbSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbWF0Y2hbMF07XG4gICAgICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLnNsaWNlKHJlc3VsdC5sZW5ndGgpLCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvbkZhaWx1cmUoc3RyZWFtLCBleHBlY3RlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHN1Y2NlZWQgPSBQYXJzZXIuc3VjY2VlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiBQYXJzZXIoZnVuY3Rpb24oc3RyZWFtLCBvblN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBmYWlsID0gUGFyc2VyLmZhaWwgPSBmdW5jdGlvbihtc2cpIHtcbiAgICByZXR1cm4gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgXywgb25GYWlsdXJlKSB7XG4gICAgICByZXR1cm4gb25GYWlsdXJlKHN0cmVhbSwgbXNnKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGV0dGVyID0gUGFyc2VyLmxldHRlciA9IHJlZ2V4KC9eW2Etel0vaSk7XG4gIHZhciBsZXR0ZXJzID0gUGFyc2VyLmxldHRlcnMgPSByZWdleCgvXlthLXpdKi9pKTtcbiAgdmFyIGRpZ2l0ID0gUGFyc2VyLmRpZ2l0ID0gcmVnZXgoL15bMC05XS8pO1xuICB2YXIgZGlnaXRzID0gUGFyc2VyLmRpZ2l0cyA9IHJlZ2V4KC9eWzAtOV0qLyk7XG4gIHZhciB3aGl0ZXNwYWNlID0gUGFyc2VyLndoaXRlc3BhY2UgPSByZWdleCgvXlxccysvKTtcbiAgdmFyIG9wdFdoaXRlc3BhY2UgPSBQYXJzZXIub3B0V2hpdGVzcGFjZSA9IHJlZ2V4KC9eXFxzKi8pO1xuXG4gIHZhciBhbnkgPSBQYXJzZXIuYW55ID0gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICBpZiAoIXN0cmVhbSkgcmV0dXJuIG9uRmFpbHVyZShzdHJlYW0sICdleHBlY3RlZCBhbnkgY2hhcmFjdGVyJyk7XG5cbiAgICByZXR1cm4gb25TdWNjZXNzKHN0cmVhbS5zbGljZSgxKSwgc3RyZWFtLmNoYXJBdCgwKSk7XG4gIH0pO1xuXG4gIHZhciBhbGwgPSBQYXJzZXIuYWxsID0gUGFyc2VyKGZ1bmN0aW9uKHN0cmVhbSwgb25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgICByZXR1cm4gb25TdWNjZXNzKCcnLCBzdHJlYW0pO1xuICB9KTtcblxuICB2YXIgZW9mID0gUGFyc2VyLmVvZiA9IFBhcnNlcihmdW5jdGlvbihzdHJlYW0sIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgaWYgKHN0cmVhbSkgcmV0dXJuIG9uRmFpbHVyZShzdHJlYW0sICdleHBlY3RlZCBFT0YnKTtcblxuICAgIHJldHVybiBvblN1Y2Nlc3Moc3RyZWFtLCBzdHJlYW0pO1xuICB9KTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNhbmUgS2V5Ym9hcmQgRXZlbnRzIFNoaW1cbiAqXG4gKiBBbiBhYnN0cmFjdGlvbiBsYXllciB3cmFwcGluZyB0aGUgdGV4dGFyZWEgaW5cbiAqIGFuIG9iamVjdCB3aXRoIG1ldGhvZHMgdG8gbWFuaXB1bGF0ZSBhbmQgbGlzdGVuXG4gKiB0byBldmVudHMgb24sIHRoYXQgaGlkZXMgYWxsIHRoZSBuYXN0eSBjcm9zcy1cbiAqIGJyb3dzZXIgaW5jb21wYXRpYmlsaXRpZXMgYmVoaW5kIGEgdW5pZm9ybSBBUEkuXG4gKlxuICogRGVzaWduIGdvYWw6IFRoaXMgaXMgYSAqSEFSRCogaW50ZXJuYWxcbiAqIGFic3RyYWN0aW9uIGJhcnJpZXIuIENyb3NzLWJyb3dzZXJcbiAqIGluY29uc2lzdGVuY2llcyBhcmUgbm90IGFsbG93ZWQgdG8gbGVhayB0aHJvdWdoXG4gKiBhbmQgYmUgZGVhbHQgd2l0aCBieSBldmVudCBoYW5kbGVycy4gQWxsIGZ1dHVyZVxuICogY3Jvc3MtYnJvd3NlciBpc3N1ZXMgdGhhdCBhcmlzZSBtdXN0IGJlIGRlYWx0XG4gKiB3aXRoIGhlcmUsIGFuZCBpZiBuZWNlc3NhcnksIHRoZSBBUEkgdXBkYXRlZC5cbiAqXG4gKiBPcmdhbml6YXRpb246XG4gKiAtIGtleSB2YWx1ZXMgbWFwIGFuZCBzdHJpbmdpZnkoKVxuICogLSBzYW5lS2V5Ym9hcmRFdmVudHMoKVxuICogICAgKyBkZWZlcigpIGFuZCBmbHVzaCgpXG4gKiAgICArIGV2ZW50IGhhbmRsZXIgbG9naWNcbiAqICAgICsgYXR0YWNoIGV2ZW50IGhhbmRsZXJzIGFuZCBleHBvcnQgbWV0aG9kc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHNhbmVLZXlib2FyZEV2ZW50cyA9IChmdW5jdGlvbigpIHtcbiAgLy8gVGhlIGZvbGxvd2luZyBba2V5IHZhbHVlc11bMV0gbWFwIHdhcyBjb21waWxlZCBmcm9tIHRoZVxuICAvLyBbRE9NMyBFdmVudHMgYXBwZW5kaXggc2VjdGlvbiBvbiBrZXkgY29kZXNdWzJdIGFuZFxuICAvLyBbYSB3aWRlbHkgY2l0ZWQgcmVwb3J0IG9uIGNyb3NzLWJyb3dzZXIgdGVzdHMgb2Yga2V5IGNvZGVzXVszXSxcbiAgLy8gZXhjZXB0IGZvciAxMDogJ0VudGVyJywgd2hpY2ggSSd2ZSBlbXBpcmljYWxseSBvYnNlcnZlZCBpbiBTYWZhcmkgb24gaU9TXG4gIC8vIGFuZCBkb2Vzbid0IGFwcGVhciB0byBjb25mbGljdCB3aXRoIGFueSBvdGhlciBrbm93biBrZXkgY29kZXMuXG4gIC8vXG4gIC8vIFsxXTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMjA2MTQvI2tleXMta2V5dmFsdWVzXG4gIC8vIFsyXTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMjA2MTQvI2ZpeGVkLXZpcnR1YWwta2V5LWNvZGVzXG4gIC8vIFszXTogaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9rZXkuaHRtbFxuICB2YXIgS0VZX1ZBTFVFUyA9IHtcbiAgICA4OiAnQmFja3NwYWNlJyxcbiAgICA5OiAnVGFiJyxcblxuICAgIDEwOiAnRW50ZXInLCAvLyBmb3IgU2FmYXJpIG9uIGlPU1xuXG4gICAgMTM6ICdFbnRlcicsXG5cbiAgICAxNjogJ1NoaWZ0JyxcbiAgICAxNzogJ0NvbnRyb2wnLFxuICAgIDE4OiAnQWx0JyxcbiAgICAyMDogJ0NhcHNMb2NrJyxcblxuICAgIDI3OiAnRXNjJyxcblxuICAgIDMyOiAnU3BhY2ViYXInLFxuXG4gICAgMzM6ICdQYWdlVXAnLFxuICAgIDM0OiAnUGFnZURvd24nLFxuICAgIDM1OiAnRW5kJyxcbiAgICAzNjogJ0hvbWUnLFxuXG4gICAgMzc6ICdMZWZ0JyxcbiAgICAzODogJ1VwJyxcbiAgICAzOTogJ1JpZ2h0JyxcbiAgICA0MDogJ0Rvd24nLFxuXG4gICAgNDU6ICdJbnNlcnQnLFxuXG4gICAgNDY6ICdEZWwnLFxuXG4gICAgMTQ0OiAnTnVtTG9jaydcbiAgfTtcblxuICAvLyBUbyB0aGUgZXh0ZW50IHBvc3NpYmxlLCBjcmVhdGUgYSBub3JtYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAvLyBvZiB0aGUga2V5IGNvbWJvIChpLmUuLCBrZXkgY29kZSBhbmQgbW9kaWZpZXIga2V5cykuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShldnQpIHtcbiAgICB2YXIgd2hpY2ggPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGU7XG4gICAgdmFyIGtleVZhbCA9IEtFWV9WQUxVRVNbd2hpY2hdO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgaWYgKGV2dC5jdHJsS2V5KSBtb2RpZmllcnMucHVzaCgnQ3RybCcpO1xuICAgIGlmIChldnQub3JpZ2luYWxFdmVudCAmJiBldnQub3JpZ2luYWxFdmVudC5tZXRhS2V5KSBtb2RpZmllcnMucHVzaCgnTWV0YScpO1xuICAgIGlmIChldnQuYWx0S2V5KSBtb2RpZmllcnMucHVzaCgnQWx0Jyk7XG4gICAgaWYgKGV2dC5zaGlmdEtleSkgbW9kaWZpZXJzLnB1c2goJ1NoaWZ0Jyk7XG5cbiAgICBrZXkgPSBrZXlWYWwgfHwgU3RyaW5nLmZyb21DaGFyQ29kZSh3aGljaCk7XG5cbiAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGggJiYgIWtleVZhbCkgcmV0dXJuIGtleTtcblxuICAgIG1vZGlmaWVycy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIG1vZGlmaWVycy5qb2luKCctJyk7XG4gIH1cblxuICAvLyBjcmVhdGUgYSBrZXlib2FyZCBldmVudHMgc2hpbSB0aGF0IGNhbGxzIGNhbGxiYWNrcyBhdCB1c2VmdWwgdGltZXNcbiAgLy8gYW5kIGV4cG9ydHMgdXNlZnVsIHB1YmxpYyBtZXRob2RzXG4gIHJldHVybiBmdW5jdGlvbiBzYW5lS2V5Ym9hcmRFdmVudHMoZWwsIGhhbmRsZXJzKSB7XG4gICAgdmFyIGtleWRvd24gPSBudWxsO1xuICAgIHZhciBrZXlwcmVzcyA9IG51bGw7XG5cbiAgICB2YXIgdGV4dGFyZWEgPSBqUXVlcnkoZWwpO1xuICAgIHZhciB0YXJnZXQgPSBqUXVlcnkoaGFuZGxlcnMuY29udGFpbmVyIHx8IHRleHRhcmVhKTtcblxuICAgIC8vIGNoZWNrVGV4dGFyZWFGb3IoKSBpcyBjYWxsZWQgYWZ0ZXIga2V5cHJlc3Mgb3IgcGFzdGUgZXZlbnRzIHRvXG4gICAgLy8gc2F5IFwiSGV5LCBJIHRoaW5rIHNvbWV0aGluZyB3YXMganVzdCB0eXBlZFwiIG9yIFwicGFzdGVkXCIgKHJlc3AuKSxcbiAgICAvLyBzbyB0aGF0IGF0IGFsbCBzdWJzZXF1ZW50IG9wcG9ydHVuZSB0aW1lcyAobmV4dCBldmVudCBvciB0aW1lb3V0KSxcbiAgICAvLyB3aWxsIGNoZWNrIGZvciBleHBlY3RlZCB0eXBlZCBvciBwYXN0ZWQgdGV4dC5cbiAgICAvLyBOZWVkIHRvIGNoZWNrIHJlcGVhdGVkbHkgYmVjYXVzZSAjMTM1OiBpbiBTYWZhcmkgNS4xIChhdCBsZWFzdCksXG4gICAgLy8gYWZ0ZXIgc2VsZWN0aW5nIHNvbWV0aGluZyBhbmQgdGhlbiB0eXBpbmcsIHRoZSB0ZXh0YXJlYSBpc1xuICAgIC8vIGluY29ycmVjdGx5IHJlcG9ydGVkIGFzIHNlbGVjdGVkIGR1cmluZyB0aGUgaW5wdXQgZXZlbnQgKGJ1dCBub3RcbiAgICAvLyBzdWJzZXF1ZW50bHkpLlxuICAgIHZhciBjaGVja1RleHRhcmVhID0gbm9vcCwgdGltZW91dElkO1xuICAgIGZ1bmN0aW9uIGNoZWNrVGV4dGFyZWFGb3IoY2hlY2tlcikge1xuICAgICAgY2hlY2tUZXh0YXJlYSA9IGNoZWNrZXI7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoY2hlY2tlcik7XG4gICAgfVxuICAgIHRhcmdldC5iaW5kKCdrZXlkb3duIGtleXByZXNzIGlucHV0IGtleXVwIGZvY3Vzb3V0IHBhc3RlJywgZnVuY3Rpb24oZSkgeyBjaGVja1RleHRhcmVhKGUpOyB9KTtcblxuXG4gICAgLy8gLSotIHB1YmxpYyBtZXRob2RzIC0qLSAvL1xuICAgIGZ1bmN0aW9uIHNlbGVjdCh0ZXh0KSB7XG4gICAgICAvLyBjaGVjayB0ZXh0YXJlYSBhdCBsZWFzdCBvbmNlL29uZSBsYXN0IHRpbWUgYmVmb3JlIG11bmdpbmcgKHNvXG4gICAgICAvLyBubyByYWNlIGNvbmRpdGlvbiBpZiBzZWxlY3Rpb24gaGFwcGVucyBhZnRlciBrZXlwcmVzcy9wYXN0ZSBidXRcbiAgICAgIC8vIGJlZm9yZSBjaGVja1RleHRhcmVhKSwgdGhlbiBuZXZlciBhZ2FpbiAoJ2NvcyBpdCdzIGJlZW4gbXVuZ2VkKVxuICAgICAgY2hlY2tUZXh0YXJlYSgpO1xuICAgICAgY2hlY2tUZXh0YXJlYSA9IG5vb3A7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgdGV4dGFyZWEudmFsKHRleHQpO1xuICAgICAgaWYgKHRleHQgJiYgdGV4dGFyZWFbMF0uc2VsZWN0KSB0ZXh0YXJlYVswXS5zZWxlY3QoKTtcbiAgICAgIHNob3VsZEJlU2VsZWN0ZWQgPSAhIXRleHQ7XG4gICAgfVxuICAgIHZhciBzaG91bGRCZVNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAvLyAtKi0gaGVscGVyIHN1YnJvdXRpbmVzIC0qLSAvL1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmUncyBhIHNlbGVjdGlvbiBpbiB0aGUgdGV4dGFyZWEuXG4gICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UgaW4gSUUgPCA5LCB3aGljaCBkb24ndCBzdXBwb3J0XG4gICAgLy8gSFRNTFRleHRhcmVhRWxlbWVudDo6c2VsZWN0aW9ue1N0YXJ0LEVuZH0uXG4gICAgZnVuY3Rpb24gaGFzU2VsZWN0aW9uKCkge1xuICAgICAgdmFyIGRvbSA9IHRleHRhcmVhWzBdO1xuXG4gICAgICBpZiAoISgnc2VsZWN0aW9uU3RhcnQnIGluIGRvbSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBkb20uc2VsZWN0aW9uU3RhcnQgIT09IGRvbS5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5KCkge1xuICAgICAgaGFuZGxlcnMua2V5c3Ryb2tlKHN0cmluZ2lmeShrZXlkb3duKSwga2V5ZG93bik7XG4gICAgfVxuXG4gICAgLy8gLSotIGV2ZW50IGhhbmRsZXJzIC0qLSAvL1xuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bihlKSB7XG4gICAgICBrZXlkb3duID0gZTtcbiAgICAgIGtleXByZXNzID0gbnVsbDtcblxuICAgICAgaWYgKHNob3VsZEJlU2VsZWN0ZWQpIGNoZWNrVGV4dGFyZWFGb3IoZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIShlICYmIGUudHlwZSA9PT0gJ2ZvY3Vzb3V0JykgJiYgdGV4dGFyZWFbMF0uc2VsZWN0KSB7XG4gICAgICAgICAgdGV4dGFyZWFbMF0uc2VsZWN0KCk7IC8vIHJlLXNlbGVjdCB0ZXh0YXJlYSBpbiBjYXNlIGl0J3MgYW4gdW5yZWNvZ25pemVkXG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tUZXh0YXJlYSA9IG5vb3A7IC8vIGtleSB0aGF0IGNsZWFycyB0aGUgc2VsZWN0aW9uLCB0aGVuIG5ldmVyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpOyAvLyBhZ2FpbiwgJ2NvcyBuZXh0IHRoaW5nIG1pZ2h0IGJlIGJsdXJcbiAgICAgIH0pO1xuXG4gICAgICBoYW5kbGVLZXkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbktleXByZXNzKGUpIHtcbiAgICAgIC8vIGNhbGwgdGhlIGtleSBoYW5kbGVyIGZvciByZXBlYXRlZCBrZXlwcmVzc2VzLlxuICAgICAgLy8gVGhpcyBleGNsdWRlcyBrZXlwcmVzc2VzIHRoYXQgaGFwcGVuIGRpcmVjdGx5XG4gICAgICAvLyBhZnRlciBrZXlkb3duLiAgSW4gdGhhdCBjYXNlLCB0aGVyZSB3aWxsIGJlXG4gICAgICAvLyBubyBwcmV2aW91cyBrZXlwcmVzcywgc28gd2Ugc2tpcCBpdCBoZXJlXG4gICAgICBpZiAoa2V5ZG93biAmJiBrZXlwcmVzcykgaGFuZGxlS2V5KCk7XG5cbiAgICAgIGtleXByZXNzID0gZTtcblxuICAgICAgY2hlY2tUZXh0YXJlYUZvcih0eXBlZFRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZFRleHQoKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiwgdGhlIGNvbnRlbnRzIG9mIHRoZSB0ZXh0YXJlYSBjb3VsZG4ndFxuICAgICAgLy8gcG9zc2libHkgaGF2ZSBqdXN0IGJlZW4gdHlwZWQgaW4uXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFuZCBPcGVyYSB0aGF0IGZpcmVcbiAgICAgIC8vIGtleXByZXNzIGZvciBrZXlzdHJva2VzIHRoYXQgYXJlIG5vdCB0ZXh0IGVudHJ5IGFuZCBsZWF2ZSB0aGVcbiAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgdGV4dGFyZWEgYWxvbmUsIHN1Y2ggYXMgQ3RybC1DLlxuICAgICAgLy8gTm90ZTogd2UgYXNzdW1lIHRoYXQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGhhc1NlbGVjdGlvbigpXG4gICAgICAvLyBhbHNvIG5ldmVyIGZpcmUga2V5cHJlc3Mgb24ga2V5c3Ryb2tlcyB0aGF0IGFyZSBub3QgdGV4dCBlbnRyeS5cbiAgICAgIC8vIFRoaXMgc2VlbXMgcmVhc29uYWJseSBzYWZlIGJlY2F1c2U6XG4gICAgICAvLyAtIGFsbCBtb2Rlcm4gYnJvd3NlcnMgaW5jbHVkaW5nIElFIDkrIHN1cHBvcnQgaGFzU2VsZWN0aW9uKCksXG4gICAgICAvLyAgIG1ha2luZyBpdCBleHRyZW1lbHkgdW5saWtlbHkgYW55IGJyb3dzZXIgYmVzaWRlcyBJRSA8IDkgd29uJ3RcbiAgICAgIC8vIC0gYXMgZmFyIGFzIHdlIGtub3cgSUUgPCA5IG5ldmVyIGZpcmVzIGtleXByZXNzIG9uIGtleXN0cm9rZXNcbiAgICAgIC8vICAgdGhhdCBhcmVuJ3QgdGV4dCBlbnRyeSwgd2hpY2ggaXMgb25seSBhcyByZWxpYWJsZSBhcyBvdXJcbiAgICAgIC8vICAgdGVzdHMgYXJlIGNvbXByZWhlbnNpdmUsIGJ1dCB0aGUgSUUgPCA5IHdheSB0byBkb1xuICAgICAgLy8gICBoYXNTZWxlY3Rpb24oKSBpcyBwb29ybHkgZG9jdW1lbnRlZCBhbmQgaXMgYWxzbyBvbmx5IGFzXG4gICAgICAvLyAgIHJlbGlhYmxlIGFzIG91ciB0ZXN0cyBhcmUgY29tcHJlaGVuc2l2ZVxuICAgICAgLy8gSWYgYW55dGhpbmcgbGlrZSAjNDAgb3IgIzcxIGlzIHJlcG9ydGVkIGluIElFIDwgOSwgc2VlXG4gICAgICAvLyBiMTMxOGU1MzQ5MTYwYjY2NTAwM2UzNmQ0ZWVkZDY0MTAxY2VhY2Q4XG4gICAgICBpZiAoaGFzU2VsZWN0aW9uKCkpIHJldHVybjtcblxuICAgICAgdmFyIHRleHQgPSB0ZXh0YXJlYS52YWwoKTtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0ZXh0YXJlYS52YWwoJycpO1xuICAgICAgICBoYW5kbGVycy50eXBlZFRleHQodGV4dCk7XG4gICAgICB9IC8vIGluIEZpcmVmb3gsIGtleXMgdGhhdCBkb24ndCB0eXBlIHRleHQsIGp1c3QgY2xlYXIgc2VsbiwgZmlyZSBrZXlwcmVzc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvaXNzdWVzLzI5MyNpc3N1ZWNvbW1lbnQtNDA5OTc2NjhcbiAgICAgIGVsc2UgaWYgKHRleHQgJiYgdGV4dGFyZWFbMF0uc2VsZWN0KSB0ZXh0YXJlYVswXS5zZWxlY3QoKTsgLy8gcmUtc2VsZWN0IGlmIHRoYXQncyB3aHkgd2UncmUgaGVyZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHsga2V5ZG93biA9IGtleXByZXNzID0gbnVsbDsgfVxuXG4gICAgZnVuY3Rpb24gb25QYXN0ZShlKSB7XG4gICAgICAvLyBicm93c2VycyBhcmUgZHVtYi5cbiAgICAgIC8vXG4gICAgICAvLyBJbiBMaW51eCwgbWlkZGxlLWNsaWNrIHBhc3RpbmcgY2F1c2VzIG9uUGFzdGUgdG8gYmUgY2FsbGVkLFxuICAgICAgLy8gd2hlbiB0aGUgdGV4dGFyZWEgaXMgbm90IG5lY2Vzc2FyaWx5IGZvY3VzZWQuICBXZSBmb2N1cyBpdFxuICAgICAgLy8gaGVyZSB0byBlbnN1cmUgdGhhdCB0aGUgcGFzdGVkIHRleHQgYWN0dWFsbHkgZW5kcyB1cCBpbiB0aGVcbiAgICAgIC8vIHRleHRhcmVhLlxuICAgICAgLy9cbiAgICAgIC8vIEl0J3MgcHJldHR5IG5pZnR5IHRoYXQgYnkgY2hhbmdpbmcgZm9jdXMgaW4gdGhpcyBoYW5kbGVyLFxuICAgICAgLy8gd2UgY2FuIGNoYW5nZSB0aGUgdGFyZ2V0IG9mIHRoZSBkZWZhdWx0IGFjdGlvbi4gIChUaGlzIHdvcmtzXG4gICAgICAvLyBvbiBrZXlkb3duIHRvbywgRldJVykuXG4gICAgICAvL1xuICAgICAgLy8gQW5kIGJ5IG5pZnR5LCB3ZSBtZWFuIGR1bWIgKGJ1dCB1c2VmdWwgc29tZXRpbWVzKS5cbiAgICAgIHRleHRhcmVhLmZvY3VzKCk7XG5cbiAgICAgIGNoZWNrVGV4dGFyZWFGb3IocGFzdGVkVGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhc3RlZFRleHQoKSB7XG4gICAgICB2YXIgdGV4dCA9IHRleHRhcmVhLnZhbCgpO1xuICAgICAgdGV4dGFyZWEudmFsKCcnKTtcbiAgICAgIGlmICh0ZXh0KSBoYW5kbGVycy5wYXN0ZSh0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyAtKi0gYXR0YWNoIGV2ZW50IGhhbmRsZXJzIC0qLSAvL1xuICAgIHRhcmdldC5iaW5kKHtcbiAgICAgIGtleWRvd246IG9uS2V5ZG93bixcbiAgICAgIGtleXByZXNzOiBvbktleXByZXNzLFxuICAgICAgZm9jdXNvdXQ6IG9uQmx1cixcbiAgICAgIHBhc3RlOiBvblBhc3RlXG4gICAgfSk7XG5cbiAgICAvLyAtKi0gZXhwb3J0IHB1YmxpYyBtZXRob2RzIC0qLSAvL1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3Q6IHNlbGVjdFxuICAgIH07XG4gIH07XG59KCkpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnQgbWF0aCBpbiBhIGh1bWFuLXJlYWRhYmxlIHRleHQgZm9ybWF0XG4gKiBBcyB5b3UgY2FuIHNlZSwgb25seSBoYWxmLWJha2VkIHNvIGZhci5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5Db250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uZXhwb3J0VGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZm9sZENoaWxkcmVuKCcnLCBmdW5jdGlvbih0ZXh0LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHRleHQgKyBjaGlsZC50ZXh0KCk7XG4gICAgfSk7XG4gIH07XG59KTtcbkNvbnRyb2xsZXIub3BlbihmdW5jdGlvbihfKSB7XG4gIF8uZm9jdXNCbHVyRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0cmxyID0gdGhpcywgcm9vdCA9IGN0cmxyLnJvb3QsIGN1cnNvciA9IGN0cmxyLmN1cnNvcjtcbiAgICB2YXIgYmx1clRpbWVvdXQ7XG4gICAgY3RybHIudGV4dGFyZWEuZm9jdXMoZnVuY3Rpb24oKSB7XG4gICAgICBjdHJsci5ibHVycmVkID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQoYmx1clRpbWVvdXQpO1xuICAgICAgY3RybHIuY29udGFpbmVyLmFkZENsYXNzKCdtcS1mb2N1c2VkJyk7XG4gICAgICBpZiAoIWN1cnNvci5wYXJlbnQpXG4gICAgICAgIGN1cnNvci5pbnNBdFJpZ2h0RW5kKHJvb3QpO1xuICAgICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY3Vyc29yLnNlbGVjdGlvbi5qUS5yZW1vdmVDbGFzcygnbXEtYmx1cicpO1xuICAgICAgICBjdHJsci5zZWxlY3Rpb25DaGFuZ2VkKCk7IC8vcmUtc2VsZWN0IHRleHRhcmVhIGNvbnRlbnRzIGFmdGVyIHRhYmJpbmcgYXdheSBhbmQgYmFja1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBjdXJzb3Iuc2hvdygpO1xuICAgIH0pLmJsdXIoZnVuY3Rpb24oKSB7XG4gICAgICBjdHJsci5ibHVycmVkID0gdHJ1ZTtcbiAgICAgIGJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgLy8gd2FpdCBmb3IgYmx1ciBvbiB3aW5kb3c7IGlmXG4gICAgICAgIHJvb3QucG9zdE9yZGVyKCdpbnRlbnRpb25hbEJsdXInKTsgLy8gbm9uZSwgaW50ZW50aW9uYWwgYmx1cjogIzI2NFxuICAgICAgICBjdXJzb3IuY2xlYXJTZWxlY3Rpb24oKS5lbmRTZWxlY3Rpb24oKTtcbiAgICAgICAgYmx1cigpO1xuICAgICAgfSk7XG4gICAgICAkKHdpbmRvdykub24oJ2JsdXInLCB3aW5kb3dCbHVyKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiB3aW5kb3dCbHVyKCkgeyAvLyBibHVyIGV2ZW50IGFsc28gZmlyZWQgb24gd2luZG93LCBqdXN0IHN3aXRjaGluZ1xuICAgICAgY2xlYXJUaW1lb3V0KGJsdXJUaW1lb3V0KTsgLy8gdGFicy93aW5kb3dzLCBub3QgaW50ZW50aW9uYWwgYmx1clxuICAgICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIGN1cnNvci5zZWxlY3Rpb24ualEuYWRkQ2xhc3MoJ21xLWJsdXInKTtcbiAgICAgIGJsdXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmx1cigpIHsgLy8gbm90IGRpcmVjdGx5IGluIHRoZSB0ZXh0YXJlYSBibHVyIGhhbmRsZXIgc28gYXMgdG8gYmVcbiAgICAgIGN1cnNvci5oaWRlKCkucGFyZW50LmJsdXIoKTsgLy8gc3luY2hyb25vdXMgd2l0aC9pbiB0aGUgc2FtZSBmcmFtZSBhc1xuICAgICAgY3RybHIuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdtcS1mb2N1c2VkJyk7IC8vIGNsZWFyaW5nL2JsdXJyaW5nIHNlbGVjdGlvblxuICAgICAgJCh3aW5kb3cpLm9mZignYmx1cicsIHdpbmRvd0JsdXIpO1xuICAgIH1cbiAgICBjdHJsci5ibHVycmVkID0gdHJ1ZTtcbiAgICBjdXJzb3IuaGlkZSgpLnBhcmVudC5ibHVyKCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBUT0RPOiBJIHdhbnRlZCB0byBtb3ZlIE1hdGhCbG9jazo6Zm9jdXMgYW5kIGJsdXIgaGVyZSwgaXQgd291bGQgY2xlYW5cbiAqIHVwIGxvdHMgb2Ygc3R1ZmYgbGlrZSwgVGV4dEJsb2NrOjpmb2N1cyBpcyBzZXQgdG8gTWF0aEJsb2NrOjpmb2N1c1xuICogYW5kIFRleHRCbG9jazo6Ymx1ciBjYWxscyBNYXRoQmxvY2s6OmJsdXIsIHdoZW4gaW5zdGVhZCB0aGV5IGNvdWxkXG4gKiB1c2UgaW5oZXJpdGFuY2UgYW5kIHN1cGVyXy5cbiAqXG4gKiBQcm9ibGVtIGlzLCB0aGVyZSdzIGxvdHMgb2YgY2FsbHMgdG8gLmZvY3VzKCkvLmJsdXIoKSBvbiBub2Rlc1xuICogb3V0c2lkZSBDb250cm9sbGVyOjpmb2N1c0JsdXJFdmVudHMoKSwgc3VjaCBhcyAucG9zdE9yZGVyKCdibHVyJykgb25cbiAqIGluc2VydGlvbiwgd2hpY2ggaWYgTWF0aEJsb2NrOjpibHVyIGJlY29tZXMgTm9kZTo6Ymx1ciwgd291bGQgYWRkIHRoZVxuICogJ2JsdXInIENTUyBjbGFzcyB0byBhbGwgU3ltYm9sJ3MgKGJlY2F1c2UgLmlzRW1wdHkoKSBpcyB0cnVlIGZvciBhbGxcbiAqIG9mIHRoZW0pLlxuICpcbiAqIEknbSBub3QgZXZlbiBzdXJlIHRoZXJlIGFyZW4ndCBvdGhlciB0cm91Ymxlc29tZSBjYWxscyB0byAuZm9jdXMoKSBvclxuICogLmJsdXIoKSwgc28gdGhpcyBpcyBUT0RPIGZvciBub3cuXG4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRGVhbHMgd2l0aCB0aGUgYnJvd3NlciBET00gZXZlbnRzIGZyb21cbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHR5cGlzdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5Db250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXykge1xuICBfLmtleXN0cm9rZSA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgdGhpcy5jdXJzb3IucGFyZW50LmtleXN0cm9rZShrZXksIGV2dCwgdGhpcyk7XG4gIH07XG59KTtcblxuTm9kZS5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgXy5rZXlzdHJva2UgPSBmdW5jdGlvbihrZXksIGUsIGN0cmxyKSB7XG4gICAgdmFyIGN1cnNvciA9IGN0cmxyLmN1cnNvcjtcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnQ3RybC1TaGlmdC1CYWNrc3BhY2UnOlxuICAgIGNhc2UgJ0N0cmwtQmFja3NwYWNlJzpcbiAgICAgIGN0cmxyLmN0cmxEZWxldGVEaXIoTCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1NoaWZ0LUJhY2tzcGFjZSc6XG4gICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgIGN0cmxyLmJhY2tzcGFjZSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBUYWIgb3IgRXNjIC0+IGdvIG9uZSBibG9jayByaWdodCBpZiBpdCBleGlzdHMsIGVsc2UgZXNjYXBlIHJpZ2h0LlxuICAgIGNhc2UgJ0VzYyc6XG4gICAgY2FzZSAnVGFiJzpcbiAgICAgIGN0cmxyLmVzY2FwZURpcihSLCBrZXksIGUpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgLy8gU2hpZnQtVGFiIC0+IGdvIG9uZSBibG9jayBsZWZ0IGlmIGl0IGV4aXN0cywgZWxzZSBlc2NhcGUgbGVmdC5cbiAgICBjYXNlICdTaGlmdC1UYWInOlxuICAgIGNhc2UgJ1NoaWZ0LUVzYyc6XG4gICAgICBjdHJsci5lc2NhcGVEaXIoTCwga2V5LCBlKTtcbiAgICAgIHJldHVybjtcblxuICAgIC8vIEVuZCAtPiBtb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgY2FzZSAnRW5kJzpcbiAgICAgIGN0cmxyLm5vdGlmeSgnbW92ZScpLmN1cnNvci5pbnNBdFJpZ2h0RW5kKGN1cnNvci5wYXJlbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDdHJsLUVuZCAtPiBtb3ZlIGFsbCB0aGUgd2F5IHRvIHRoZSBlbmQgb2YgdGhlIHJvb3QgYmxvY2suXG4gICAgY2FzZSAnQ3RybC1FbmQnOlxuICAgICAgY3RybHIubm90aWZ5KCdtb3ZlJykuY3Vyc29yLmluc0F0UmlnaHRFbmQoY3RybHIucm9vdCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIFNoaWZ0LUVuZCAtPiBzZWxlY3QgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBibG9jay5cbiAgICBjYXNlICdTaGlmdC1FbmQnOlxuICAgICAgd2hpbGUgKGN1cnNvcltSXSkge1xuICAgICAgICBjdHJsci5zZWxlY3RSaWdodCgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDdHJsLVNoaWZ0LUVuZCAtPiBzZWxlY3QgdG8gdGhlIGVuZCBvZiB0aGUgcm9vdCBibG9jay5cbiAgICBjYXNlICdDdHJsLVNoaWZ0LUVuZCc6XG4gICAgICB3aGlsZSAoY3Vyc29yW1JdIHx8IGN1cnNvci5wYXJlbnQgIT09IGN0cmxyLnJvb3QpIHtcbiAgICAgICAgY3RybHIuc2VsZWN0UmlnaHQoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gSG9tZSAtPiBtb3ZlIHRvIHRoZSBzdGFydCBvZiB0aGUgcm9vdCBibG9jayBvciB0aGUgY3VycmVudCBibG9jay5cbiAgICBjYXNlICdIb21lJzpcbiAgICAgIGN0cmxyLm5vdGlmeSgnbW92ZScpLmN1cnNvci5pbnNBdExlZnRFbmQoY3Vyc29yLnBhcmVudCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIEN0cmwtSG9tZSAtPiBtb3ZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBibG9jay5cbiAgICBjYXNlICdDdHJsLUhvbWUnOlxuICAgICAgY3RybHIubm90aWZ5KCdtb3ZlJykuY3Vyc29yLmluc0F0TGVmdEVuZChjdHJsci5yb290KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gU2hpZnQtSG9tZSAtPiBzZWxlY3QgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgIGNhc2UgJ1NoaWZ0LUhvbWUnOlxuICAgICAgd2hpbGUgKGN1cnNvcltMXSkge1xuICAgICAgICBjdHJsci5zZWxlY3RMZWZ0KCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIC8vIEN0cmwtU2hpZnQtSG9tZSAtPiBtb3ZlIHRvIHRoZSBzdGFydCBvZiB0aGUgcm9vdCBibG9jay5cbiAgICBjYXNlICdDdHJsLVNoaWZ0LUhvbWUnOlxuICAgICAgd2hpbGUgKGN1cnNvcltMXSB8fCBjdXJzb3IucGFyZW50ICE9PSBjdHJsci5yb290KSB7XG4gICAgICAgIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTGVmdCc6IGN0cmxyLm1vdmVMZWZ0KCk7IGJyZWFrO1xuICAgIGNhc2UgJ1NoaWZ0LUxlZnQnOiBjdHJsci5zZWxlY3RMZWZ0KCk7IGJyZWFrO1xuICAgIGNhc2UgJ0N0cmwtTGVmdCc6IGJyZWFrO1xuXG4gICAgY2FzZSAnUmlnaHQnOiBjdHJsci5tb3ZlUmlnaHQoKTsgYnJlYWs7XG4gICAgY2FzZSAnU2hpZnQtUmlnaHQnOiBjdHJsci5zZWxlY3RSaWdodCgpOyBicmVhaztcbiAgICBjYXNlICdDdHJsLVJpZ2h0JzogYnJlYWs7XG5cbiAgICBjYXNlICdVcCc6IGN0cmxyLm1vdmVVcCgpOyBicmVhaztcbiAgICBjYXNlICdEb3duJzogY3RybHIubW92ZURvd24oKTsgYnJlYWs7XG5cbiAgICBjYXNlICdTaGlmdC1VcCc6XG4gICAgICBpZiAoY3Vyc29yW0xdKSB7XG4gICAgICAgIHdoaWxlIChjdXJzb3JbTF0pIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ1NoaWZ0LURvd24nOlxuICAgICAgaWYgKGN1cnNvcltSXSkge1xuICAgICAgICB3aGlsZSAoY3Vyc29yW1JdKSBjdHJsci5zZWxlY3RSaWdodCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0cmxyLnNlbGVjdFJpZ2h0KCk7XG4gICAgICB9XG5cbiAgICBjYXNlICdDdHJsLVVwJzogYnJlYWs7XG4gICAgY2FzZSAnQ3RybC1Eb3duJzogYnJlYWs7XG5cbiAgICBjYXNlICdDdHJsLVNoaWZ0LURlbCc6XG4gICAgY2FzZSAnQ3RybC1EZWwnOlxuICAgICAgY3RybHIuY3RybERlbGV0ZURpcihSKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnU2hpZnQtRGVsJzpcbiAgICBjYXNlICdEZWwnOlxuICAgICAgY3RybHIuZGVsZXRlRm9yd2FyZCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdNZXRhLUEnOlxuICAgIGNhc2UgJ0N0cmwtQSc6XG4gICAgICBjdHJsci5ub3RpZnkoJ21vdmUnKS5jdXJzb3IuaW5zQXRSaWdodEVuZChjdHJsci5yb290KTtcbiAgICAgIHdoaWxlIChjdXJzb3JbTF0pIGN0cmxyLnNlbGVjdExlZnQoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGN0cmxyLnNjcm9sbEhvcml6KCk7XG4gIH07XG5cbiAgXy5tb3ZlT3V0T2YgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6ZXNjYXBlRGlyLCBtb3ZlRGlyXG4gIF8ubW92ZVRvd2FyZHMgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6bW92ZURpclxuICBfLmRlbGV0ZU91dE9mID0gLy8gY2FsbGVkIGJ5IENvbnRyb2xsZXI6OmRlbGV0ZURpclxuICBfLmRlbGV0ZVRvd2FyZHMgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6ZGVsZXRlRGlyXG4gIF8udW5zZWxlY3RJbnRvID0gLy8gY2FsbGVkIGJ5IENvbnRyb2xsZXI6OnNlbGVjdERpclxuICBfLnNlbGVjdE91dE9mID0gLy8gY2FsbGVkIGJ5IENvbnRyb2xsZXI6OnNlbGVjdERpclxuICBfLnNlbGVjdFRvd2FyZHMgPSAvLyBjYWxsZWQgYnkgQ29udHJvbGxlcjo6c2VsZWN0RGlyXG4gICAgZnVuY3Rpb24oKSB7IHByYXkoJ292ZXJyaWRkZW4gb3IgbmV2ZXIgY2FsbGVkIG9uIHRoaXMgbm9kZScpOyB9O1xufSk7XG5cbkNvbnRyb2xsZXIub3BlbihmdW5jdGlvbihfKSB7XG4gIHRoaXMub25Ob3RpZnkoZnVuY3Rpb24oZSkge1xuICAgIGlmIChlID09PSAnbW92ZScgfHwgZSA9PT0gJ3VwRG93bicpIHRoaXMuc2hvdygpLmNsZWFyU2VsZWN0aW9uKCk7XG4gIH0pO1xuICBfLmVzY2FwZURpciA9IGZ1bmN0aW9uKGRpciwga2V5LCBlKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmN1cnNvcjtcblxuICAgIC8vIG9ubHkgcHJldmVudCBkZWZhdWx0IG9mIFRhYiBpZiBub3QgaW4gdGhlIHJvb3QgZWRpdGFibGVcbiAgICBpZiAoY3Vyc29yLnBhcmVudCAhPT0gdGhpcy5yb290KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyB3YW50IHRvIGJlIGEgbm9vcCBpZiBpbiB0aGUgcm9vdCBlZGl0YWJsZSAoaW4gZmFjdCwgVGFiIGhhcyBhbiB1bnJlbGF0ZWRcbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uIGlmIHNvKVxuICAgIGlmIChjdXJzb3IucGFyZW50ID09PSB0aGlzLnJvb3QpIHJldHVybjtcblxuICAgIGN1cnNvci5wYXJlbnQubW92ZU91dE9mKGRpciwgY3Vyc29yKTtcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoJ21vdmUnKTtcbiAgfTtcblxuICBvcHRpb25Qcm9jZXNzb3JzLmxlZnRSaWdodEludG9DbWRHb2VzID0gZnVuY3Rpb24odXBkb3duKSB7XG4gICAgaWYgKHVwZG93biAmJiB1cGRvd24gIT09ICd1cCcgJiYgdXBkb3duICE9PSAnZG93bicpIHtcbiAgICAgIHRocm93ICdcInVwXCIgb3IgXCJkb3duXCIgcmVxdWlyZWQgZm9yIGxlZnRSaWdodEludG9DbWRHb2VzIG9wdGlvbiwgJ1xuICAgICAgICAgICAgKyAnZ290IFwiJyt1cGRvd24rJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuIHVwZG93bjtcbiAgfTtcbiAgXy5tb3ZlRGlyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmN1cnNvciwgdXBkb3duID0gY3Vyc29yLm9wdGlvbnMubGVmdFJpZ2h0SW50b0NtZEdvZXM7XG5cbiAgICBpZiAoY3Vyc29yLnNlbGVjdGlvbikge1xuICAgICAgY3Vyc29yLmluc0Rpck9mKGRpciwgY3Vyc29yLnNlbGVjdGlvbi5lbmRzW2Rpcl0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJzb3JbZGlyXSkgY3Vyc29yW2Rpcl0ubW92ZVRvd2FyZHMoZGlyLCBjdXJzb3IsIHVwZG93bik7XG4gICAgZWxzZSBjdXJzb3IucGFyZW50Lm1vdmVPdXRPZihkaXIsIGN1cnNvciwgdXBkb3duKTtcblxuICAgIHJldHVybiB0aGlzLm5vdGlmeSgnbW92ZScpO1xuICB9O1xuICBfLm1vdmVMZWZ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1vdmVEaXIoTCk7IH07XG4gIF8ubW92ZVJpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1vdmVEaXIoUik7IH07XG5cbiAgLyoqXG4gICAqIG1vdmVVcCBhbmQgbW92ZURvd24gaGF2ZSBhbG1vc3QgaWRlbnRpY2FsIGFsZ29yaXRobXM6XG4gICAqIC0gZmlyc3QgY2hlY2sgbGVmdCBhbmQgcmlnaHQsIGlmIHNvIGluc0F0TGVmdC9SaWdodEVuZCBvZiB0aGVtXG4gICAqIC0gZWxzZSBjaGVjayB0aGUgcGFyZW50J3MgJ3VwT3V0T2YnLydkb3duT3V0T2YnIHByb3BlcnR5OlxuICAgKiAgICsgaWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0IHdpdGggdGhlIGN1cnNvciBhcyB0aGUgc29sZSBhcmd1bWVudCBhbmRcbiAgICogICAgIHVzZSB0aGUgcmV0dXJuIHZhbHVlIGFzIGlmIGl0IHdlcmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiAgICsgaWYgaXQncyBhIE5vZGUsIGp1bXAgdXAgb3IgZG93biBpbnRvIGl0OlxuICAgKiAgICAgLSBpZiB0aGVyZSBpcyBhIGNhY2hlZCBQb2ludCBpbiB0aGUgYmxvY2ssIGluc2VydCB0aGVyZVxuICAgKiAgICAgLSBlbHNlLCBzZWVrSG9yaXogd2l0aGluIHRoZSBibG9jayB0byB0aGUgY3VycmVudCB4LWNvb3JkaW5hdGUgKHRvIGJlXG4gICAqICAgICAgIGFzIGNsb3NlIHRvIGRpcmVjdGx5IGFib3ZlL2JlbG93IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFzIHBvc3NpYmxlKVxuICAgKiAgICsgdW5sZXNzIGl0J3MgZXhhY3RseSBgdHJ1ZWAsIHN0b3AgYnViYmxpbmdcbiAgICovXG4gIF8ubW92ZVVwID0gZnVuY3Rpb24oKSB7IHJldHVybiBtb3ZlVXBEb3duKHRoaXMsICd1cCcpOyB9O1xuICBfLm1vdmVEb3duID0gZnVuY3Rpb24oKSB7IHJldHVybiBtb3ZlVXBEb3duKHRoaXMsICdkb3duJyk7IH07XG4gIGZ1bmN0aW9uIG1vdmVVcERvd24oc2VsZiwgZGlyKSB7XG4gICAgdmFyIGN1cnNvciA9IHNlbGYubm90aWZ5KCd1cERvd24nKS5jdXJzb3I7XG4gICAgdmFyIGRpckludG8gPSBkaXIrJ0ludG8nLCBkaXJPdXRPZiA9IGRpcisnT3V0T2YnO1xuICAgIGlmIChjdXJzb3JbUl1bZGlySW50b10pIGN1cnNvci5pbnNBdExlZnRFbmQoY3Vyc29yW1JdW2RpckludG9dKTtcbiAgICBlbHNlIGlmIChjdXJzb3JbTF1bZGlySW50b10pIGN1cnNvci5pbnNBdFJpZ2h0RW5kKGN1cnNvcltMXVtkaXJJbnRvXSk7XG4gICAgZWxzZSB7XG4gICAgICBjdXJzb3IucGFyZW50LmJ1YmJsZShmdW5jdGlvbihhbmNlc3Rvcikge1xuICAgICAgICB2YXIgcHJvcCA9IGFuY2VzdG9yW2Rpck91dE9mXTtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHByb3AgPSBhbmNlc3RvcltkaXJPdXRPZl0oY3Vyc29yKTtcbiAgICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIE5vZGUpIGN1cnNvci5qdW1wVXBEb3duKGFuY2VzdG9yLCBwcm9wKTtcbiAgICAgICAgICBpZiAocHJvcCAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdGhpcy5vbk5vdGlmeShmdW5jdGlvbihlKSB7IGlmIChlICE9PSAndXBEb3duJykgdGhpcy51cERvd25DYWNoZSA9IHt9OyB9KTtcblxuICB0aGlzLm9uTm90aWZ5KGZ1bmN0aW9uKGUpIHsgaWYgKGUgPT09ICdlZGl0JykgdGhpcy5zaG93KCkuZGVsZXRlU2VsZWN0aW9uKCk7IH0pO1xuICBfLmRlbGV0ZURpciA9IGZ1bmN0aW9uKGRpcikge1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcbiAgICB2YXIgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICB2YXIgaGFkU2VsZWN0aW9uID0gY3Vyc29yLnNlbGVjdGlvbjtcbiAgICB0aGlzLm5vdGlmeSgnZWRpdCcpOyAvLyBkZWxldGVzIHNlbGVjdGlvbiBpZiBwcmVzZW50XG4gICAgaWYgKCFoYWRTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChjdXJzb3JbZGlyXSkgY3Vyc29yW2Rpcl0uZGVsZXRlVG93YXJkcyhkaXIsIGN1cnNvcik7XG4gICAgICBlbHNlIGN1cnNvci5wYXJlbnQuZGVsZXRlT3V0T2YoZGlyLCBjdXJzb3IpO1xuICAgIH1cblxuICAgIGlmIChjdXJzb3JbTF0uc2libGluZ0RlbGV0ZWQpIGN1cnNvcltMXS5zaWJsaW5nRGVsZXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgaWYgKGN1cnNvcltSXS5zaWJsaW5nRGVsZXRlZCkgY3Vyc29yW1JdLnNpYmxpbmdEZWxldGVkKGN1cnNvci5vcHRpb25zLCBMKTtcbiAgICBjdXJzb3IucGFyZW50LmJ1YmJsZSgncmVmbG93Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5jdHJsRGVsZXRlRGlyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmN1cnNvcjtcbiAgICBpZiAoIWN1cnNvcltMXSB8fCBjdXJzb3Iuc2VsZWN0aW9uKSByZXR1cm4gY3RybHIuZGVsZXRlRGlyKCk7XG5cbiAgICB0aGlzLm5vdGlmeSgnZWRpdCcpO1xuICAgIEZyYWdtZW50KGN1cnNvci5wYXJlbnQuZW5kc1tMXSwgY3Vyc29yW0xdKS5yZW1vdmUoKTtcbiAgICBjdXJzb3IuaW5zQXREaXJFbmQoTCwgY3Vyc29yLnBhcmVudCk7XG5cbiAgICBpZiAoY3Vyc29yW0xdLnNpYmxpbmdEZWxldGVkKSBjdXJzb3JbTF0uc2libGluZ0RlbGV0ZWQoY3Vyc29yLm9wdGlvbnMsIFIpO1xuICAgIGlmIChjdXJzb3JbUl0uc2libGluZ0RlbGV0ZWQpIGN1cnNvcltSXS5zaWJsaW5nRGVsZXRlZChjdXJzb3Iub3B0aW9ucywgTCk7XG4gICAgY3Vyc29yLnBhcmVudC5idWJibGUoJ3JlZmxvdycpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uYmFja3NwYWNlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRlbGV0ZURpcihMKTsgfTtcbiAgXy5kZWxldGVGb3J3YXJkID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRlbGV0ZURpcihSKTsgfTtcblxuICB0aGlzLm9uTm90aWZ5KGZ1bmN0aW9uKGUpIHsgaWYgKGUgIT09ICdzZWxlY3QnKSB0aGlzLmVuZFNlbGVjdGlvbigpOyB9KTtcbiAgXy5zZWxlY3REaXIgPSBmdW5jdGlvbihkaXIpIHtcbiAgICB2YXIgY3Vyc29yID0gdGhpcy5ub3RpZnkoJ3NlbGVjdCcpLmN1cnNvciwgc2VsbiA9IGN1cnNvci5zZWxlY3Rpb247XG4gICAgcHJheURpcmVjdGlvbihkaXIpO1xuXG4gICAgaWYgKCFjdXJzb3IuYW50aWN1cnNvcikgY3Vyc29yLnN0YXJ0U2VsZWN0aW9uKCk7XG5cbiAgICB2YXIgbm9kZSA9IGN1cnNvcltkaXJdO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAvLyBcImlmIG5vZGUgd2UncmUgc2VsZWN0aW5nIHRvd2FyZHMgaXMgaW5zaWRlIHNlbGVjdGlvbiAoaGVuY2UgcmV0cmFjdGluZylcbiAgICAgIC8vIGFuZCBpcyBvbiB0aGUgKmZhciBzaWRlKiBvZiB0aGUgc2VsZWN0aW9uIChoZW5jZSBpcyBvbmx5IG5vZGUgc2VsZWN0ZWQpXG4gICAgICAvLyBhbmQgdGhlIGFudGljdXJzb3IgaXMgKmluc2lkZSogdGhhdCBub2RlLCBub3QganVzdCBvbiB0aGUgb3RoZXIgc2lkZVwiXG4gICAgICBpZiAoc2VsbiAmJiBzZWxuLmVuZHNbZGlyXSA9PT0gbm9kZSAmJiBjdXJzb3IuYW50aWN1cnNvclstZGlyXSAhPT0gbm9kZSkge1xuICAgICAgICBub2RlLnVuc2VsZWN0SW50byhkaXIsIGN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIG5vZGUuc2VsZWN0VG93YXJkcyhkaXIsIGN1cnNvcik7XG4gICAgfVxuICAgIGVsc2UgY3Vyc29yLnBhcmVudC5zZWxlY3RPdXRPZihkaXIsIGN1cnNvcik7XG5cbiAgICBjdXJzb3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICBjdXJzb3Iuc2VsZWN0KCkgfHwgY3Vyc29yLnNob3coKTtcbiAgfTtcbiAgXy5zZWxlY3RMZWZ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbGVjdERpcihMKTsgfTtcbiAgXy5zZWxlY3RSaWdodCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWxlY3REaXIoUik7IH07XG59KTtcbi8vIFBhcnNlciBNYXRoQmxvY2tcbnZhciBsYXRleE1hdGhQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGNvbW1hbmRUb0Jsb2NrKGNtZCkgeyAvLyBjYW4gYWxzbyB0YWtlIGluIGEgRnJhZ21lbnRcbiAgICB2YXIgYmxvY2sgPSBNYXRoQmxvY2soKTtcbiAgICBjbWQuYWRvcHQoYmxvY2ssIDAsIDApO1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuICBmdW5jdGlvbiBqb2luQmxvY2tzKGJsb2Nrcykge1xuICAgIHZhciBmaXJzdEJsb2NrID0gYmxvY2tzWzBdIHx8IE1hdGhCbG9jaygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBibG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGJsb2Nrc1tpXS5jaGlsZHJlbigpLmFkb3B0KGZpcnN0QmxvY2ssIGZpcnN0QmxvY2suZW5kc1tSXSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0QmxvY2s7XG4gIH1cblxuICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgdmFyIHJlZ2V4ID0gUGFyc2VyLnJlZ2V4O1xuICB2YXIgbGV0dGVyID0gUGFyc2VyLmxldHRlcjtcbiAgdmFyIGFueSA9IFBhcnNlci5hbnk7XG4gIHZhciBvcHRXaGl0ZXNwYWNlID0gUGFyc2VyLm9wdFdoaXRlc3BhY2U7XG4gIHZhciBzdWNjZWVkID0gUGFyc2VyLnN1Y2NlZWQ7XG4gIHZhciBmYWlsID0gUGFyc2VyLmZhaWw7XG5cbiAgLy8gUGFyc2VycyB5aWVsZGluZyBlaXRoZXIgTWF0aENvbW1hbmRzLCBvciBGcmFnbWVudHMgb2YgTWF0aENvbW1hbmRzXG4gIC8vICAgKGVpdGhlciB3YXksIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhZG9wdGVkIGJ5IGEgTWF0aEJsb2NrKVxuICB2YXIgdmFyaWFibGUgPSBsZXR0ZXIubWFwKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIExldHRlcihjKTsgfSk7XG4gIHZhciBzeW1ib2wgPSByZWdleCgvXlteJHt9XFxcXF9eXS8pLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiBWYW5pbGxhU3ltYm9sKGMpOyB9KTtcblxuICB2YXIgY29udHJvbFNlcXVlbmNlID1cbiAgICByZWdleCgvXlteXFxcXGEtZWctekEtWl0vKSAvLyBob3RmaXggIzE2NDsgbWF0Y2ggTWF0aEJsb2NrOjp3cml0ZVxuICAgIC5vcihzdHJpbmcoJ1xcXFwnKS50aGVuKFxuICAgICAgcmVnZXgoL15bYS16XSsvaSlcbiAgICAgIC5vcihyZWdleCgvXlxccysvKS5yZXN1bHQoJyAnKSlcbiAgICAgIC5vcihhbnkpXG4gICAgKSkudGhlbihmdW5jdGlvbihjdHJsU2VxKSB7XG4gICAgICB2YXIgY21kS2xhc3MgPSBMYXRleENtZHNbY3RybFNlcV07XG5cbiAgICAgIGlmIChjbWRLbGFzcykge1xuICAgICAgICByZXR1cm4gY21kS2xhc3MoY3RybFNlcSkucGFyc2VyKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoJ3Vua25vd24gY29tbWFuZDogXFxcXCcrY3RybFNlcSk7XG4gICAgICB9XG4gICAgfSlcbiAgO1xuXG4gIHZhciBjb21tYW5kID1cbiAgICBjb250cm9sU2VxdWVuY2VcbiAgICAub3IodmFyaWFibGUpXG4gICAgLm9yKHN5bWJvbClcbiAgO1xuXG4gIC8vIFBhcnNlcnMgeWllbGRpbmcgTWF0aEJsb2Nrc1xuICB2YXIgbWF0aEdyb3VwID0gc3RyaW5nKCd7JykudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIG1hdGhTZXF1ZW5jZTsgfSkuc2tpcChzdHJpbmcoJ30nKSk7XG4gIHZhciBtYXRoQmxvY2sgPSBvcHRXaGl0ZXNwYWNlLnRoZW4obWF0aEdyb3VwLm9yKGNvbW1hbmQubWFwKGNvbW1hbmRUb0Jsb2NrKSkpO1xuICB2YXIgbWF0aFNlcXVlbmNlID0gbWF0aEJsb2NrLm1hbnkoKS5tYXAoam9pbkJsb2Nrcykuc2tpcChvcHRXaGl0ZXNwYWNlKTtcblxuICB2YXIgb3B0TWF0aEJsb2NrID1cbiAgICBzdHJpbmcoJ1snKS50aGVuKFxuICAgICAgbWF0aEJsb2NrLnRoZW4oZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmpvaW4oJ2xhdGV4JykgIT09ICddJyA/IHN1Y2NlZWQoYmxvY2spIDogZmFpbCgpO1xuICAgICAgfSlcbiAgICAgIC5tYW55KCkubWFwKGpvaW5CbG9ja3MpLnNraXAob3B0V2hpdGVzcGFjZSlcbiAgICApLnNraXAoc3RyaW5nKCddJykpXG4gIDtcblxuICB2YXIgbGF0ZXhNYXRoID0gbWF0aFNlcXVlbmNlO1xuXG4gIGxhdGV4TWF0aC5ibG9jayA9IG1hdGhCbG9jaztcbiAgbGF0ZXhNYXRoLm9wdEJsb2NrID0gb3B0TWF0aEJsb2NrO1xuICByZXR1cm4gbGF0ZXhNYXRoO1xufSkoKTtcblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmV4cG9ydExhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5sYXRleCgpLnJlcGxhY2UoLyhcXFxcW2Etel0rKSAoPyFbYS16XSkvaWcsJyQxJyk7XG4gIH07XG4gIF8ud3JpdGVMYXRleCA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMubm90aWZ5KCdlZGl0JykuY3Vyc29yO1xuXG4gICAgdmFyIGFsbCA9IFBhcnNlci5hbGw7XG4gICAgdmFyIGVvZiA9IFBhcnNlci5lb2Y7XG5cbiAgICB2YXIgYmxvY2sgPSBsYXRleE1hdGhQYXJzZXIuc2tpcChlb2YpLm9yKGFsbC5yZXN1bHQoZmFsc2UpKS5wYXJzZShsYXRleCk7XG5cbiAgICBpZiAoYmxvY2sgJiYgIWJsb2NrLmlzRW1wdHkoKSkge1xuICAgICAgYmxvY2suY2hpbGRyZW4oKS5hZG9wdChjdXJzb3IucGFyZW50LCBjdXJzb3JbTF0sIGN1cnNvcltSXSk7XG4gICAgICB2YXIgalEgPSBibG9jay5qUWl6ZSgpO1xuICAgICAgalEuaW5zZXJ0QmVmb3JlKGN1cnNvci5qUSk7XG4gICAgICBjdXJzb3JbTF0gPSBibG9jay5lbmRzW1JdO1xuICAgICAgYmxvY2suZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMsIGN1cnNvcik7XG4gICAgICBpZiAoYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tSXVtSXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgTCk7XG4gICAgICBpZiAoYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgICBjdXJzb3IucGFyZW50LmJ1YmJsZSgncmVmbG93Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8ucmVuZGVyTGF0ZXhNYXRoID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCwgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICB2YXIgYWxsID0gUGFyc2VyLmFsbDtcbiAgICB2YXIgZW9mID0gUGFyc2VyLmVvZjtcblxuICAgIHZhciBibG9jayA9IGxhdGV4TWF0aFBhcnNlci5za2lwKGVvZikub3IoYWxsLnJlc3VsdChmYWxzZSkpLnBhcnNlKGxhdGV4KTtcblxuICAgIHJvb3QuZWFjaENoaWxkKCdwb3N0T3JkZXInLCAnZGlzcG9zZScpO1xuICAgIHJvb3QuZW5kc1tMXSA9IHJvb3QuZW5kc1tSXSA9IDA7XG5cbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIGJsb2NrLmNoaWxkcmVuKCkuYWRvcHQocm9vdCwgMCwgMCk7XG4gICAgfVxuXG4gICAgdmFyIGpRID0gcm9vdC5qUTtcblxuICAgIGlmIChibG9jaykge1xuICAgICAgdmFyIGh0bWwgPSBibG9jay5qb2luKCdodG1sJyk7XG4gICAgICBqUS5odG1sKGh0bWwpO1xuICAgICAgcm9vdC5qUWl6ZShqUS5jaGlsZHJlbigpKTtcbiAgICAgIHJvb3QuZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGpRLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGN1cnNvci5zZWxlY3Rpb247XG4gICAgY3Vyc29yLmluc0F0UmlnaHRFbmQocm9vdCk7XG4gIH07XG4gIF8ucmVuZGVyTGF0ZXhUZXh0ID0gZnVuY3Rpb24obGF0ZXgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCwgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICByb290LmpRLmNoaWxkcmVuKCkuc2xpY2UoMSkucmVtb3ZlKCk7XG4gICAgcm9vdC5lYWNoQ2hpbGQoJ3Bvc3RPcmRlcicsICdkaXNwb3NlJyk7XG4gICAgcm9vdC5lbmRzW0xdID0gcm9vdC5lbmRzW1JdID0gMDtcbiAgICBkZWxldGUgY3Vyc29yLnNlbGVjdGlvbjtcbiAgICBjdXJzb3Iuc2hvdygpLmluc0F0UmlnaHRFbmQocm9vdCk7XG5cbiAgICB2YXIgcmVnZXggPSBQYXJzZXIucmVnZXg7XG4gICAgdmFyIHN0cmluZyA9IFBhcnNlci5zdHJpbmc7XG4gICAgdmFyIGVvZiA9IFBhcnNlci5lb2Y7XG4gICAgdmFyIGFsbCA9IFBhcnNlci5hbGw7XG5cbiAgICAvLyBQYXJzZXIgUm9vdE1hdGhDb21tYW5kXG4gICAgdmFyIG1hdGhNb2RlID0gc3RyaW5nKCckJykudGhlbihsYXRleE1hdGhQYXJzZXIpXG4gICAgICAvLyBiZWNhdXNlIFRlWCBpcyBpbnNhbmUsIG1hdGggbW9kZSBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4gICAgICAvLyBoYXZlIHRvIGVuZC4gIFNvIHdlIGFsbG93IGZvciB0aGUgY2FzZSB0aGF0IG1hdGggbW9kZVxuICAgICAgLy8gY29udGludWVzIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICAgIC5za2lwKHN0cmluZygnJCcpLm9yKGVvZikpXG4gICAgICAubWFwKGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgIC8vIEhBQ0sgRklYTUU6IHRoaXMgc2hvdWxkbid0IGhhdmUgdG8gaGF2ZSBhY2Nlc3MgdG8gY3Vyc29yXG4gICAgICAgIHZhciByb290TWF0aENvbW1hbmQgPSBSb290TWF0aENvbW1hbmQoY3Vyc29yKTtcblxuICAgICAgICByb290TWF0aENvbW1hbmQuY3JlYXRlQmxvY2tzKCk7XG4gICAgICAgIHZhciByb290TWF0aEJsb2NrID0gcm9vdE1hdGhDb21tYW5kLmVuZHNbTF07XG4gICAgICAgIGJsb2NrLmNoaWxkcmVuKCkuYWRvcHQocm9vdE1hdGhCbG9jaywgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHJvb3RNYXRoQ29tbWFuZDtcbiAgICAgIH0pXG4gICAgO1xuXG4gICAgdmFyIGVzY2FwZWREb2xsYXIgPSBzdHJpbmcoJ1xcXFwkJykucmVzdWx0KCckJyk7XG4gICAgdmFyIHRleHRDaGFyID0gZXNjYXBlZERvbGxhci5vcihyZWdleCgvXlteJF0vKSkubWFwKFZhbmlsbGFTeW1ib2wpO1xuICAgIHZhciBsYXRleFRleHQgPSBtYXRoTW9kZS5vcih0ZXh0Q2hhcikubWFueSgpO1xuICAgIHZhciBjb21tYW5kcyA9IGxhdGV4VGV4dC5za2lwKGVvZikub3IoYWxsLnJlc3VsdChmYWxzZSkpLnBhcnNlKGxhdGV4KTtcblxuICAgIGlmIChjb21tYW5kcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb21tYW5kc1tpXS5hZG9wdChyb290LCByb290LmVuZHNbUl0sIDApO1xuICAgICAgfVxuXG4gICAgICByb290LmpRaXplKCkuYXBwZW5kVG8ocm9vdC5qUSk7XG5cbiAgICAgIHJvb3QuZmluYWxpemVJbnNlcnQoY3Vyc29yLm9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEZWFscyB3aXRoIG1vdXNlIGV2ZW50cyBmb3IgY2xpY2tpbmcsIGRyYWctdG8tc2VsZWN0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuQ29udHJvbGxlci5vcGVuKGZ1bmN0aW9uKF8pIHtcbiAgT3B0aW9ucy5wLmlnbm9yZU5leHRNb3VzZWRvd24gPSBub29wO1xuICBfLmRlbGVnYXRlTW91c2VFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdWx0aW1hdGVSb290alEgPSB0aGlzLnJvb3QualE7XG4gICAgLy9kcmFnLXRvLXNlbGVjdCBldmVudCBoYW5kbGluZ1xuICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlZG93bi5tYXRocXVpbGwnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcm9vdGpRID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLm1xLXJvb3QtYmxvY2snKTtcbiAgICAgIHZhciByb290ID0gTm9kZS5ieUlkW3Jvb3RqUS5hdHRyKG1xQmxvY2tJZCkgfHwgdWx0aW1hdGVSb290alEuYXR0cihtcUJsb2NrSWQpXTtcbiAgICAgIHZhciBjdHJsciA9IHJvb3QuY29udHJvbGxlciwgY3Vyc29yID0gY3RybHIuY3Vyc29yLCBibGluayA9IGN1cnNvci5ibGluaztcbiAgICAgIHZhciB0ZXh0YXJlYVNwYW4gPSBjdHJsci50ZXh0YXJlYVNwYW4sIHRleHRhcmVhID0gY3RybHIudGV4dGFyZWE7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gZG9lc24ndCB3b3JrIGluIElFXFx1MjI2NDgsIGJ1dCBpdCdzIGEgb25lLWxpbmUgZml4OlxuICAgICAgZS50YXJnZXQudW5zZWxlY3RhYmxlID0gdHJ1ZTsgLy8gaHR0cDovL2pzYmluLmNvbS95YWdla2lqaS8xXG5cbiAgICAgIGlmIChjdXJzb3Iub3B0aW9ucy5pZ25vcmVOZXh0TW91c2Vkb3duKGUpKSByZXR1cm47XG4gICAgICBlbHNlIGN1cnNvci5vcHRpb25zLmlnbm9yZU5leHRNb3VzZWRvd24gPSBub29wO1xuXG4gICAgICB2YXIgdGFyZ2V0O1xuICAgICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGUpIHsgdGFyZ2V0ID0gJChlLnRhcmdldCk7IH1cbiAgICAgIGZ1bmN0aW9uIGRvY21vdXNlbW92ZShlKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmFudGljdXJzb3IpIGN1cnNvci5zdGFydFNlbGVjdGlvbigpO1xuICAgICAgICBjdHJsci5zZWVrKHRhcmdldCwgZS5wYWdlWCwgZS5wYWdlWSkuY3Vyc29yLnNlbGVjdCgpO1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAvLyBvdXRzaWRlIHJvb3RqUSwgdGhlIE1hdGhRdWlsbCBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCAoaWYgYW55KVxuICAgICAgLy8gd29uJ3QgYmUgaW5zaWRlIHRoaXMgcm9vdCwgc28gZG9uJ3QgbWlzbGVhZCBDb250cm9sbGVyOjpzZWVrIHdpdGggaXRcblxuICAgICAgZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gICAgICAgIGN1cnNvci5ibGluayA9IGJsaW5rO1xuICAgICAgICBpZiAoIWN1cnNvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY3RybHIuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGN1cnNvci5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dGFyZWFTcGFuLmRldGFjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgbW91c2UgaGFuZGxlcnMgbm93IHRoYXQgd2UncmUgbm90IGRyYWdnaW5nIGFueW1vcmVcbiAgICAgICAgcm9vdGpRLnVuYmluZCgnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgJChlLnRhcmdldC5vd25lckRvY3VtZW50KS51bmJpbmQoJ21vdXNlbW92ZScsIGRvY21vdXNlbW92ZSkudW5iaW5kKCdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHJsci5ibHVycmVkKSB7XG4gICAgICAgIGlmICghY3RybHIuZWRpdGFibGUpIHJvb3RqUS5wcmVwZW5kKHRleHRhcmVhU3Bhbik7XG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnNvci5ibGluayA9IG5vb3A7XG4gICAgICBjdHJsci5zZWVrKCQoZS50YXJnZXQpLCBlLnBhZ2VYLCBlLnBhZ2VZKS5jdXJzb3Iuc3RhcnRTZWxlY3Rpb24oKTtcblxuICAgICAgcm9vdGpRLm1vdXNlbW92ZShtb3VzZW1vdmUpO1xuICAgICAgJChlLnRhcmdldC5vd25lckRvY3VtZW50KS5tb3VzZW1vdmUoZG9jbW91c2Vtb3ZlKS5tb3VzZXVwKG1vdXNldXApO1xuICAgICAgLy8gbGlzdGVuIG9uIGRvY3VtZW50IG5vdCBqdXN0IGJvZHkgdG8gbm90IG9ubHkgaGVhciBhYm91dCBtb3VzZW1vdmUgYW5kXG4gICAgICAvLyBtb3VzZXVwIG9uIHBhZ2Ugb3V0c2lkZSBmaWVsZCwgYnV0IGV2ZW4gb3V0c2lkZSBwYWdlLCBleGNlcHQgaWZyYW1lczogaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvY29tbWl0LzhjNTAwMjhhZmNmZmNhY2U2NTVkOGFlMjA0OWY2ZTAyNDgyMzQ2YzUjY29tbWl0Y29tbWVudC02MTc1ODAwXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5Db250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXykge1xuICBfLnNlZWsgPSBmdW5jdGlvbih0YXJnZXQsIHBhZ2VYLCBwYWdlWSkge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLm5vdGlmeSgnc2VsZWN0JykuY3Vyc29yO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdmFyIG5vZGVJZCA9IHRhcmdldC5hdHRyKG1xQmxvY2tJZCkgfHwgdGFyZ2V0LmF0dHIobXFDbWRJZCk7XG4gICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICB2YXIgdGFyZ2V0UGFyZW50ID0gdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgICBub2RlSWQgPSB0YXJnZXRQYXJlbnQuYXR0cihtcUJsb2NrSWQpIHx8IHRhcmdldFBhcmVudC5hdHRyKG1xQ21kSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbm9kZSA9IG5vZGVJZCA/IE5vZGUuYnlJZFtub2RlSWRdIDogdGhpcy5yb290O1xuICAgIHByYXkoJ25vZGVJZCBpcyB0aGUgaWQgb2Ygc29tZSBOb2RlIHRoYXQgZXhpc3RzJywgbm9kZSk7XG5cbiAgICAvLyBkb24ndCBjbGVhciBzZWxlY3Rpb24gdW50aWwgYWZ0ZXIgZ2V0dGluZyBub2RlIGZyb20gdGFyZ2V0LCBpbiBjYXNlXG4gICAgLy8gdGFyZ2V0IHdhcyBzZWxlY3Rpb24gc3Bhbiwgb3RoZXJ3aXNlIHRhcmdldCB3aWxsIGhhdmUgbm8gcGFyZW50IGFuZCB3aWxsXG4gICAgLy8gc2VlayBmcm9tIHJvb3QsIHdoaWNoIGlzIGxlc3MgYWNjdXJhdGUgKGUuZy4gZnJhY3Rpb24pXG4gICAgY3Vyc29yLmNsZWFyU2VsZWN0aW9uKCkuc2hvdygpO1xuXG4gICAgbm9kZS5zZWVrKHBhZ2VYLCBjdXJzb3IpO1xuICAgIHRoaXMuc2Nyb2xsSG9yaXooKTsgLy8gYmVmb3JlIC5zZWxlY3RGcm9tIHdoZW4gbW91c2Utc2VsZWN0aW5nLCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIGhpdHMgbm8tc2VsZWN0aW9uIGNhc2UgaW4gc2Nyb2xsSG9yaXogYW5kIHNjcm9sbHMgc2xvd2VyXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogSG9yaXpvbnRhbCBwYW5uaW5nIGZvciBlZGl0YWJsZSBmaWVsZHMgdGhhdFxuICogb3ZlcmZsb3cgdGhlaXIgd2lkdGhcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5Db250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXykge1xuICBfLnNjcm9sbEhvcml6ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMuY3Vyc29yLCBzZWxuID0gY3Vyc29yLnNlbGVjdGlvbjtcbiAgICB2YXIgcm9vdFJlY3QgPSB0aGlzLnJvb3QualFbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFzZWxuKSB7XG4gICAgICB2YXIgeCA9IGN1cnNvci5qUVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgaWYgKHggPiByb290UmVjdC5yaWdodCAtIDIwKSB2YXIgc2Nyb2xsQnkgPSB4IC0gKHJvb3RSZWN0LnJpZ2h0IC0gMjApO1xuICAgICAgZWxzZSBpZiAoeCA8IHJvb3RSZWN0LmxlZnQgKyAyMCkgdmFyIHNjcm9sbEJ5ID0geCAtIChyb290UmVjdC5sZWZ0ICsgMjApO1xuICAgICAgZWxzZSByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlY3QgPSBzZWxuLmpRWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG92ZXJMZWZ0ID0gcmVjdC5sZWZ0IC0gKHJvb3RSZWN0LmxlZnQgKyAyMCk7XG4gICAgICB2YXIgb3ZlclJpZ2h0ID0gcmVjdC5yaWdodCAtIChyb290UmVjdC5yaWdodCAtIDIwKTtcbiAgICAgIGlmIChzZWxuLmVuZHNbTF0gPT09IGN1cnNvcltSXSkge1xuICAgICAgICBpZiAob3ZlckxlZnQgPCAwKSB2YXIgc2Nyb2xsQnkgPSBvdmVyTGVmdDtcbiAgICAgICAgZWxzZSBpZiAob3ZlclJpZ2h0ID4gMCkge1xuICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSBvdmVyUmlnaHQgPCByb290UmVjdC5sZWZ0ICsgMjApIHZhciBzY3JvbGxCeSA9IG92ZXJMZWZ0O1xuICAgICAgICAgIGVsc2UgdmFyIHNjcm9sbEJ5ID0gb3ZlclJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvdmVyUmlnaHQgPiAwKSB2YXIgc2Nyb2xsQnkgPSBvdmVyUmlnaHQ7XG4gICAgICAgIGVsc2UgaWYgKG92ZXJMZWZ0IDwgMCkge1xuICAgICAgICAgIGlmIChyZWN0LnJpZ2h0IC0gb3ZlckxlZnQgPiByb290UmVjdC5yaWdodCAtIDIwKSB2YXIgc2Nyb2xsQnkgPSBvdmVyUmlnaHQ7XG4gICAgICAgICAgZWxzZSB2YXIgc2Nyb2xsQnkgPSBvdmVyTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yb290LmpRLnN0b3AoKS5hbmltYXRlKHsgc2Nyb2xsTGVmdDogJys9JyArIHNjcm9sbEJ5fSwgMTAwKTtcbiAgfTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTWFuYWdlIHRoZSBNYXRoUXVpbGwgaW5zdGFuY2UncyB0ZXh0YXJlYVxuICogKGFzIG93bmVkIGJ5IHRoZSBDb250cm9sbGVyKVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5Db250cm9sbGVyLm9wZW4oZnVuY3Rpb24oXykge1xuICBPcHRpb25zLnAuc3Vic3RpdHV0ZVRleHRhcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICQoJzx0ZXh0YXJlYSBhdXRvY2FwaXRhbGl6ZT1vZmYgYXV0b2NvbXBsZXRlPW9mZiBhdXRvY29ycmVjdD1vZmYgJyArXG4gICAgICAgICAgICAgICAnc3BlbGxjaGVjaz1mYWxzZSB4LXBhbG0tZGlzYWJsZS1zdGUtYWxsPXRydWUgLz4nKVswXTtcbiAgfTtcbiAgXy5jcmVhdGVUZXh0YXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXh0YXJlYVNwYW4gPSB0aGlzLnRleHRhcmVhU3BhbiA9ICQoJzxzcGFuIGNsYXNzPVwibXEtdGV4dGFyZWFcIj48L3NwYW4+JyksXG4gICAgICB0ZXh0YXJlYSA9IHRoaXMub3B0aW9ucy5zdWJzdGl0dXRlVGV4dGFyZWEoKTtcbiAgICBpZiAoIXRleHRhcmVhLm5vZGVUeXBlKSB7XG4gICAgICB0aHJvdyAnc3Vic3RpdHV0ZVRleHRhcmVhKCkgbXVzdCByZXR1cm4gYSBET00gZWxlbWVudCwgZ290ICcgKyB0ZXh0YXJlYTtcbiAgICB9XG4gICAgdGV4dGFyZWEgPSB0aGlzLnRleHRhcmVhID0gJCh0ZXh0YXJlYSkuYXBwZW5kVG8odGV4dGFyZWFTcGFuKTtcblxuICAgIHZhciBjdHJsciA9IHRoaXM7XG4gICAgY3RybHIuY3Vyc29yLnNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHsgY3RybHIuc2VsZWN0aW9uQ2hhbmdlZCgpOyB9O1xuICAgIGN0cmxyLmNvbnRhaW5lci5iaW5kKCdjb3B5JywgZnVuY3Rpb24oKSB7IGN0cmxyLnNldFRleHRhcmVhU2VsZWN0aW9uKCk7IH0pO1xuICB9O1xuICBfLnNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3RybHIgPSB0aGlzO1xuICAgIGZvcmNlSUVSZWRyYXcoY3RybHIuY29udGFpbmVyWzBdKTtcblxuICAgIC8vIHRocm90dGxlIGNhbGxzIHRvIHNldFRleHRhcmVhU2VsZWN0aW9uKCksIGJlY2F1c2Ugc2V0dGluZyB0ZXh0YXJlYS52YWx1ZVxuICAgIC8vIGFuZC9vciBjYWxsaW5nIHRleHRhcmVhLnNlbGVjdCgpIGNhbiBoYXZlIGFub21hbG91c2x5IGJhZCBwZXJmb3JtYW5jZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aHF1aWxsL21hdGhxdWlsbC9pc3N1ZXMvNDMjaXNzdWVjb21tZW50LTEzOTkwODBcbiAgICBpZiAoY3RybHIudGV4dGFyZWFTZWxlY3Rpb25UaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0cmxyLnRleHRhcmVhU2VsZWN0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0cmxyLnNldFRleHRhcmVhU2VsZWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF8uc2V0VGV4dGFyZWFTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRhcmVhU2VsZWN0aW9uVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgbGF0ZXggPSAnJztcbiAgICBpZiAodGhpcy5jdXJzb3Iuc2VsZWN0aW9uKSB7XG4gICAgICBsYXRleCA9IHRoaXMuY3Vyc29yLnNlbGVjdGlvbi5qb2luKCdsYXRleCcpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0ZWxlc3NDbGlwYm9hcmQpIHtcbiAgICAgICAgLy8gRklYTUU6IGxpa2UgcGFzdGUsIG9ubHkgdGhpcyB3b3JrcyBmb3IgbWF0aCBmaWVsZHM7IHNob3VsZCBhc2sgcGFyZW50XG4gICAgICAgIGxhdGV4ID0gJyQnICsgbGF0ZXggKyAnJCc7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0Rm4obGF0ZXgpO1xuICB9O1xuICBfLnN0YXRpY01hdGhUZXh0YXJlYUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHJsciA9IHRoaXMsIHJvb3QgPSBjdHJsci5yb290LCBjdXJzb3IgPSBjdHJsci5jdXJzb3IsXG4gICAgICB0ZXh0YXJlYSA9IGN0cmxyLnRleHRhcmVhLCB0ZXh0YXJlYVNwYW4gPSBjdHJsci50ZXh0YXJlYVNwYW47XG5cbiAgICB0aGlzLmNvbnRhaW5lci5wcmVwZW5kKCc8c3BhbiBjbGFzcz1cIm1xLXNlbGVjdGFibGVcIj4kJytjdHJsci5leHBvcnRMYXRleCgpKyckPC9zcGFuPicpO1xuICAgIGN0cmxyLmJsdXJyZWQgPSB0cnVlO1xuICAgIHRleHRhcmVhLmJpbmQoJ2N1dCBwYXN0ZScsIGZhbHNlKVxuICAgIC5mb2N1cyhmdW5jdGlvbigpIHsgY3RybHIuYmx1cnJlZCA9IGZhbHNlOyB9KS5ibHVyKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIGN1cnNvci5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIHNldFRpbWVvdXQoZGV0YWNoKTsgLy9kZXRhY2hpbmcgZHVyaW5nIGJsdXIgZXhwbG9kZXMgaW4gV2ViS2l0XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgdGV4dGFyZWFTcGFuLmRldGFjaCgpO1xuICAgICAgY3RybHIuYmx1cnJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY3RybHIuc2VsZWN0Rm4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB0ZXh0YXJlYS52YWwodGV4dCk7XG4gICAgICBpZiAodGV4dCkgdGV4dGFyZWEuc2VsZWN0KCk7XG4gICAgfTtcbiAgfTtcbiAgXy5lZGl0YWJsZXNUZXh0YXJlYUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHJsciA9IHRoaXMsIHJvb3QgPSBjdHJsci5yb290LCBjdXJzb3IgPSBjdHJsci5jdXJzb3IsXG4gICAgICB0ZXh0YXJlYSA9IGN0cmxyLnRleHRhcmVhLCB0ZXh0YXJlYVNwYW4gPSBjdHJsci50ZXh0YXJlYVNwYW47XG5cbiAgICB2YXIga2V5Ym9hcmRFdmVudHNTaGltID0gc2FuZUtleWJvYXJkRXZlbnRzKHRleHRhcmVhLCB0aGlzKTtcbiAgICB0aGlzLnNlbGVjdEZuID0gZnVuY3Rpb24odGV4dCkgeyBrZXlib2FyZEV2ZW50c1NoaW0uc2VsZWN0KHRleHQpOyB9O1xuXG4gICAgdGhpcy5jb250YWluZXIucHJlcGVuZCh0ZXh0YXJlYVNwYW4pXG4gICAgLm9uKCdjdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoY3Vyc29yLnNlbGVjdGlvbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGN0cmxyLm5vdGlmeSgnZWRpdCcpOyAvLyBkZWxldGVzIHNlbGVjdGlvbiBpZiBwcmVzZW50XG4gICAgICAgICAgY3Vyc29yLnBhcmVudC5idWJibGUoJ3JlZmxvdycpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZm9jdXNCbHVyRXZlbnRzKCk7XG4gIH07XG4gIF8udHlwZWRUZXh0ID0gZnVuY3Rpb24oY2gpIHtcbiAgICBpZiAoY2ggPT09ICdcXG4nKSByZXR1cm4gdGhpcy5oYW5kbGUoJ2VudGVyJyk7XG4gICAgdmFyIGN1cnNvciA9IHRoaXMubm90aWZ5KCkuY3Vyc29yO1xuICAgIGN1cnNvci5wYXJlbnQud3JpdGUoY3Vyc29yLCBjaCk7XG4gICAgdGhpcy5zY3JvbGxIb3JpeigpO1xuICB9O1xuICBfLnBhc3RlID0gZnVuY3Rpb24odGV4dCkge1xuICAgIC8vIFRPRE86IGRvY3VtZW50IGBzdGF0ZWxlc3NDbGlwYm9hcmRgIGNvbmZpZyBvcHRpb24gaW4gUkVBRE1FLCBhZnRlclxuICAgIC8vIG1ha2luZyBpdCB3b3JrIGxpa2UgaXQgc2hvdWxkLCB0aGF0IGlzLCBpbiBib3RoIHRleHQgYW5kIG1hdGggbW9kZVxuICAgIC8vIChjdXJyZW50bHkgb25seSB3b3JrcyBpbiBtYXRoIGZpZWxkcywgc28gd29yc2UgdGhhbiBwb2ludGxlc3MsIGl0XG4gICAgLy8gIG9ubHkgZ2V0cyBpbiB0aGUgd2F5IGJ5IFxcdGV4dHt9LWlmeWluZyBwYXN0ZWQgc3R1ZmYgYW5kICQtaWZ5aW5nXG4gICAgLy8gIGN1dC9jb3BpZWQgTGFUZVgpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0ZWxlc3NDbGlwYm9hcmQpIHtcbiAgICAgIGlmICh0ZXh0LnNsaWNlKDAsMSkgPT09ICckJyAmJiB0ZXh0LnNsaWNlKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0ZXh0ID0gJ1xcXFx0ZXh0eycrdGV4dCsnfSc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZJWE1FOiB0aGlzIGFsd2F5cyBpbnNlcnRzIG1hdGggb3IgYSBUZXh0QmxvY2ssIGV2ZW4gaW4gYSBSb290VGV4dEJsb2NrXG4gICAgdGhpcy53cml0ZUxhdGV4KHRleHQpLmN1cnNvci5zaG93KCk7XG4gIH07XG59KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBBYnN0cmFjdCBjbGFzc2VzIG9mIG1hdGggYmxvY2tzIGFuZCBjb21tYW5kcy5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogTWF0aCB0cmVlIG5vZGUgYmFzZSBjbGFzcy5cbiAqIFNvbWUgbWF0aC10cmVlLXNwZWNpZmljIGV4dGVuc2lvbnMgdG8gTm9kZS5cbiAqIEJvdGggTWF0aEJsb2NrJ3MgYW5kIE1hdGhDb21tYW5kJ3MgZGVzY2VuZCBmcm9tIGl0LlxuICovXG52YXIgTWF0aEVsZW1lbnQgPSBQKE5vZGUsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmZpbmFsaXplSW5zZXJ0ID0gZnVuY3Rpb24ob3B0aW9ucywgY3Vyc29yKSB7IC8vIGBjdXJzb3JgIHBhcmFtIGlzIG9ubHkgZm9yXG4gICAgICAvLyBTdXBTdWI6OmNvbnRhY3RXZWxkLCBhbmQgaXMgZGVsaWJlcmF0ZWx5IG9ubHkgcGFzc2VkIGluIGJ5IHdyaXRlTGF0ZXgsXG4gICAgICAvLyBzZWUgZWE3MzA3ZWI0ZmFjNzdjMTQ5YTExZmZkZjlhODMxZGY4NTI0NzY5M1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnBvc3RPcmRlcignZmluYWxpemVUcmVlJywgb3B0aW9ucyk7XG4gICAgc2VsZi5wb3N0T3JkZXIoJ2NvbnRhY3RXZWxkJywgY3Vyc29yKTtcblxuICAgIC8vIG5vdGU6IHRoaXMgb3JkZXIgaXMgaW1wb3J0YW50LlxuICAgIC8vIGVtcHR5IGVsZW1lbnRzIG5lZWQgdGhlIGVtcHR5IGJveCBwcm92aWRlZCBieSBibHVyIHRvXG4gICAgLy8gYmUgcHJlc2VudCBpbiBvcmRlciBmb3IgdGhlaXIgZGltZW5zaW9ucyB0byBiZSBtZWFzdXJlZFxuICAgIC8vIGNvcnJlY3RseSBieSAncmVmbG93JyBoYW5kbGVycy5cbiAgICBzZWxmLnBvc3RPcmRlcignYmx1cicpO1xuXG4gICAgc2VsZi5wb3N0T3JkZXIoJ3JlZmxvdycpO1xuICAgIGlmIChzZWxmW1JdLnNpYmxpbmdDcmVhdGVkKSBzZWxmW1JdLnNpYmxpbmdDcmVhdGVkKG9wdGlvbnMsIEwpO1xuICAgIGlmIChzZWxmW0xdLnNpYmxpbmdDcmVhdGVkKSBzZWxmW0xdLnNpYmxpbmdDcmVhdGVkKG9wdGlvbnMsIFIpO1xuICAgIHNlbGYuYnViYmxlKCdyZWZsb3cnKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIENvbW1hbmRzIGFuZCBvcGVyYXRvcnMsIGxpa2Ugc3Vic2NyaXB0cywgZXhwb25lbnRzLCBvciBmcmFjdGlvbnMuXG4gKiBEZXNjZW5kYW50IGNvbW1hbmRzIGFyZSBvcmdhbml6ZWQgaW50byBibG9ja3MuXG4gKi9cbnZhciBNYXRoQ29tbWFuZCA9IFAoTWF0aEVsZW1lbnQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjdHJsU2VxLCBodG1sVGVtcGxhdGUsIHRleHRUZW1wbGF0ZSkge1xuICAgIHZhciBjbWQgPSB0aGlzO1xuICAgIHN1cGVyXy5pbml0LmNhbGwoY21kKTtcblxuICAgIGlmICghY21kLmN0cmxTZXEpIGNtZC5jdHJsU2VxID0gY3RybFNlcTtcbiAgICBpZiAoaHRtbFRlbXBsYXRlKSBjbWQuaHRtbFRlbXBsYXRlID0gaHRtbFRlbXBsYXRlO1xuICAgIGlmICh0ZXh0VGVtcGxhdGUpIGNtZC50ZXh0VGVtcGxhdGUgPSB0ZXh0VGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gb2J2aW91cyBtZXRob2RzXG4gIF8ucmVwbGFjZXMgPSBmdW5jdGlvbihyZXBsYWNlZEZyYWdtZW50KSB7XG4gICAgcmVwbGFjZWRGcmFnbWVudC5kaXNvd24oKTtcbiAgICB0aGlzLnJlcGxhY2VkRnJhZ21lbnQgPSByZXBsYWNlZEZyYWdtZW50O1xuICB9O1xuICBfLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkQ2hpbGRyZW4odHJ1ZSwgZnVuY3Rpb24oaXNFbXB0eSwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBpc0VtcHR5ICYmIGNoaWxkLmlzRW1wdHkoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBibG9jayA9IGxhdGV4TWF0aFBhcnNlci5ibG9jaztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gYmxvY2sudGltZXMoc2VsZi5udW1CbG9ja3MoKSkubWFwKGZ1bmN0aW9uKGJsb2Nrcykge1xuICAgICAgc2VsZi5ibG9ja3MgPSBibG9ja3M7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJsb2Nrc1tpXS5hZG9wdChzZWxmLCBzZWxmLmVuZHNbUl0sIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBjcmVhdGVMZWZ0T2YoY3Vyc29yKSBhbmQgdGhlIG1ldGhvZHMgaXQgY2FsbHNcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICB2YXIgY21kID0gdGhpcztcbiAgICB2YXIgcmVwbGFjZWRGcmFnbWVudCA9IGNtZC5yZXBsYWNlZEZyYWdtZW50O1xuXG4gICAgY21kLmNyZWF0ZUJsb2NrcygpO1xuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbChjbWQsIGN1cnNvcik7XG4gICAgaWYgKHJlcGxhY2VkRnJhZ21lbnQpIHtcbiAgICAgIHJlcGxhY2VkRnJhZ21lbnQuYWRvcHQoY21kLmVuZHNbTF0sIDAsIDApO1xuICAgICAgcmVwbGFjZWRGcmFnbWVudC5qUS5hcHBlbmRUbyhjbWQuZW5kc1tMXS5qUSk7XG4gICAgfVxuICAgIGNtZC5maW5hbGl6ZUluc2VydChjdXJzb3Iub3B0aW9ucyk7XG4gICAgY21kLnBsYWNlQ3Vyc29yKGN1cnNvcik7XG4gIH07XG4gIF8uY3JlYXRlQmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNtZCA9IHRoaXMsXG4gICAgICBudW1CbG9ja3MgPSBjbWQubnVtQmxvY2tzKCksXG4gICAgICBibG9ja3MgPSBjbWQuYmxvY2tzID0gQXJyYXkobnVtQmxvY2tzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQmxvY2tzOyBpICs9IDEpIHtcbiAgICAgIHZhciBuZXdCbG9jayA9IGJsb2Nrc1tpXSA9IE1hdGhCbG9jaygpO1xuICAgICAgbmV3QmxvY2suYWRvcHQoY21kLCBjbWQuZW5kc1tSXSwgMCk7XG4gICAgfVxuICB9O1xuICBfLnBsYWNlQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgLy9pbnNlcnQgdGhlIGN1cnNvciBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBmaXJzdCBlbXB0eSBjaGlsZCwgc2VhcmNoaW5nXG4gICAgLy9sZWZ0LXRvLXJpZ2h0LCBvciBpZiBub25lIGVtcHR5LCB0aGUgcmlnaHQgZW5kIGNoaWxkXG4gICAgY3Vyc29yLmluc0F0UmlnaHRFbmQodGhpcy5mb2xkQ2hpbGRyZW4odGhpcy5lbmRzW0xdLCBmdW5jdGlvbihsZWZ0d2FyZCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBsZWZ0d2FyZC5pc0VtcHR5KCkgPyBsZWZ0d2FyZCA6IGNoaWxkO1xuICAgIH0pKTtcbiAgfTtcblxuICAvLyBlZGl0YWJpbGl0eSBtZXRob2RzOiBjYWxsZWQgYnkgdGhlIGN1cnNvciBmb3IgZWRpdGluZywgY3Vyc29yIG1vdmVtZW50cyxcbiAgLy8gYW5kIHNlbGVjdGlvbiBvZiB0aGUgTWF0aFF1aWxsIHRyZWUsIHRoZXNlIGFsbCB0YWtlIGluIGEgZGlyZWN0aW9uIGFuZFxuICAvLyB0aGUgY3Vyc29yXG4gIF8ubW92ZVRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvciwgdXBkb3duKSB7XG4gICAgdmFyIHVwZG93bkludG8gPSB1cGRvd24gJiYgdGhpc1t1cGRvd24rJ0ludG8nXTtcbiAgICBjdXJzb3IuaW5zQXREaXJFbmQoLWRpciwgdXBkb3duSW50byB8fCB0aGlzLmVuZHNbLWRpcl0pO1xuICB9O1xuICBfLmRlbGV0ZVRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgY3Vyc29yW2Rpcl0gPSB0aGlzLnJlbW92ZSgpW2Rpcl07XG4gICAgZWxzZSB0aGlzLm1vdmVUb3dhcmRzKGRpciwgY3Vyc29yLCBudWxsKTtcbiAgfTtcbiAgXy5zZWxlY3RUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBjdXJzb3JbLWRpcl0gPSB0aGlzO1xuICAgIGN1cnNvcltkaXJdID0gdGhpc1tkaXJdO1xuICB9O1xuICBfLnNlbGVjdENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNlbGVjdGlvbih0aGlzLCB0aGlzKTtcbiAgfTtcbiAgXy51bnNlbGVjdEludG8gPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGN1cnNvci5pbnNBdERpckVuZCgtZGlyLCBjdXJzb3IuYW50aWN1cnNvci5hbmNlc3RvcnNbdGhpcy5pZF0pO1xuICB9O1xuICBfLnNlZWsgPSBmdW5jdGlvbihwYWdlWCwgY3Vyc29yKSB7XG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRzKG5vZGUpIHtcbiAgICAgIHZhciBib3VuZHMgPSB7fVxuICAgICAgYm91bmRzW0xdID0gbm9kZS5qUS5vZmZzZXQoKS5sZWZ0O1xuICAgICAgYm91bmRzW1JdID0gYm91bmRzW0xdICsgbm9kZS5qUS5vdXRlcldpZHRoKCk7XG4gICAgICByZXR1cm4gYm91bmRzO1xuICAgIH1cblxuICAgIHZhciBjbWQgPSB0aGlzO1xuICAgIHZhciBjbWRCb3VuZHMgPSBnZXRCb3VuZHMoY21kKTtcblxuICAgIGlmIChwYWdlWCA8IGNtZEJvdW5kc1tMXSkgcmV0dXJuIGN1cnNvci5pbnNMZWZ0T2YoY21kKTtcbiAgICBpZiAocGFnZVggPiBjbWRCb3VuZHNbUl0pIHJldHVybiBjdXJzb3IuaW5zUmlnaHRPZihjbWQpO1xuXG4gICAgdmFyIGxlZnRMZWZ0Qm91bmQgPSBjbWRCb3VuZHNbTF07XG4gICAgY21kLmVhY2hDaGlsZChmdW5jdGlvbihibG9jaykge1xuICAgICAgdmFyIGJsb2NrQm91bmRzID0gZ2V0Qm91bmRzKGJsb2NrKTtcbiAgICAgIGlmIChwYWdlWCA8IGJsb2NrQm91bmRzW0xdKSB7XG4gICAgICAgIC8vIGNsb3NlciB0byB0aGlzIGJsb2NrJ3MgbGVmdCBib3VuZCwgb3IgdGhlIGJvdW5kIGxlZnQgb2YgdGhhdD9cbiAgICAgICAgaWYgKHBhZ2VYIC0gbGVmdExlZnRCb3VuZCA8IGJsb2NrQm91bmRzW0xdIC0gcGFnZVgpIHtcbiAgICAgICAgICBpZiAoYmxvY2tbTF0pIGN1cnNvci5pbnNBdFJpZ2h0RW5kKGJsb2NrW0xdKTtcbiAgICAgICAgICBlbHNlIGN1cnNvci5pbnNMZWZ0T2YoY21kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGN1cnNvci5pbnNBdExlZnRFbmQoYmxvY2spO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYWdlWCA+IGJsb2NrQm91bmRzW1JdKSB7XG4gICAgICAgIGlmIChibG9ja1tSXSkgbGVmdExlZnRCb3VuZCA9IGJsb2NrQm91bmRzW1JdOyAvLyBjb250aW51ZSB0byBuZXh0IGJsb2NrXG4gICAgICAgIGVsc2UgeyAvLyBsYXN0IChyaWdodG1vc3QpIGJsb2NrXG4gICAgICAgICAgLy8gY2xvc2VyIHRvIHRoaXMgYmxvY2sncyByaWdodCBib3VuZCwgb3IgdGhlIGNtZCdzIHJpZ2h0IGJvdW5kP1xuICAgICAgICAgIGlmIChjbWRCb3VuZHNbUl0gLSBwYWdlWCA8IHBhZ2VYIC0gYmxvY2tCb3VuZHNbUl0pIHtcbiAgICAgICAgICAgIGN1cnNvci5pbnNSaWdodE9mKGNtZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgY3Vyc29yLmluc0F0UmlnaHRFbmQoYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYmxvY2suc2VlayhwYWdlWCwgY3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gbWV0aG9kcyBpbnZvbHZlZCBpbiBjcmVhdGluZyBhbmQgY3Jvc3MtbGlua2luZyB3aXRoIEhUTUwgRE9NIG5vZGVzXG4gIC8qXG4gICAgVGhleSBhbGwgZXhwZWN0IGFuIC5odG1sVGVtcGxhdGUgbGlrZVxuICAgICAgJzxzcGFuPiYwPC9zcGFuPidcbiAgICBvclxuICAgICAgJzxzcGFuPjxzcGFuPiYwPC9zcGFuPjxzcGFuPiYxPC9zcGFuPjwvc3Bhbj4nXG5cbiAgICBTZWUgaHRtbC50ZXN0LmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuXG4gICAgUmVxdWlyZW1lbnRzOlxuICAgIC0gRm9yIGVhY2ggYmxvY2sgb2YgdGhlIGNvbW1hbmQsIHRoZXJlIG11c3QgYmUgZXhhY3RseSBvbmUgXCJibG9jayBjb250ZW50XG4gICAgICBtYXJrZXJcIiBvZiB0aGUgZm9ybSAnJjxudW1iZXI+JyB3aGVyZSA8bnVtYmVyPiBpcyB0aGUgMC1iYXNlZCBpbmRleCBvZiB0aGVcbiAgICAgIGJsb2NrLiAoTGlrZSB0aGUgTGFUZVggXFxuZXdjb21tYW5kIHN5bnRheCwgYnV0IHdpdGggYSAwLWJhc2VkIHJhdGhlciB0aGFuXG4gICAgICAxLWJhc2VkIGluZGV4LCBiZWNhdXNlIEphdmFTY3JpcHQgYmVjYXVzZSBDIGJlY2F1c2UgRGlqa3N0cmEuKVxuICAgIC0gVGhlIGJsb2NrIGNvbnRlbnQgbWFya2VyIG11c3QgYmUgdGhlIHNvbGUgY29udGVudHMgb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgIGVsZW1lbnQsIHRoZXJlIGNhbid0IGV2ZW4gYmUgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSwgb3IgZWxzZSB3ZSBjYW4ndFxuICAgICAgZ3VhcmFudGVlIHN0aWNraW5nIHRvIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBibG9jayBjb250ZW50IG1hcmtlciB3aGVuXG4gICAgICBtdWNraW5nIHdpdGggdGhlIEhUTUwgRE9NLlxuICAgIC0gVGhlIEhUTUwgbm90IG9ubHkgbXVzdCBiZSB3ZWxsLWZvcm1lZCBIVE1MIChvZiBjb3Vyc2UpLCBidXQgYWxzbyBtdXN0XG4gICAgICBjb25mb3JtIHRvIHRoZSBYSFRNTCByZXF1aXJlbWVudHMgb24gdGFncywgc3BlY2lmaWNhbGx5IGFsbCB0YWdzIG11c3RcbiAgICAgIGVpdGhlciBiZSBzZWxmLWNsb3NpbmcgKGxpa2UgJzxici8+Jykgb3IgY29tZSBpbiBtYXRjaGluZyBwYWlycy5cbiAgICAgIENsb3NlIHRhZ3MgYXJlIG5ldmVyIG9wdGlvbmFsLlxuXG4gICAgTm90ZSB0aGF0ICY8bnVtYmVyPiBpc24ndCB3ZWxsLWZvcm1lZCBIVE1MOyBpZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCAnJjEyMycsXG4gICAgeW91ciBIVE1MIHRlbXBsYXRlIHdvdWxkIGhhdmUgdG8gaGF2ZSAnJmFtcDsxMjMnLlxuICAqL1xuICBfLm51bUJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5odG1sVGVtcGxhdGUubWF0Y2goLyZcXGQrL2cpO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5sZW5ndGggOiAwO1xuICB9O1xuICBfLmh0bWwgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBSZW5kZXIgdGhlIGVudGlyZSBtYXRoIHN1YnRyZWUgcm9vdGVkIGF0IHRoaXMgY29tbWFuZCwgYXMgSFRNTC5cbiAgICAvLyBFeHBlY3RzIC5jcmVhdGVCbG9ja3MoKSB0byBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHksIHNpbmNlIGl0IHVzZXMgdGhlXG4gICAgLy8gLmJsb2NrcyBhcnJheSBvZiBjaGlsZCBibG9ja3MuXG4gICAgLy9cbiAgICAvLyBTZWUgaHRtbC50ZXN0LmpzIGZvciBleGFtcGxlIHRlbXBsYXRlcyBhbmQgaW50ZW5kZWQgb3V0cHV0cy5cbiAgICAvL1xuICAgIC8vIEdpdmVuIGFuIC5odG1sVGVtcGxhdGUgYXMgZGVzY3JpYmVkIGFib3ZlLFxuICAgIC8vIC0gaW5zZXJ0IHRoZSBtYXRocXVpbGwtY29tbWFuZC1pZCBhdHRyaWJ1dGUgaW50byBhbGwgdG9wLWxldmVsIHRhZ3MsXG4gICAgLy8gICB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoaXMualEgaW4gLmpRaXplKCkuXG4gICAgLy8gICBUaGlzIGlzIHN0cmFpZ2h0Zm9yd2FyZDpcbiAgICAvLyAgICAgKiB0b2tlbml6ZSBpbnRvIHRhZ3MgYW5kIG5vbi10YWdzXG4gICAgLy8gICAgICogbG9vcCB0aHJvdWdoIHRvcC1sZXZlbCB0b2tlbnM6XG4gICAgLy8gICAgICAgICAqIGFkZCAjY21kSWQgYXR0cmlidXRlIG1hY3JvIHRvIHRvcC1sZXZlbCBzZWxmLWNsb3NpbmcgdGFnc1xuICAgIC8vICAgICAgICAgKiBlbHNlIGFkZCAjY21kSWQgYXR0cmlidXRlIG1hY3JvIHRvIHRvcC1sZXZlbCBvcGVuIHRhZ3NcbiAgICAvLyAgICAgICAgICAgICAqIHNraXAgdGhlIG1hdGNoaW5nIHRvcC1sZXZlbCBjbG9zZSB0YWcgYW5kIGFsbCB0YWcgcGFpcnNcbiAgICAvLyAgICAgICAgICAgICAgIGluIGJldHdlZW5cbiAgICAvLyAtIGZvciBlYWNoIGJsb2NrIGNvbnRlbnQgbWFya2VyLFxuICAgIC8vICAgICArIHJlcGxhY2UgaXQgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgYmxvY2ssXG4gICAgLy8gICAgICAgcmVuZGVyZWQgYXMgSFRNTFxuICAgIC8vICAgICArIGluc2VydCB0aGUgbWF0aHF1aWxsLWJsb2NrLWlkIGF0dHJpYnV0ZSBpbnRvIHRoZSBjb250YWluaW5nIHRhZ1xuICAgIC8vICAgVGhpcyBpcyBldmVuIGVhc2llciwgYSBxdWljayByZWdleCByZXBsYWNlLCBzaW5jZSBibG9jayB0YWdzIGNhbm5vdFxuICAgIC8vICAgY29udGFpbiBhbnl0aGluZyBiZXNpZGVzIHRoZSBibG9jayBjb250ZW50IG1hcmtlci5cbiAgICAvL1xuICAgIC8vIFR3byBub3RlczpcbiAgICAvLyAtIFRoZSBvdXRlcm1vc3QgbG9vcCB0aHJvdWdoIHRvcC1sZXZlbCB0b2tlbnMgc2hvdWxkIG5ldmVyIGVuY291bnRlciBhbnlcbiAgICAvLyAgIHRvcC1sZXZlbCBjbG9zZSB0YWdzLCBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGZpcnN0IGVuY291bnRlcmVkIGFcbiAgICAvLyAgIG1hdGNoaW5nIHRvcC1sZXZlbCBvcGVuIHRhZywgYWxsIGlubmVyIHRhZ3Mgc2hvdWxkIGhhdmUgYXBwZWFyZWQgaW5cbiAgICAvLyAgIG1hdGNoaW5nIHBhaXJzIGFuZCBiZWVuIHNraXBwZWQsIGFuZCB0aGVuIHdlIHNob3VsZCBoYXZlIHNraXBwZWQgdGhlXG4gICAgLy8gICBjbG9zZSB0YWcgaW4gcXVlc3Rpb24uXG4gICAgLy8gLSBBbGwgb3BlbiB0YWdzIHNob3VsZCBoYXZlIG1hdGNoaW5nIGNsb3NlIHRhZ3MsIHdoaWNoIG1lYW5zIG91ciBpbm5lclxuICAgIC8vICAgbG9vcCBzaG91bGQgYWx3YXlzIGVuY291bnRlciBhIGNsb3NlIHRhZyBhbmQgZHJvcCBuZXN0aW5nIHRvIDAuIElmXG4gICAgLy8gICBhIGNsb3NlIHRhZyBpcyBtaXNzaW5nLCB0aGUgbG9vcCB3aWxsIGNvbnRpbnVlIHVudGlsIGkgPj0gdG9rZW5zLmxlbmd0aFxuICAgIC8vICAgYW5kIHRva2VuIGJlY29tZXMgdW5kZWZpbmVkLiBUaGlzIHdpbGwgbm90IGluZmluaXRlIGxvb3AsIGV2ZW4gaW5cbiAgICAvLyAgIHByb2R1Y3Rpb24gd2l0aG91dCBwcmF5KCksIGJlY2F1c2UgaXQgd2lsbCB0aGVuIFR5cGVFcnJvciBvbiAuc2xpY2UoKS5cblxuICAgIHZhciBjbWQgPSB0aGlzO1xuICAgIHZhciBibG9ja3MgPSBjbWQuYmxvY2tzO1xuICAgIHZhciBjbWRJZCA9ICcgbWF0aHF1aWxsLWNvbW1hbmQtaWQ9JyArIGNtZC5pZDtcbiAgICB2YXIgdG9rZW5zID0gY21kLmh0bWxUZW1wbGF0ZS5tYXRjaCgvPFtePD5dKz58W148Pl0rL2cpO1xuXG4gICAgcHJheSgnbm8gdW5tYXRjaGVkIGFuZ2xlIGJyYWNrZXRzJywgdG9rZW5zLmpvaW4oJycpID09PSB0aGlzLmh0bWxUZW1wbGF0ZSk7XG5cbiAgICAvLyBhZGQgY21kSWQgdG8gYWxsIHRvcC1sZXZlbCB0YWdzXG4gICAgZm9yICh2YXIgaSA9IDAsIHRva2VuID0gdG9rZW5zWzBdOyB0b2tlbjsgaSArPSAxLCB0b2tlbiA9IHRva2Vuc1tpXSkge1xuICAgICAgLy8gdG9wLWxldmVsIHNlbGYtY2xvc2luZyB0YWdzXG4gICAgICBpZiAodG9rZW4uc2xpY2UoLTIpID09PSAnLz4nKSB7XG4gICAgICAgIHRva2Vuc1tpXSA9IHRva2VuLnNsaWNlKDAsLTIpICsgY21kSWQgKyAnLz4nO1xuICAgICAgfVxuICAgICAgLy8gdG9wLWxldmVsIG9wZW4gdGFnc1xuICAgICAgZWxzZSBpZiAodG9rZW4uY2hhckF0KDApID09PSAnPCcpIHtcbiAgICAgICAgcHJheSgnbm90IGFuIHVubWF0Y2hlZCB0b3AtbGV2ZWwgY2xvc2UgdGFnJywgdG9rZW4uY2hhckF0KDEpICE9PSAnLycpO1xuXG4gICAgICAgIHRva2Vuc1tpXSA9IHRva2VuLnNsaWNlKDAsLTEpICsgY21kSWQgKyAnPic7XG5cbiAgICAgICAgLy8gc2tpcCBtYXRjaGluZyB0b3AtbGV2ZWwgY2xvc2UgdGFnIGFuZCBhbGwgdGFnIHBhaXJzIGluIGJldHdlZW5cbiAgICAgICAgdmFyIG5lc3RpbmcgPSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaSArPSAxLCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICBwcmF5KCdubyBtaXNzaW5nIGNsb3NlIHRhZ3MnLCB0b2tlbik7XG4gICAgICAgICAgLy8gY2xvc2UgdGFnc1xuICAgICAgICAgIGlmICh0b2tlbi5zbGljZSgwLDIpID09PSAnPC8nKSB7XG4gICAgICAgICAgICBuZXN0aW5nIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vbi1zZWxmLWNsb3Npbmcgb3BlbiB0YWdzXG4gICAgICAgICAgZWxzZSBpZiAodG9rZW4uY2hhckF0KDApID09PSAnPCcgJiYgdG9rZW4uc2xpY2UoLTIpICE9PSAnLz4nKSB7XG4gICAgICAgICAgICBuZXN0aW5nICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMuam9pbignJykucmVwbGFjZSgvPiYoXFxkKykvZywgZnVuY3Rpb24oJDAsICQxKSB7XG4gICAgICByZXR1cm4gJyBtYXRocXVpbGwtYmxvY2staWQ9JyArIGJsb2Nrc1skMV0uaWQgKyAnPicgKyBibG9ja3NbJDFdLmpvaW4oJ2h0bWwnKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBtZXRob2RzIHRvIGV4cG9ydCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0aCB0cmVlXG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkQ2hpbGRyZW4odGhpcy5jdHJsU2VxLCBmdW5jdGlvbihsYXRleCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBsYXRleCArICd7JyArIChjaGlsZC5sYXRleCgpIHx8ICcgJykgKyAnfSc7XG4gICAgfSk7XG4gIH07XG4gIF8udGV4dFRlbXBsYXRlID0gWycnXTtcbiAgXy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNtZCA9IHRoaXMsIGkgPSAwO1xuICAgIHJldHVybiBjbWQuZm9sZENoaWxkcmVuKGNtZC50ZXh0VGVtcGxhdGVbaV0sIGZ1bmN0aW9uKHRleHQsIGNoaWxkKSB7XG4gICAgICBpICs9IDE7XG4gICAgICB2YXIgY2hpbGRfdGV4dCA9IGNoaWxkLnRleHQoKTtcbiAgICAgIGlmICh0ZXh0ICYmIGNtZC50ZXh0VGVtcGxhdGVbaV0gPT09ICcoJ1xuICAgICAgICAgICYmIGNoaWxkX3RleHRbMF0gPT09ICcoJyAmJiBjaGlsZF90ZXh0LnNsaWNlKC0xKSA9PT0gJyknKVxuICAgICAgICByZXR1cm4gdGV4dCArIGNoaWxkX3RleHQuc2xpY2UoMSwgLTEpICsgY21kLnRleHRUZW1wbGF0ZVtpXTtcbiAgICAgIHJldHVybiB0ZXh0ICsgY2hpbGQudGV4dCgpICsgKGNtZC50ZXh0VGVtcGxhdGVbaV0gfHwgJycpO1xuICAgIH0pO1xuICB9O1xufSk7XG5cbi8qKlxuICogTGlnaHR3ZWlnaHQgY29tbWFuZCB3aXRob3V0IGJsb2NrcyBvciBjaGlsZHJlbi5cbiAqL1xudmFyIFN5bWJvbCA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjdHJsU2VxLCBodG1sLCB0ZXh0KSB7XG4gICAgaWYgKCF0ZXh0KSB0ZXh0ID0gY3RybFNlcSAmJiBjdHJsU2VxLmxlbmd0aCA+IDEgPyBjdHJsU2VxLnNsaWNlKDEpIDogY3RybFNlcTtcblxuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgY3RybFNlcSwgaHRtbCwgWyB0ZXh0IF0pO1xuICB9O1xuXG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7IHJldHVybiBQYXJzZXIuc3VjY2VlZCh0aGlzKTsgfTtcbiAgXy5udW1CbG9ja3MgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cbiAgXy5yZXBsYWNlcyA9IGZ1bmN0aW9uKHJlcGxhY2VkRnJhZ21lbnQpIHtcbiAgICByZXBsYWNlZEZyYWdtZW50LnJlbW92ZSgpO1xuICB9O1xuICBfLmNyZWF0ZUJsb2NrcyA9IG5vb3A7XG5cbiAgXy5tb3ZlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgY3Vyc29yLmpRLmluc0Rpck9mKGRpciwgdGhpcy5qUSk7XG4gICAgY3Vyc29yWy1kaXJdID0gdGhpcztcbiAgICBjdXJzb3JbZGlyXSA9IHRoaXNbZGlyXTtcbiAgfTtcbiAgXy5kZWxldGVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBjdXJzb3JbZGlyXSA9IHRoaXMucmVtb3ZlKClbZGlyXTtcbiAgfTtcbiAgXy5zZWVrID0gZnVuY3Rpb24ocGFnZVgsIGN1cnNvcikge1xuICAgIC8vIGluc2VydCBhdCB3aGljaGV2ZXIgc2lkZSB0aGUgY2xpY2sgd2FzIGNsb3NlciB0b1xuICAgIGlmIChwYWdlWCAtIHRoaXMualEub2Zmc2V0KCkubGVmdCA8IHRoaXMualEub3V0ZXJXaWR0aCgpLzIpXG4gICAgICBjdXJzb3IuaW5zTGVmdE9mKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGN1cnNvci5pbnNSaWdodE9mKHRoaXMpO1xuICB9O1xuXG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5jdHJsU2VxOyB9O1xuICBfLnRleHQgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy50ZXh0VGVtcGxhdGU7IH07XG4gIF8ucGxhY2VDdXJzb3IgPSBub29wO1xuICBfLmlzRW1wdHkgPSBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZTsgfTtcbn0pO1xudmFyIFZhbmlsbGFTeW1ib2wgPSBQKFN5bWJvbCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGNoLCBodG1sKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCBjaCwgJzxzcGFuPicrKGh0bWwgfHwgY2gpKyc8L3NwYW4+Jyk7XG4gIH07XG59KTtcbnZhciBCaW5hcnlPcGVyYXRvciA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY3RybFNlcSwgaHRtbCwgdGV4dCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcyxcbiAgICAgIGN0cmxTZXEsICc8c3BhbiBjbGFzcz1cIm1xLWJpbmFyeS1vcGVyYXRvclwiPicraHRtbCsnPC9zcGFuPicsIHRleHRcbiAgICApO1xuICB9O1xufSk7XG5cbi8qKlxuICogQ2hpbGRyZW4gYW5kIHBhcmVudCBvZiBNYXRoQ29tbWFuZCdzLiBCYXNpY2FsbHkgcGFydGl0aW9ucyBhbGwgdGhlXG4gKiBzeW1ib2xzIGFuZCBvcGVyYXRvcnMgdGhhdCBkZXNjZW5kIChpbiB0aGUgTWF0aCBET00gdHJlZSkgZnJvbVxuICogYW5jZXN0b3Igb3BlcmF0b3JzLlxuICovXG52YXIgTWF0aEJsb2NrID0gUChNYXRoRWxlbWVudCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uam9pbiA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkQ2hpbGRyZW4oJycsIGZ1bmN0aW9uKGZvbGQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gZm9sZCArIGNoaWxkW21ldGhvZE5hbWVdKCk7XG4gICAgfSk7XG4gIH07XG4gIF8uaHRtbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5qb2luKCdodG1sJyk7IH07XG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuam9pbignbGF0ZXgnKTsgfTtcbiAgXy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmVuZHNbTF0gPT09IHRoaXMuZW5kc1tSXSAmJiB0aGlzLmVuZHNbTF0gIT09IDApID9cbiAgICAgIHRoaXMuZW5kc1tMXS50ZXh0KCkgOlxuICAgICAgdGhpcy5qb2luKCd0ZXh0JylcbiAgICA7XG4gIH07XG5cbiAgXy5rZXlzdHJva2UgPSBmdW5jdGlvbihrZXksIGUsIGN0cmxyKSB7XG4gICAgaWYgKGN0cmxyLm9wdGlvbnMuc3BhY2VCZWhhdmVzTGlrZVRhYlxuICAgICAgICAmJiAoa2V5ID09PSAnU3BhY2ViYXInIHx8IGtleSA9PT0gJ1NoaWZ0LVNwYWNlYmFyJykpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGN0cmxyLmVzY2FwZURpcihrZXkgPT09ICdTaGlmdC1TcGFjZWJhcicgPyBMIDogUiwga2V5LCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyXy5rZXlzdHJva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBlZGl0YWJpbGl0eSBtZXRob2RzOiBjYWxsZWQgYnkgdGhlIGN1cnNvciBmb3IgZWRpdGluZywgY3Vyc29yIG1vdmVtZW50cyxcbiAgLy8gYW5kIHNlbGVjdGlvbiBvZiB0aGUgTWF0aFF1aWxsIHRyZWUsIHRoZXNlIGFsbCB0YWtlIGluIGEgZGlyZWN0aW9uIGFuZFxuICAvLyB0aGUgY3Vyc29yXG4gIF8ubW92ZU91dE9mID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IsIHVwZG93bikge1xuICAgIHZhciB1cGRvd25JbnRvID0gdXBkb3duICYmIHRoaXMucGFyZW50W3VwZG93bisnSW50byddO1xuICAgIGlmICghdXBkb3duSW50byAmJiB0aGlzW2Rpcl0pIGN1cnNvci5pbnNBdERpckVuZCgtZGlyLCB0aGlzW2Rpcl0pO1xuICAgIGVsc2UgY3Vyc29yLmluc0Rpck9mKGRpciwgdGhpcy5wYXJlbnQpO1xuICB9O1xuICBfLnNlbGVjdE91dE9mID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBjdXJzb3IuaW5zRGlyT2YoZGlyLCB0aGlzLnBhcmVudCk7XG4gIH07XG4gIF8uZGVsZXRlT3V0T2YgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGN1cnNvci51bndyYXBHcmFtcCgpO1xuICB9O1xuICBfLnNlZWsgPSBmdW5jdGlvbihwYWdlWCwgY3Vyc29yKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmVuZHNbUl07XG4gICAgaWYgKCFub2RlIHx8IG5vZGUualEub2Zmc2V0KCkubGVmdCArIG5vZGUualEub3V0ZXJXaWR0aCgpIDwgcGFnZVgpIHtcbiAgICAgIHJldHVybiBjdXJzb3IuaW5zQXRSaWdodEVuZCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHBhZ2VYIDwgdGhpcy5lbmRzW0xdLmpRLm9mZnNldCgpLmxlZnQpIHJldHVybiBjdXJzb3IuaW5zQXRMZWZ0RW5kKHRoaXMpO1xuICAgIHdoaWxlIChwYWdlWCA8IG5vZGUualEub2Zmc2V0KCkubGVmdCkgbm9kZSA9IG5vZGVbTF07XG4gICAgcmV0dXJuIG5vZGUuc2VlayhwYWdlWCwgY3Vyc29yKTtcbiAgfTtcbiAgXy5jaFRvQ21kID0gZnVuY3Rpb24oY2gpIHtcbiAgICB2YXIgY29ucztcbiAgICAvLyBleGNsdWRlIGYgYmVjYXVzZSBpdCBnZXRzIGEgZGVkaWNhdGVkIGNvbW1hbmQgd2l0aCBtb3JlIHNwYWNpbmdcbiAgICBpZiAoY2gubWF0Y2goL15bYS1lZy16QS1aXSQvKSlcbiAgICAgIHJldHVybiBMZXR0ZXIoY2gpO1xuICAgIGVsc2UgaWYgKC9eXFxkJC8udGVzdChjaCkpXG4gICAgICByZXR1cm4gRGlnaXQoY2gpO1xuICAgIGVsc2UgaWYgKGNvbnMgPSBDaGFyQ21kc1tjaF0gfHwgTGF0ZXhDbWRzW2NoXSlcbiAgICAgIHJldHVybiBjb25zKGNoKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gVmFuaWxsYVN5bWJvbChjaCk7XG4gIH07XG4gIF8ud3JpdGUgPSBmdW5jdGlvbihjdXJzb3IsIGNoKSB7XG4gICAgdmFyIGNtZCA9IHRoaXMuY2hUb0NtZChjaCk7XG4gICAgaWYgKGN1cnNvci5zZWxlY3Rpb24pIGNtZC5yZXBsYWNlcyhjdXJzb3IucmVwbGFjZVNlbGVjdGlvbigpKTtcbiAgICBjbWQuY3JlYXRlTGVmdE9mKGN1cnNvci5zaG93KCkpO1xuICB9O1xuXG4gIF8uZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmpRLmFkZENsYXNzKCdtcS1oYXNDdXJzb3InKTtcbiAgICB0aGlzLmpRLnJlbW92ZUNsYXNzKCdtcS1lbXB0eScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF8uYmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMualEucmVtb3ZlQ2xhc3MoJ21xLWhhc0N1cnNvcicpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSlcbiAgICAgIHRoaXMualEuYWRkQ2xhc3MoJ21xLWVtcHR5Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5BUEkuU3RhdGljTWF0aCA9IGZ1bmN0aW9uKEFQSUNsYXNzZXMpIHtcbiAgcmV0dXJuIFAoQVBJQ2xhc3Nlcy5BYnN0cmFjdE1hdGhRdWlsbCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gICAgdGhpcy5Sb290QmxvY2sgPSBNYXRoQmxvY2s7XG4gICAgXy5fX21hdGhxdWlsbGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgc3VwZXJfLl9fbWF0aHF1aWxsaWZ5LmNhbGwodGhpcywgJ21xLW1hdGgtbW9kZScpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuZGVsZWdhdGVNb3VzZUV2ZW50cygpO1xuICAgICAgdGhpcy5fX2NvbnRyb2xsZXIuc3RhdGljTWF0aFRleHRhcmVhRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc3VwZXJfLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX19jb250cm9sbGVyLnJvb3QucG9zdE9yZGVyKFxuICAgICAgICAncmVnaXN0ZXJJbm5lckZpZWxkJywgdGhpcy5pbm5lckZpZWxkcyA9IFtdLCBBUElDbGFzc2VzLk1hdGhGaWVsZCk7XG4gICAgfTtcbiAgICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmV0dXJuZWQgPSBzdXBlcl8ubGF0ZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlci5yb290LnBvc3RPcmRlcihcbiAgICAgICAgICAncmVnaXN0ZXJJbm5lckZpZWxkJywgdGhpcy5pbm5lckZpZWxkcyA9IFtdLCBBUElDbGFzc2VzLk1hdGhGaWVsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgfSk7XG59O1xuXG52YXIgUm9vdE1hdGhCbG9jayA9IFAoTWF0aEJsb2NrLCBSb290QmxvY2tNaXhpbik7XG5BUEkuTWF0aEZpZWxkID0gZnVuY3Rpb24oQVBJQ2xhc3Nlcykge1xuICByZXR1cm4gUChBUElDbGFzc2VzLkVkaXRhYmxlRmllbGQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICAgIHRoaXMuUm9vdEJsb2NrID0gUm9vdE1hdGhCbG9jaztcbiAgICBfLl9fbWF0aHF1aWxsaWZ5ID0gZnVuY3Rpb24ob3B0cywgaW50ZXJmYWNlVmVyc2lvbikge1xuICAgICAgdGhpcy5jb25maWcob3B0cyk7XG4gICAgICBpZiAoaW50ZXJmYWNlVmVyc2lvbiA+IDEpIHRoaXMuX19jb250cm9sbGVyLnJvb3QucmVmbG93ID0gbm9vcDtcbiAgICAgIHN1cGVyXy5fX21hdGhxdWlsbGlmeS5jYWxsKHRoaXMsICdtcS1lZGl0YWJsZS1maWVsZCBtcS1tYXRoLW1vZGUnKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9fY29udHJvbGxlci5yb290LnJlZmxvdztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xufTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBBYnN0cmFjdCBjbGFzc2VzIG9mIHRleHQgYmxvY2tzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEJsb2NrcyBvZiBwbGFpbiB0ZXh0LCB3aXRoIG9uZSBvciB0d28gVGV4dFBpZWNlJ3MgYXMgY2hpbGRyZW4uXG4gKiBSZXByZXNlbnRzIGZsYXQgc3RyaW5ncyBvZiB0eXBpY2FsbHkgc2VyaWYtZm9udCBSb21hbiBjaGFyYWN0ZXJzLCBhc1xuICogb3Bwb3NlZCB0byBoaWVyY2hpY2FsLCBuZXN0ZWQsIHRyZWUtc3RydWN0dXJlZCBtYXRoLlxuICogV3JhcHMgYSBzaW5nbGUgSFRNTFNwYW5FbGVtZW50LlxuICovXG52YXIgVGV4dEJsb2NrID0gUChOb2RlLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFx0ZXh0JztcblxuICBfLnJlcGxhY2VzID0gZnVuY3Rpb24ocmVwbGFjZWRUZXh0KSB7XG4gICAgaWYgKHJlcGxhY2VkVGV4dCBpbnN0YW5jZW9mIEZyYWdtZW50KVxuICAgICAgdGhpcy5yZXBsYWNlZFRleHQgPSByZXBsYWNlZFRleHQucmVtb3ZlKCkualEudGV4dCgpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiByZXBsYWNlZFRleHQgPT09ICdzdHJpbmcnKVxuICAgICAgdGhpcy5yZXBsYWNlZFRleHQgPSByZXBsYWNlZFRleHQ7XG4gIH07XG5cbiAgXy5qUWFkZCA9IGZ1bmN0aW9uKGpRKSB7XG4gICAgc3VwZXJfLmpRYWRkLmNhbGwodGhpcywgalEpO1xuICAgIGlmICh0aGlzLmVuZHNbTF0pIHRoaXMuZW5kc1tMXS5qUWFkZCh0aGlzLmpRWzBdLmZpcnN0Q2hpbGQpO1xuICB9O1xuXG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgdmFyIHRleHRCbG9jayA9IHRoaXM7XG4gICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5jYWxsKHRoaXMsIGN1cnNvcik7XG5cbiAgICBpZiAodGV4dEJsb2NrW1JdLnNpYmxpbmdDcmVhdGVkKSB0ZXh0QmxvY2tbUl0uc2libGluZ0NyZWF0ZWQoY3Vyc29yLm9wdGlvbnMsIEwpO1xuICAgIGlmICh0ZXh0QmxvY2tbTF0uc2libGluZ0NyZWF0ZWQpIHRleHRCbG9ja1tMXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgdGV4dEJsb2NrLmJ1YmJsZSgncmVmbG93Jyk7XG5cbiAgICBjdXJzb3IuaW5zQXRSaWdodEVuZCh0ZXh0QmxvY2spO1xuXG4gICAgaWYgKHRleHRCbG9jay5yZXBsYWNlZFRleHQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRCbG9jay5yZXBsYWNlZFRleHQubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHRleHRCbG9jay53cml0ZShjdXJzb3IsIHRleHRCbG9jay5yZXBsYWNlZFRleHQuY2hhckF0KGkpKTtcbiAgfTtcblxuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXh0QmxvY2sgPSB0aGlzO1xuXG4gICAgLy8gVE9ETzogY29ycmVjdGx5IHBhcnNlIHRleHQgbW9kZVxuICAgIHZhciBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nO1xuICAgIHZhciByZWdleCA9IFBhcnNlci5yZWdleDtcbiAgICB2YXIgb3B0V2hpdGVzcGFjZSA9IFBhcnNlci5vcHRXaGl0ZXNwYWNlO1xuICAgIHJldHVybiBvcHRXaGl0ZXNwYWNlXG4gICAgICAudGhlbihzdHJpbmcoJ3snKSkudGhlbihyZWdleCgvXltefV0qLykpLnNraXAoc3RyaW5nKCd9JykpXG4gICAgICAubWFwKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSByZXR1cm4gRnJhZ21lbnQoKTtcblxuICAgICAgICBUZXh0UGllY2UodGV4dCkuYWRvcHQodGV4dEJsb2NrLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHRCbG9jaztcbiAgICAgIH0pXG4gICAgO1xuICB9O1xuXG4gIF8udGV4dENvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZENoaWxkcmVuKCcnLCBmdW5jdGlvbih0ZXh0LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHRleHQgKyBjaGlsZC50ZXh0O1xuICAgIH0pO1xuICB9O1xuICBfLnRleHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdcIicgKyB0aGlzLnRleHRDb250ZW50cygpICsgJ1wiJzsgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZW50cyA9IHRoaXMudGV4dENvbnRlbnRzKCk7XG4gICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHJldHVybiAnXFxcXHRleHR7JyArIGNvbnRlbnRzICsgJ30nO1xuICB9O1xuICBfLmh0bWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJtcS10ZXh0LW1vZGVcIiBtYXRocXVpbGwtY29tbWFuZC1pZD0nK3RoaXMuaWQrJz4nXG4gICAgICArICAgdGhpcy50ZXh0Q29udGVudHMoKVxuICAgICAgKyAnPC9zcGFuPidcbiAgICApO1xuICB9O1xuXG4gIC8vIGVkaXRhYmlsaXR5IG1ldGhvZHM6IGNhbGxlZCBieSB0aGUgY3Vyc29yIGZvciBlZGl0aW5nLCBjdXJzb3IgbW92ZW1lbnRzLFxuICAvLyBhbmQgc2VsZWN0aW9uIG9mIHRoZSBNYXRoUXVpbGwgdHJlZSwgdGhlc2UgYWxsIHRha2UgaW4gYSBkaXJlY3Rpb24gYW5kXG4gIC8vIHRoZSBjdXJzb3JcbiAgXy5tb3ZlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7IGN1cnNvci5pbnNBdERpckVuZCgtZGlyLCB0aGlzKTsgfTtcbiAgXy5tb3ZlT3V0T2YgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikgeyBjdXJzb3IuaW5zRGlyT2YoZGlyLCB0aGlzKTsgfTtcbiAgXy51bnNlbGVjdEludG8gPSBfLm1vdmVUb3dhcmRzO1xuXG4gIC8vIFRPRE86IG1ha2UgdGhlc2UgbWV0aG9kcyBwYXJ0IG9mIGEgc2hhcmVkIG1peGluIG9yIHNvbWV0aGluZy5cbiAgXy5zZWxlY3RUb3dhcmRzID0gTWF0aENvbW1hbmQucHJvdG90eXBlLnNlbGVjdFRvd2FyZHM7XG4gIF8uZGVsZXRlVG93YXJkcyA9IE1hdGhDb21tYW5kLnByb3RvdHlwZS5kZWxldGVUb3dhcmRzO1xuXG4gIF8uc2VsZWN0T3V0T2YgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGN1cnNvci5pbnNEaXJPZihkaXIsIHRoaXMpO1xuICB9O1xuICBfLmRlbGV0ZU91dE9mID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICAvLyBiYWNrc3BhY2UgYW5kIGRlbGV0ZSBhdCBlbmRzIG9mIGJsb2NrIGRvbid0IHVud3JhcFxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgY3Vyc29yLmluc1JpZ2h0T2YodGhpcyk7XG4gIH07XG4gIF8ud3JpdGUgPSBmdW5jdGlvbihjdXJzb3IsIGNoKSB7XG4gICAgY3Vyc29yLnNob3coKS5kZWxldGVTZWxlY3Rpb24oKTtcblxuICAgIGlmIChjaCAhPT0gJyQnKSB7XG4gICAgICBpZiAoIWN1cnNvcltMXSkgVGV4dFBpZWNlKGNoKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgIGVsc2UgY3Vyc29yW0xdLmFwcGVuZFRleHQoY2gpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgY3Vyc29yLmluc1JpZ2h0T2YodGhpcyk7XG4gICAgICBWYW5pbGxhU3ltYm9sKCdcXFxcJCcsJyQnKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWN1cnNvcltSXSkgY3Vyc29yLmluc1JpZ2h0T2YodGhpcyk7XG4gICAgZWxzZSBpZiAoIWN1cnNvcltMXSkgY3Vyc29yLmluc0xlZnRPZih0aGlzKTtcbiAgICBlbHNlIHsgLy8gc3BsaXQgYXBhcnRcbiAgICAgIHZhciBsZWZ0QmxvY2sgPSBUZXh0QmxvY2soKTtcbiAgICAgIHZhciBsZWZ0UGMgPSB0aGlzLmVuZHNbTF07XG4gICAgICBsZWZ0UGMuZGlzb3duKCkualEuZGV0YWNoKCk7XG4gICAgICBsZWZ0UGMuYWRvcHQobGVmdEJsb2NrLCAwLCAwKTtcblxuICAgICAgY3Vyc29yLmluc0xlZnRPZih0aGlzKTtcbiAgICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbChsZWZ0QmxvY2ssIGN1cnNvcik7XG4gICAgfVxuICB9O1xuXG4gIF8uc2VlayA9IGZ1bmN0aW9uKHBhZ2VYLCBjdXJzb3IpIHtcbiAgICBjdXJzb3IuaGlkZSgpO1xuICAgIHZhciB0ZXh0UGMgPSBmdXNlQ2hpbGRyZW4odGhpcyk7XG5cbiAgICAvLyBpbnNlcnQgY3Vyc29yIGF0IGFwcHJveCBwb3NpdGlvbiBpbiBET01UZXh0Tm9kZVxuICAgIHZhciBhdmdDaFdpZHRoID0gdGhpcy5qUS53aWR0aCgpL3RoaXMudGV4dC5sZW5ndGg7XG4gICAgdmFyIGFwcHJveFBvc2l0aW9uID0gTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLmpRLm9mZnNldCgpLmxlZnQpL2F2Z0NoV2lkdGgpO1xuICAgIGlmIChhcHByb3hQb3NpdGlvbiA8PSAwKSBjdXJzb3IuaW5zQXRMZWZ0RW5kKHRoaXMpO1xuICAgIGVsc2UgaWYgKGFwcHJveFBvc2l0aW9uID49IHRleHRQYy50ZXh0Lmxlbmd0aCkgY3Vyc29yLmluc0F0UmlnaHRFbmQodGhpcyk7XG4gICAgZWxzZSBjdXJzb3IuaW5zTGVmdE9mKHRleHRQYy5zcGxpdFJpZ2h0KGFwcHJveFBvc2l0aW9uKSk7XG5cbiAgICAvLyBtb3ZlIHRvd2FyZHMgbW91c2Vkb3duIChwYWdlWClcbiAgICB2YXIgZGlzcGwgPSBwYWdlWCAtIGN1cnNvci5zaG93KCkub2Zmc2V0KCkubGVmdDsgLy8gZGlzcGxhY2VtZW50XG4gICAgdmFyIGRpciA9IGRpc3BsICYmIGRpc3BsIDwgMCA/IEwgOiBSO1xuICAgIHZhciBwcmV2RGlzcGwgPSBkaXI7XG4gICAgLy8gZGlzcGwgKiBwcmV2RGlzcGwgPiAwIGlmZiBkaXNwbGFjZW1lbnQgZGlyZWN0aW9uID09PSBwcmV2aW91cyBkaXJlY3Rpb25cbiAgICB3aGlsZSAoY3Vyc29yW2Rpcl0gJiYgZGlzcGwgKiBwcmV2RGlzcGwgPiAwKSB7XG4gICAgICBjdXJzb3JbZGlyXS5tb3ZlVG93YXJkcyhkaXIsIGN1cnNvcik7XG4gICAgICBwcmV2RGlzcGwgPSBkaXNwbDtcbiAgICAgIGRpc3BsID0gcGFnZVggLSBjdXJzb3Iub2Zmc2V0KCkubGVmdDtcbiAgICB9XG4gICAgaWYgKGRpcipkaXNwbCA8IC1kaXIqcHJldkRpc3BsKSBjdXJzb3JbLWRpcl0ubW92ZVRvd2FyZHMoLWRpciwgY3Vyc29yKTtcblxuICAgIGlmICghY3Vyc29yLmFudGljdXJzb3IpIHtcbiAgICAgIC8vIGFib3V0IHRvIHN0YXJ0IG1vdXNlLXNlbGVjdGluZywgdGhlIGFudGljdXJzb3IgaXMgZ29ubmEgZ2V0IHB1dCBoZXJlXG4gICAgICB0aGlzLmFudGljdXJzb3JQb3NpdGlvbiA9IGN1cnNvcltMXSAmJiBjdXJzb3JbTF0udGV4dC5sZW5ndGg7XG4gICAgICAvLyBeIGdldCBpdD8gJ2NvcyBpZiB0aGVyZSdzIG5vIGN1cnNvcltMXSwgaXQncyAwLi4uIEknbSBhIHRlcnJpYmxlIHBlcnNvbi5cbiAgICB9XG4gICAgZWxzZSBpZiAoY3Vyc29yLmFudGljdXJzb3IucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAvLyBtb3VzZS1zZWxlY3Rpbmcgd2l0aGluIHRoaXMgVGV4dEJsb2NrLCByZS1pbnNlcnQgdGhlIGFudGljdXJzb3JcbiAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IGN1cnNvcltMXSAmJiBjdXJzb3JbTF0udGV4dC5sZW5ndGg7O1xuICAgICAgaWYgKHRoaXMuYW50aWN1cnNvclBvc2l0aW9uID09PSBjdXJzb3JQb3NpdGlvbikge1xuICAgICAgICBjdXJzb3IuYW50aWN1cnNvciA9IFBvaW50LmNvcHkoY3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hbnRpY3Vyc29yUG9zaXRpb24gPCBjdXJzb3JQb3NpdGlvbikge1xuICAgICAgICAgIHZhciBuZXdUZXh0UGMgPSBjdXJzb3JbTF0uc3BsaXRSaWdodCh0aGlzLmFudGljdXJzb3JQb3NpdGlvbik7XG4gICAgICAgICAgY3Vyc29yW0xdID0gbmV3VGV4dFBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdUZXh0UGMgPSBjdXJzb3JbUl0uc3BsaXRSaWdodCh0aGlzLmFudGljdXJzb3JQb3NpdGlvbiAtIGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJzb3IuYW50aWN1cnNvciA9IFBvaW50KHRoaXMsIG5ld1RleHRQY1tMXSwgbmV3VGV4dFBjKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXy5ibHVyID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgTWF0aEJsb2NrLnByb3RvdHlwZS5ibHVyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFjdXJzb3IpIHJldHVybjtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudHMoKSA9PT0gJycpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICBpZiAoY3Vyc29yW0xdID09PSB0aGlzKSBjdXJzb3JbTF0gPSB0aGlzW0xdO1xuICAgICAgZWxzZSBpZiAoY3Vyc29yW1JdID09PSB0aGlzKSBjdXJzb3JbUl0gPSB0aGlzW1JdO1xuICAgIH1cbiAgICBlbHNlIGZ1c2VDaGlsZHJlbih0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmdXNlQ2hpbGRyZW4oc2VsZikge1xuICAgIHNlbGYualFbMF0ubm9ybWFsaXplKCk7XG5cbiAgICB2YXIgdGV4dFBjRG9tID0gc2VsZi5qUVswXS5maXJzdENoaWxkO1xuICAgIGlmICghdGV4dFBjRG9tKSByZXR1cm47XG4gICAgcHJheSgnb25seSBub2RlIGluIFRleHRCbG9jayBzcGFuIGlzIFRleHQgbm9kZScsIHRleHRQY0RvbS5ub2RlVHlwZSA9PT0gMyk7XG4gICAgLy8gbm9kZVR5cGUgPT09IDMgaGFzIG1lYW50IGEgVGV4dCBub2RlIHNpbmNlIGFuY2llbnQgdGltZXM6XG4gICAgLy8gICBodHRwOi8vcmVmZXJlbmNlLnNpdGVwb2ludC5jb20vamF2YXNjcmlwdC9Ob2RlL25vZGVUeXBlXG5cbiAgICB2YXIgdGV4dFBjID0gVGV4dFBpZWNlKHRleHRQY0RvbS5kYXRhKTtcbiAgICB0ZXh0UGMualFhZGQodGV4dFBjRG9tKTtcblxuICAgIHNlbGYuY2hpbGRyZW4oKS5kaXNvd24oKTtcbiAgICByZXR1cm4gdGV4dFBjLmFkb3B0KHNlbGYsIDAsIDApO1xuICB9XG5cbiAgXy5mb2N1cyA9IE1hdGhCbG9jay5wcm90b3R5cGUuZm9jdXM7XG59KTtcblxuLyoqXG4gKiBQaWVjZSBvZiBwbGFpbiB0ZXh0LCB3aXRoIGEgVGV4dEJsb2NrIGFzIGEgcGFyZW50IGFuZCBubyBjaGlsZHJlbi5cbiAqIFdyYXBzIGEgc2luZ2xlIERPTVRleHROb2RlLlxuICogRm9yIGNvbnZlbmllbmNlLCBoYXMgYSAudGV4dCBwcm9wZXJ0eSB0aGF0J3MganVzdCBhIEphdmFTY3JpcHQgc3RyaW5nXG4gKiBtaXJyb3JpbmcgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIERPTVRleHROb2RlLlxuICogVGV4dCBjb250ZW50cyBtdXN0IGFsd2F5cyBiZSBub25lbXB0eS5cbiAqL1xudmFyIFRleHRQaWVjZSA9IFAoTm9kZSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMpO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH07XG4gIF8ualFhZGQgPSBmdW5jdGlvbihkb20pIHsgdGhpcy5kb20gPSBkb207IHRoaXMualEgPSAkKGRvbSk7IH07XG4gIF8ualFpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5qUWFkZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgfTtcbiAgXy5hcHBlbmRUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIHRoaXMuZG9tLmFwcGVuZERhdGEodGV4dCk7XG4gIH07XG4gIF8ucHJlcGVuZFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dCArIHRoaXMudGV4dDtcbiAgICB0aGlzLmRvbS5pbnNlcnREYXRhKDAsIHRleHQpO1xuICB9O1xuICBfLmluc1RleHRBdERpckVuZCA9IGZ1bmN0aW9uKHRleHQsIGRpcikge1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcbiAgICBpZiAoZGlyID09PSBSKSB0aGlzLmFwcGVuZFRleHQodGV4dCk7XG4gICAgZWxzZSB0aGlzLnByZXBlbmRUZXh0KHRleHQpO1xuICB9O1xuICBfLnNwbGl0UmlnaHQgPSBmdW5jdGlvbihpKSB7XG4gICAgdmFyIG5ld1BjID0gVGV4dFBpZWNlKHRoaXMudGV4dC5zbGljZShpKSkuYWRvcHQodGhpcy5wYXJlbnQsIHRoaXMsIHRoaXNbUl0pO1xuICAgIG5ld1BjLmpRYWRkKHRoaXMuZG9tLnNwbGl0VGV4dChpKSk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiBuZXdQYztcbiAgfTtcblxuICBmdW5jdGlvbiBlbmRDaGFyKGRpciwgdGV4dCkge1xuICAgIHJldHVybiB0ZXh0LmNoYXJBdChkaXIgPT09IEwgPyAwIDogLTEgKyB0ZXh0Lmxlbmd0aCk7XG4gIH1cblxuICBfLm1vdmVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBwcmF5RGlyZWN0aW9uKGRpcik7XG5cbiAgICB2YXIgY2ggPSBlbmRDaGFyKC1kaXIsIHRoaXMudGV4dClcblxuICAgIHZhciBmcm9tID0gdGhpc1stZGlyXTtcbiAgICBpZiAoZnJvbSkgZnJvbS5pbnNUZXh0QXREaXJFbmQoY2gsIGRpcik7XG4gICAgZWxzZSBUZXh0UGllY2UoY2gpLmNyZWF0ZURpcigtZGlyLCBjdXJzb3IpO1xuXG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlVG93YXJkcyhkaXIsIGN1cnNvcik7XG4gIH07XG5cbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9O1xuXG4gIF8uZGVsZXRlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgaWYgKHRoaXMudGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoZGlyID09PSBSKSB7XG4gICAgICAgIHRoaXMuZG9tLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZXNlIDIgbGluZXMgaXMgYW5ub3lpbmdseSBpbXBvcnRhbnRcbiAgICAgICAgLy8gKHRoZSBzZWNvbmQgbGluZSBtdXRhdGVzIHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgIHRoaXMuZG9tLmRlbGV0ZURhdGEoLTEgKyB0aGlzLnRleHQubGVuZ3RoLCAxKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgdGhpcy5qUS5yZW1vdmUoKTtcbiAgICAgIGN1cnNvcltkaXJdID0gdGhpc1tkaXJdO1xuICAgIH1cbiAgfTtcblxuICBfLnNlbGVjdFRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIHByYXlEaXJlY3Rpb24oZGlyKTtcbiAgICB2YXIgYW50aWN1cnNvciA9IGN1cnNvci5hbnRpY3Vyc29yO1xuXG4gICAgdmFyIGNoID0gZW5kQ2hhcigtZGlyLCB0aGlzLnRleHQpXG5cbiAgICBpZiAoYW50aWN1cnNvcltkaXJdID09PSB0aGlzKSB7XG4gICAgICB2YXIgbmV3UGMgPSBUZXh0UGllY2UoY2gpLmNyZWF0ZURpcihkaXIsIGN1cnNvcik7XG4gICAgICBhbnRpY3Vyc29yW2Rpcl0gPSBuZXdQYztcbiAgICAgIGN1cnNvci5pbnNEaXJPZihkaXIsIG5ld1BjKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgZnJvbSA9IHRoaXNbLWRpcl07XG4gICAgICBpZiAoZnJvbSkgZnJvbS5pbnNUZXh0QXREaXJFbmQoY2gsIGRpcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1BjID0gVGV4dFBpZWNlKGNoKS5jcmVhdGVEaXIoLWRpciwgY3Vyc29yKTtcbiAgICAgICAgbmV3UGMualEuaW5zRGlyT2YoLWRpciwgY3Vyc29yLnNlbGVjdGlvbi5qUSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRleHQubGVuZ3RoID09PSAxICYmIGFudGljdXJzb3JbLWRpcl0gPT09IHRoaXMpIHtcbiAgICAgICAgYW50aWN1cnNvclstZGlyXSA9IHRoaXNbLWRpcl07IC8vIGB0aGlzYCB3aWxsIGJlIHJlbW92ZWQgaW4gZGVsZXRlVG93YXJkc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRlbGV0ZVRvd2FyZHMoZGlyLCBjdXJzb3IpO1xuICB9O1xufSk7XG5cbkNoYXJDbWRzLiQgPVxuTGF0ZXhDbWRzLnRleHQgPVxuTGF0ZXhDbWRzLnRleHRub3JtYWwgPVxuTGF0ZXhDbWRzLnRleHRybSA9XG5MYXRleENtZHMudGV4dHVwID1cbkxhdGV4Q21kcy50ZXh0bWQgPSBUZXh0QmxvY2s7XG5cbmZ1bmN0aW9uIG1ha2VUZXh0QmxvY2sobGF0ZXgsIHRhZ05hbWUsIGF0dHJzKSB7XG4gIHJldHVybiBQKFRleHRCbG9jaywge1xuICAgIGN0cmxTZXE6IGxhdGV4LFxuICAgIGh0bWxUZW1wbGF0ZTogJzwnK3RhZ05hbWUrJyAnK2F0dHJzKyc+JjA8LycrdGFnTmFtZSsnPidcbiAgfSk7XG59XG5cbkxhdGV4Q21kcy5lbSA9IExhdGV4Q21kcy5pdGFsaWMgPSBMYXRleENtZHMuaXRhbGljcyA9XG5MYXRleENtZHMuZW1waCA9IExhdGV4Q21kcy50ZXh0aXQgPSBMYXRleENtZHMudGV4dHNsID1cbiAgbWFrZVRleHRCbG9jaygnXFxcXHRleHRpdCcsICdpJywgJ2NsYXNzPVwibXEtdGV4dC1tb2RlXCInKTtcbkxhdGV4Q21kcy5zdHJvbmcgPSBMYXRleENtZHMuYm9sZCA9IExhdGV4Q21kcy50ZXh0YmYgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcdGV4dGJmJywgJ2InLCAnY2xhc3M9XCJtcS10ZXh0LW1vZGVcIicpO1xuTGF0ZXhDbWRzLnNmID0gTGF0ZXhDbWRzLnRleHRzZiA9XG4gIG1ha2VUZXh0QmxvY2soJ1xcXFx0ZXh0c2YnLCAnc3BhbicsICdjbGFzcz1cIm1xLXNhbnMtc2VyaWYgbXEtdGV4dC1tb2RlXCInKTtcbkxhdGV4Q21kcy50dCA9IExhdGV4Q21kcy50ZXh0dHQgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcdGV4dHR0JywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1tb25vc3BhY2UgbXEtdGV4dC1tb2RlXCInKTtcbkxhdGV4Q21kcy50ZXh0c2MgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcdGV4dHNjJywgJ3NwYW4nLCAnc3R5bGU9XCJmb250LXZhcmlhbnQ6c21hbGwtY2Fwc1wiIGNsYXNzPVwibXEtdGV4dC1tb2RlXCInKTtcbkxhdGV4Q21kcy51cHBlcmNhc2UgPVxuICBtYWtlVGV4dEJsb2NrKCdcXFxcdXBwZXJjYXNlJywgJ3NwYW4nLCAnc3R5bGU9XCJ0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2VcIiBjbGFzcz1cIm1xLXRleHQtbW9kZVwiJyk7XG5MYXRleENtZHMubG93ZXJjYXNlID1cbiAgbWFrZVRleHRCbG9jaygnXFxcXGxvd2VyY2FzZScsICdzcGFuJywgJ3N0eWxlPVwidGV4dC10cmFuc2Zvcm06bG93ZXJjYXNlXCIgY2xhc3M9XCJtcS10ZXh0LW1vZGVcIicpO1xuXG5cbnZhciBSb290TWF0aENvbW1hbmQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCAnJCcpO1xuICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICB9O1xuICBfLmh0bWxUZW1wbGF0ZSA9ICc8c3BhbiBjbGFzcz1cIm1xLW1hdGgtbW9kZVwiPiYwPC9zcGFuPic7XG4gIF8uY3JlYXRlQmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgc3VwZXJfLmNyZWF0ZUJsb2Nrcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5lbmRzW0xdLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xuICAgIHRoaXMuZW5kc1tMXS53cml0ZSA9IGZ1bmN0aW9uKGN1cnNvciwgY2gpIHtcbiAgICAgIGlmIChjaCAhPT0gJyQnKVxuICAgICAgICBNYXRoQmxvY2sucHJvdG90eXBlLndyaXRlLmNhbGwodGhpcywgY3Vyc29yLCBjaCk7XG4gICAgICBlbHNlIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICBjdXJzb3IuaW5zUmlnaHRPZih0aGlzLnBhcmVudCk7XG4gICAgICAgIHRoaXMucGFyZW50LmRlbGV0ZVRvd2FyZHMoZGlyLCBjdXJzb3IpO1xuICAgICAgICBWYW5pbGxhU3ltYm9sKCdcXFxcJCcsJyQnKS5jcmVhdGVMZWZ0T2YoY3Vyc29yLnNob3coKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghY3Vyc29yW1JdKVxuICAgICAgICBjdXJzb3IuaW5zUmlnaHRPZih0aGlzLnBhcmVudCk7XG4gICAgICBlbHNlIGlmICghY3Vyc29yW0xdKVxuICAgICAgICBjdXJzb3IuaW5zTGVmdE9mKHRoaXMucGFyZW50KTtcbiAgICAgIGVsc2VcbiAgICAgICAgTWF0aEJsb2NrLnByb3RvdHlwZS53cml0ZS5jYWxsKHRoaXMsIGN1cnNvciwgY2gpO1xuICAgIH07XG4gIH07XG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyQnICsgdGhpcy5lbmRzW0xdLmxhdGV4KCkgKyAnJCc7XG4gIH07XG59KTtcblxudmFyIFJvb3RUZXh0QmxvY2sgPSBQKFJvb3RNYXRoQmxvY2ssIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmtleXN0cm9rZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdTcGFjZWJhcicgfHwga2V5ID09PSAnU2hpZnQtU3BhY2ViYXInKSByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyXy5rZXlzdHJva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXy53cml0ZSA9IGZ1bmN0aW9uKGN1cnNvciwgY2gpIHtcbiAgICBjdXJzb3Iuc2hvdygpLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIGlmIChjaCA9PT0gJyQnKVxuICAgICAgUm9vdE1hdGhDb21tYW5kKGN1cnNvcikuY3JlYXRlTGVmdE9mKGN1cnNvcik7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaHRtbDtcbiAgICAgIGlmIChjaCA9PT0gJzwnKSBodG1sID0gJyZsdDsnO1xuICAgICAgZWxzZSBpZiAoY2ggPT09ICc+JykgaHRtbCA9ICcmZ3Q7JztcbiAgICAgIFZhbmlsbGFTeW1ib2woY2gsIGh0bWwpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgIH1cbiAgfTtcbn0pO1xuQVBJLlRleHRGaWVsZCA9IGZ1bmN0aW9uKEFQSUNsYXNzZXMpIHtcbiAgcmV0dXJuIFAoQVBJQ2xhc3Nlcy5FZGl0YWJsZUZpZWxkLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgICB0aGlzLlJvb3RCbG9jayA9IFJvb3RUZXh0QmxvY2s7XG4gICAgXy5fX21hdGhxdWlsbGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN1cGVyXy5fX21hdGhxdWlsbGlmeS5jYWxsKHRoaXMsICdtcS1lZGl0YWJsZS1maWVsZCBtcS10ZXh0LW1vZGUnKTtcbiAgICB9O1xuICAgIF8ubGF0ZXggPSBmdW5jdGlvbihsYXRleCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX19jb250cm9sbGVyLnJlbmRlckxhdGV4VGV4dChsYXRleCk7XG4gICAgICAgIGlmICh0aGlzLl9fY29udHJvbGxlci5ibHVycmVkKSB0aGlzLl9fY29udHJvbGxlci5jdXJzb3IuaGlkZSgpLnBhcmVudC5ibHVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19jb250cm9sbGVyLmV4cG9ydExhdGV4KCk7XG4gICAgfTtcbiAgfSk7XG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogU3ltYm9scyBmb3IgQWR2YW5jZWQgTWF0aGVtYXRpY3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuTGF0ZXhDbWRzLm5vdGluID1cbkxhdGV4Q21kcy5jb25nID1cbkxhdGV4Q21kcy5lcXVpdiA9XG5MYXRleENtZHMub3BsdXMgPVxuTGF0ZXhDbWRzLm90aW1lcyA9IFAoQmluYXJ5T3BlcmF0b3IsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihsYXRleCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgJ1xcXFwnK2xhdGV4KycgJywgJyYnK2xhdGV4Kyc7Jyk7XG4gIH07XG59KTtcblxuTGF0ZXhDbWRzWydcXHUyMjYwJ10gPSBMYXRleENtZHMubmUgPSBMYXRleENtZHMubmVxID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXG5lICcsJyZuZTsnKTtcblxuTGF0ZXhDbWRzLmFzdCA9IExhdGV4Q21kcy5zdGFyID0gTGF0ZXhDbWRzLmxvYXN0ID0gTGF0ZXhDbWRzLmxvd2FzdCA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxhc3QgJywnJmxvd2FzdDsnKTtcbiAgLy9jYXNlICd0aGVyZTQgPSAvLyBhIHNwZWNpYWwgZXhjZXB0aW9uIGZvciB0aGlzIG9uZSwgcGVyaGFwcz9cbkxhdGV4Q21kcy50aGVyZWZvciA9IExhdGV4Q21kcy50aGVyZWZvcmUgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcdGhlcmVmb3JlICcsJyZ0aGVyZTQ7Jyk7XG5cbkxhdGV4Q21kcy5jdXogPSAvLyBsMzN0XG5MYXRleENtZHMuYmVjYXVzZSA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxiZWNhdXNlICcsJyYjODc1NzsnKTtcblxuTGF0ZXhDbWRzLnByb3AgPSBMYXRleENtZHMucHJvcHRvID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXHByb3B0byAnLCcmcHJvcDsnKTtcblxuTGF0ZXhDbWRzWydcXHUyMjQ4J10gPSBMYXRleENtZHMuYXN5bXAgPSBMYXRleENtZHMuYXBwcm94ID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGFwcHJveCAnLCcmYXN5bXA7Jyk7XG5cbkxhdGV4Q21kcy5pc2luID0gTGF0ZXhDbWRzWydpbiddID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGluICcsJyZpc2luOycpO1xuXG5MYXRleENtZHMubmkgPSBMYXRleENtZHMuY29udGFpbnMgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbmkgJywnJm5pOycpO1xuXG5MYXRleENtZHMubm90bmkgPSBMYXRleENtZHMubml0b24gPSBMYXRleENtZHMubm90Y29udGFpbnMgPSBMYXRleENtZHMuZG9lc25vdGNvbnRhaW4gPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbm90XFxcXG5pICcsJyYjODcxNjsnKTtcblxuTGF0ZXhDbWRzLnN1YiA9IExhdGV4Q21kcy5zdWJzZXQgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcc3Vic2V0ICcsJyZzdWI7Jyk7XG5cbkxhdGV4Q21kcy5zdXAgPSBMYXRleENtZHMuc3Vwc2V0ID0gTGF0ZXhDbWRzLnN1cGVyc2V0ID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXHN1cHNldCAnLCcmc3VwOycpO1xuXG5MYXRleENtZHMubnN1YiA9IExhdGV4Q21kcy5ub3RzdWIgPVxuTGF0ZXhDbWRzLm5zdWJzZXQgPSBMYXRleENtZHMubm90c3Vic2V0ID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXG5vdFxcXFxzdWJzZXQgJywnJiM4ODM2OycpO1xuXG5MYXRleENtZHMubnN1cCA9IExhdGV4Q21kcy5ub3RzdXAgPVxuTGF0ZXhDbWRzLm5zdXBzZXQgPSBMYXRleENtZHMubm90c3Vwc2V0ID1cbkxhdGV4Q21kcy5uc3VwZXJzZXQgPSBMYXRleENtZHMubm90c3VwZXJzZXQgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbm90XFxcXHN1cHNldCAnLCcmIzg4Mzc7Jyk7XG5cbkxhdGV4Q21kcy5zdWJlID0gTGF0ZXhDbWRzLnN1YmVxID0gTGF0ZXhDbWRzLnN1YnNldGUgPSBMYXRleENtZHMuc3Vic2V0ZXEgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcc3Vic2V0ZXEgJywnJnN1YmU7Jyk7XG5cbkxhdGV4Q21kcy5zdXBlID0gTGF0ZXhDbWRzLnN1cGVxID1cbkxhdGV4Q21kcy5zdXBzZXRlID0gTGF0ZXhDbWRzLnN1cHNldGVxID1cbkxhdGV4Q21kcy5zdXBlcnNldGUgPSBMYXRleENtZHMuc3VwZXJzZXRlcSA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxzdXBzZXRlcSAnLCcmc3VwZTsnKTtcblxuTGF0ZXhDbWRzLm5zdWJlID0gTGF0ZXhDbWRzLm5zdWJlcSA9XG5MYXRleENtZHMubm90c3ViZSA9IExhdGV4Q21kcy5ub3RzdWJlcSA9XG5MYXRleENtZHMubnN1YnNldGUgPSBMYXRleENtZHMubnN1YnNldGVxID1cbkxhdGV4Q21kcy5ub3RzdWJzZXRlID0gTGF0ZXhDbWRzLm5vdHN1YnNldGVxID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXG5vdFxcXFxzdWJzZXRlcSAnLCcmIzg4NDA7Jyk7XG5cbkxhdGV4Q21kcy5uc3VwZSA9IExhdGV4Q21kcy5uc3VwZXEgPVxuTGF0ZXhDbWRzLm5vdHN1cGUgPSBMYXRleENtZHMubm90c3VwZXEgPVxuTGF0ZXhDbWRzLm5zdXBzZXRlID0gTGF0ZXhDbWRzLm5zdXBzZXRlcSA9XG5MYXRleENtZHMubm90c3Vwc2V0ZSA9IExhdGV4Q21kcy5ub3RzdXBzZXRlcSA9XG5MYXRleENtZHMubnN1cGVyc2V0ZSA9IExhdGV4Q21kcy5uc3VwZXJzZXRlcSA9XG5MYXRleENtZHMubm90c3VwZXJzZXRlID0gTGF0ZXhDbWRzLm5vdHN1cGVyc2V0ZXEgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcbm90XFxcXHN1cHNldGVxICcsJyYjODg0MTsnKTtcblxuXG4vL3RoZSBjYW5vbmljYWwgc2V0cyBvZiBudW1iZXJzXG5MYXRleENtZHMuTiA9IExhdGV4Q21kcy5uYXR1cmFscyA9IExhdGV4Q21kcy5OYXR1cmFscyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG1hdGhiYntOfScsJyYjODQ2OTsnKTtcblxuTGF0ZXhDbWRzLlAgPVxuTGF0ZXhDbWRzLnByaW1lcyA9IExhdGV4Q21kcy5QcmltZXMgPVxuTGF0ZXhDbWRzLnByb2plY3RpdmUgPSBMYXRleENtZHMuUHJvamVjdGl2ZSA9XG5MYXRleENtZHMucHJvYmFiaWxpdHkgPSBMYXRleENtZHMuUHJvYmFiaWxpdHkgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxtYXRoYmJ7UH0nLCcmIzg0NzM7Jyk7XG5cbkxhdGV4Q21kcy5aID0gTGF0ZXhDbWRzLmludGVnZXJzID0gTGF0ZXhDbWRzLkludGVnZXJzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWF0aGJie1p9JywnJiM4NDg0OycpO1xuXG5MYXRleENtZHMuUSA9IExhdGV4Q21kcy5yYXRpb25hbHMgPSBMYXRleENtZHMuUmF0aW9uYWxzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWF0aGJie1F9JywnJiM4NDc0OycpO1xuXG5MYXRleENtZHMuUiA9IExhdGV4Q21kcy5yZWFscyA9IExhdGV4Q21kcy5SZWFscyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG1hdGhiYntSfScsJyYjODQ3NzsnKTtcblxuTGF0ZXhDbWRzLkMgPVxuTGF0ZXhDbWRzLmNvbXBsZXggPSBMYXRleENtZHMuQ29tcGxleCA9XG5MYXRleENtZHMuY29tcGxleGVzID0gTGF0ZXhDbWRzLkNvbXBsZXhlcyA9XG5MYXRleENtZHMuY29tcGxleHBsYW5lID0gTGF0ZXhDbWRzLkNvbXBsZXhwbGFuZSA9IExhdGV4Q21kcy5Db21wbGV4UGxhbmUgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxtYXRoYmJ7Q30nLCcmIzg0NTA7Jyk7XG5cbkxhdGV4Q21kcy5IID0gTGF0ZXhDbWRzLkhhbWlsdG9uaWFuID0gTGF0ZXhDbWRzLnF1YXRlcm5pb25zID0gTGF0ZXhDbWRzLlF1YXRlcm5pb25zID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWF0aGJie0h9JywnJiM4NDYxOycpO1xuXG4vL3NwYWNpbmdcbkxhdGV4Q21kcy5xdWFkID0gTGF0ZXhDbWRzLmVtc3AgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxxdWFkICcsJyAgICAnKTtcbkxhdGV4Q21kcy5xcXVhZCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHFxdWFkICcsJyAgICAgICAgJyk7XG4vKiBzcGFjaW5nIHNwZWNpYWwgY2hhcmFjdGVycywgZ29ubmEgaGF2ZSB0byBpbXBsZW1lbnQgdGhpcyBpbiBMYXRleENvbW1hbmRJbnB1dDo6b25UZXh0IHNvbWVob3dcbmNhc2UgJywnOlxuICByZXR1cm4gVmFuaWxsYVN5bWJvbCgnXFxcXCwgJywnICcpO1xuY2FzZSAnOic6XG4gIHJldHVybiBWYW5pbGxhU3ltYm9sKCdcXFxcOiAnLCcgICcpO1xuY2FzZSAnOyc6XG4gIHJldHVybiBWYW5pbGxhU3ltYm9sKCdcXFxcOyAnLCcgICAnKTtcbmNhc2UgJyEnOlxuICByZXR1cm4gU3ltYm9sKCdcXFxcISAnLCc8c3BhbiBzdHlsZT1cIm1hcmdpbi1yaWdodDotLjJlbVwiPjwvc3Bhbj4nKTtcbiovXG5cbi8vYmluYXJ5IG9wZXJhdG9yc1xuTGF0ZXhDbWRzLmRpYW1vbmQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZGlhbW9uZCAnLCAnJiM5NjcxOycpO1xuTGF0ZXhDbWRzLmJpZ3RyaWFuZ2xldXAgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYmlndHJpYW5nbGV1cCAnLCAnJiM5NjUxOycpO1xuTGF0ZXhDbWRzLm9taW51cyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxvbWludXMgJywgJyYjODg1NDsnKTtcbkxhdGV4Q21kcy51cGx1cyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx1cGx1cyAnLCAnJiM4ODQ2OycpO1xuTGF0ZXhDbWRzLmJpZ3RyaWFuZ2xlZG93biA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWd0cmlhbmdsZWRvd24gJywgJyYjOTY2MTsnKTtcbkxhdGV4Q21kcy5zcWNhcCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcWNhcCAnLCAnJiM4ODUxOycpO1xuTGF0ZXhDbWRzLnRyaWFuZ2xlbGVmdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx0cmlhbmdsZWxlZnQgJywgJyYjODg4MjsnKTtcbkxhdGV4Q21kcy5zcWN1cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzcWN1cCAnLCAnJiM4ODUyOycpO1xuTGF0ZXhDbWRzLnRyaWFuZ2xlcmlnaHQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcdHJpYW5nbGVyaWdodCAnLCAnJiM4ODgzOycpO1xuLy9jaXJjbGVkb3QgaXMgbm90IGEgbm90IHJlYWwgTGFUZXggY29tbWFuZCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdGhxdWlsbC9tYXRocXVpbGwvcHVsbC81NTIgZm9yIG1vcmUgZGV0YWlsc1xuTGF0ZXhDbWRzLm9kb3QgPSBMYXRleENtZHMuY2lyY2xlZG90ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG9kb3QgJywgJyYjODg1NzsnKTtcbkxhdGV4Q21kcy5iaWdjaXJjID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ2NpcmMgJywgJyYjOTcxMTsnKTtcbkxhdGV4Q21kcy5kYWdnZXIgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZGFnZ2VyICcsICcmIzAxMzQ7Jyk7XG5MYXRleENtZHMuZGRhZ2dlciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxkZGFnZ2VyICcsICcmIzEzNTsnKTtcbkxhdGV4Q21kcy53ciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx3ciAnLCAnJiM4NzY4OycpO1xuTGF0ZXhDbWRzLmFtYWxnID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGFtYWxnICcsICcmIzg3MjA7Jyk7XG5cbi8vcmVsYXRpb25zaGlwIHN5bWJvbHNcbkxhdGV4Q21kcy5tb2RlbHMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbW9kZWxzICcsICcmIzg4NzI7Jyk7XG5MYXRleENtZHMucHJlYyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxwcmVjICcsICcmIzg4MjY7Jyk7XG5MYXRleENtZHMuc3VjYyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzdWNjICcsICcmIzg4Mjc7Jyk7XG5MYXRleENtZHMucHJlY2VxID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHByZWNlcSAnLCAnJiM4ODI4OycpO1xuTGF0ZXhDbWRzLnN1Y2NlcSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzdWNjZXEgJywgJyYjODgyOTsnKTtcbkxhdGV4Q21kcy5zaW1lcSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzaW1lcSAnLCAnJiM4NzcxOycpO1xuTGF0ZXhDbWRzLm1pZCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxtaWQgJywgJyYjODczOTsnKTtcbkxhdGV4Q21kcy5sbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsbCAnLCAnJiM4ODEwOycpO1xuTGF0ZXhDbWRzLmdnID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGdnICcsICcmIzg4MTE7Jyk7XG5MYXRleENtZHMucGFyYWxsZWwgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccGFyYWxsZWwgJywgJyYjODc0MTsnKTtcbkxhdGV4Q21kcy5ucGFyYWxsZWwgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbnBhcmFsbGVsICcsICcmIzg3NDI7Jyk7XG5MYXRleENtZHMuYm93dGllID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJvd3RpZSAnLCAnJiM4OTA0OycpO1xuTGF0ZXhDbWRzLnNxc3Vic2V0ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNxc3Vic2V0ICcsICcmIzg4NDc7Jyk7XG5MYXRleENtZHMuc3FzdXBzZXQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3FzdXBzZXQgJywgJyYjODg0ODsnKTtcbkxhdGV4Q21kcy5zbWlsZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzbWlsZSAnLCAnJiM4OTk1OycpO1xuTGF0ZXhDbWRzLnNxc3Vic2V0ZXEgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3FzdWJzZXRlcSAnLCAnJiM4ODQ5OycpO1xuTGF0ZXhDbWRzLnNxc3Vwc2V0ZXEgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3FzdXBzZXRlcSAnLCAnJiM4ODUwOycpO1xuTGF0ZXhDbWRzLmRvdGVxID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGRvdGVxICcsICcmIzg3ODQ7Jyk7XG5MYXRleENtZHMuZnJvd24gPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZnJvd24gJywgJyYjODk5NDsnKTtcbkxhdGV4Q21kcy52ZGFzaCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx2ZGFzaCAnLCAnJiM4ODcwOycpO1xuTGF0ZXhDbWRzLmRhc2h2ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGRhc2h2ICcsICcmIzg4Njc7Jyk7XG5MYXRleENtZHMubmxlc3MgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbmxlc3MgJywgJyYjODgxNDsnKTtcbkxhdGV4Q21kcy5uZ3RyID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG5ndHIgJywgJyYjODgxNTsnKTtcblxuLy9hcnJvd3NcbkxhdGV4Q21kcy5sb25nbGVmdGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxvbmdsZWZ0YXJyb3cgJywgJyYjODU5MjsnKTtcbkxhdGV4Q21kcy5sb25ncmlnaHRhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsb25ncmlnaHRhcnJvdyAnLCAnJiM4NTk0OycpO1xuTGF0ZXhDbWRzLkxvbmdsZWZ0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcTG9uZ2xlZnRhcnJvdyAnLCAnJiM4NjU2OycpO1xuTGF0ZXhDbWRzLkxvbmdyaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXExvbmdyaWdodGFycm93ICcsICcmIzg2NTg7Jyk7XG5MYXRleENtZHMubG9uZ2xlZnRyaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxvbmdsZWZ0cmlnaHRhcnJvdyAnLCAnJiM4NTk2OycpO1xuTGF0ZXhDbWRzLnVwZG93bmFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHVwZG93bmFycm93ICcsICcmIzg1OTc7Jyk7XG5MYXRleENtZHMuTG9uZ2xlZnRyaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXExvbmdsZWZ0cmlnaHRhcnJvdyAnLCAnJiM4NjYwOycpO1xuTGF0ZXhDbWRzLlVwZG93bmFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXFVwZG93bmFycm93ICcsICcmIzg2NjE7Jyk7XG5MYXRleENtZHMubWFwc3RvID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG1hcHN0byAnLCAnJiM4NjE0OycpO1xuTGF0ZXhDbWRzLm5lYXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbmVhcnJvdyAnLCAnJiM4NTk5OycpO1xuTGF0ZXhDbWRzLmhvb2tsZWZ0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcaG9va2xlZnRhcnJvdyAnLCAnJiM4NjE3OycpO1xuTGF0ZXhDbWRzLmhvb2tyaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGhvb2tyaWdodGFycm93ICcsICcmIzg2MTg7Jyk7XG5MYXRleENtZHMuc2VhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzZWFycm93ICcsICcmIzg2MDA7Jyk7XG5MYXRleENtZHMubGVmdGhhcnBvb251cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsZWZ0aGFycG9vbnVwICcsICcmIzg2MzY7Jyk7XG5MYXRleENtZHMucmlnaHRoYXJwb29udXAgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccmlnaHRoYXJwb29udXAgJywgJyYjODY0MDsnKTtcbkxhdGV4Q21kcy5zd2Fycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHN3YXJyb3cgJywgJyYjODYwMTsnKTtcbkxhdGV4Q21kcy5sZWZ0aGFycG9vbmRvd24gPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbGVmdGhhcnBvb25kb3duICcsICcmIzg2Mzc7Jyk7XG5MYXRleENtZHMucmlnaHRoYXJwb29uZG93biA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxyaWdodGhhcnBvb25kb3duICcsICcmIzg2NDE7Jyk7XG5MYXRleENtZHMubndhcnJvdyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxud2Fycm93ICcsICcmIzg1OTg7Jyk7XG5cbi8vTWlzY1xuTGF0ZXhDbWRzLmxkb3RzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGxkb3RzICcsICcmIzgyMzA7Jyk7XG5MYXRleENtZHMuY2RvdHMgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcY2RvdHMgJywgJyYjODk0MzsnKTtcbkxhdGV4Q21kcy52ZG90cyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFx2ZG90cyAnLCAnJiM4OTQyOycpO1xuTGF0ZXhDbWRzLmRkb3RzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGRkb3RzICcsICcmIzg5NDU7Jyk7XG5MYXRleENtZHMuc3VyZCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxzdXJkICcsICcmIzg3MzA7Jyk7XG5MYXRleENtZHMudHJpYW5nbGUgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcdHJpYW5nbGUgJywgJyYjOTY1MTsnKTtcbkxhdGV4Q21kcy5lbGwgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZWxsICcsICcmIzg0Njc7Jyk7XG5MYXRleENtZHMudG9wID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHRvcCAnLCAnJiM4ODY4OycpO1xuTGF0ZXhDbWRzLmZsYXQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcZmxhdCAnLCAnJiM5ODM3OycpO1xuTGF0ZXhDbWRzLm5hdHVyYWwgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbmF0dXJhbCAnLCAnJiM5ODM4OycpO1xuTGF0ZXhDbWRzLnNoYXJwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHNoYXJwICcsICcmIzk4Mzk7Jyk7XG5MYXRleENtZHMud3AgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcd3AgJywgJyYjODQ3MjsnKTtcbkxhdGV4Q21kcy5ib3QgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYm90ICcsICcmIzg4Njk7Jyk7XG5MYXRleENtZHMuY2x1YnN1aXQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcY2x1YnN1aXQgJywgJyYjOTgyNzsnKTtcbkxhdGV4Q21kcy5kaWFtb25kc3VpdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxkaWFtb25kc3VpdCAnLCAnJiM5ODI2OycpO1xuTGF0ZXhDbWRzLmhlYXJ0c3VpdCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxoZWFydHN1aXQgJywgJyYjOTgyNTsnKTtcbkxhdGV4Q21kcy5zcGFkZXN1aXQgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3BhZGVzdWl0ICcsICcmIzk4MjQ7Jyk7XG4vL25vdCByZWFsIExhVGV4IGNvbW1hbmQgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRocXVpbGwvbWF0aHF1aWxsL3B1bGwvNTUyIGZvciBtb3JlIGRldGFpbHNcbkxhdGV4Q21kcy5wYXJhbGxlbG9ncmFtID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHBhcmFsbGVsb2dyYW0gJywgJyYjOTY0OTsnKTtcbkxhdGV4Q21kcy5zcXVhcmUgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcc3F1YXJlICcsICcmIzExMDM2OycpO1xuXG4vL3ZhcmlhYmxlLXNpemVkXG5MYXRleENtZHMub2ludCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxvaW50ICcsICcmIzg3NTA7Jyk7XG5MYXRleENtZHMuYmlnY2FwID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ2NhcCAnLCAnJiM4NzQ1OycpO1xuTGF0ZXhDbWRzLmJpZ2N1cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWdjdXAgJywgJyYjODc0NjsnKTtcbkxhdGV4Q21kcy5iaWdzcWN1cCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWdzcWN1cCAnLCAnJiM4ODUyOycpO1xuTGF0ZXhDbWRzLmJpZ3ZlZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWd2ZWUgJywgJyYjODc0NDsnKTtcbkxhdGV4Q21kcy5iaWd3ZWRnZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWd3ZWRnZSAnLCAnJiM4NzQzOycpO1xuTGF0ZXhDbWRzLmJpZ29kb3QgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcYmlnb2RvdCAnLCAnJiM4ODU3OycpO1xuTGF0ZXhDbWRzLmJpZ290aW1lcyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWdvdGltZXMgJywgJyYjODg1NTsnKTtcbkxhdGV4Q21kcy5iaWdvcGx1cyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxiaWdvcGx1cyAnLCAnJiM4ODUzOycpO1xuTGF0ZXhDbWRzLmJpZ3VwbHVzID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXGJpZ3VwbHVzICcsICcmIzg4NDY7Jyk7XG5cbi8vZGVsaW1pdGVyc1xuTGF0ZXhDbWRzLmxmbG9vciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsZmxvb3IgJywgJyYjODk3MDsnKTtcbkxhdGV4Q21kcy5yZmxvb3IgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxccmZsb29yICcsICcmIzg5NzE7Jyk7XG5MYXRleENtZHMubGNlaWwgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICdcXFxcbGNlaWwgJywgJyYjODk2ODsnKTtcbkxhdGV4Q21kcy5yY2VpbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxyY2VpbCAnLCAnJiM4OTY5OycpO1xuTGF0ZXhDbWRzLm9wZW5jdXJseWJyYWNlID0gTGF0ZXhDbWRzLmxicmFjZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFxsYnJhY2UgJywgJ3snKTtcbkxhdGV4Q21kcy5jbG9zZWN1cmx5YnJhY2UgPSBMYXRleENtZHMucmJyYWNlID0gYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXHJicmFjZSAnLCAnfScpO1xuTGF0ZXhDbWRzLmxicmFjayA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1snKTtcbkxhdGV4Q21kcy5yYnJhY2sgPSBiaW5kKFZhbmlsbGFTeW1ib2wsICddJyk7XG5cbi8vdmFyaW91cyBzeW1ib2xzXG5MYXRleENtZHMuc2xhc2ggPSBiaW5kKFZhbmlsbGFTeW1ib2wsICcvJyk7XG5MYXRleENtZHMudmVydCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnfCcpO1xuTGF0ZXhDbWRzLnBlcnAgPSBMYXRleENtZHMucGVycGVuZGljdWxhciA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHBlcnAgJywnJnBlcnA7Jyk7XG5MYXRleENtZHMubmFibGEgPSBMYXRleENtZHMuZGVsID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbmFibGEgJywnJm5hYmxhOycpO1xuTGF0ZXhDbWRzLmhiYXIgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxoYmFyICcsJyYjODQ2MzsnKTtcblxuTGF0ZXhDbWRzLkFBID0gTGF0ZXhDbWRzLkFuZ3N0cm9tID0gTGF0ZXhDbWRzLmFuZ3N0cm9tID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcdGV4dFxcXFxBQSAnLCcmIzg0OTE7Jyk7XG5cbkxhdGV4Q21kcy5yaW5nID0gTGF0ZXhDbWRzLmNpcmMgPSBMYXRleENtZHMuY2lyY2xlID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcY2lyYyAnLCcmIzg3Mjg7Jyk7XG5cbkxhdGV4Q21kcy5idWxsID0gTGF0ZXhDbWRzLmJ1bGxldCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGJ1bGxldCAnLCcmYnVsbDsnKTtcblxuTGF0ZXhDbWRzLnNldG1pbnVzID0gTGF0ZXhDbWRzLnNtYWxsc2V0bWludXMgPVxuICBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxzZXRtaW51cyAnLCcmIzg3MjY7Jyk7XG5cbkxhdGV4Q21kcy5ub3QgPSAvL2JpbmQoU3ltYm9sLCdcXFxcbm90ICcsJzxzcGFuIGNsYXNzPVwibm90XCI+Lzwvc3Bhbj4nKTtcbkxhdGV4Q21kc1snXFx1MDBhYyddID0gTGF0ZXhDbWRzLm5lZyA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXG5lZyAnLCcmbm90OycpO1xuXG5MYXRleENtZHNbJ1xcdTIwMjYnXSA9IExhdGV4Q21kcy5kb3RzID0gTGF0ZXhDbWRzLmVsbGlwID0gTGF0ZXhDbWRzLmhlbGxpcCA9XG5MYXRleENtZHMuZWxsaXBzaXMgPSBMYXRleENtZHMuaGVsbGlwc2lzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZG90cyAnLCcmaGVsbGlwOycpO1xuXG5MYXRleENtZHMuY29udmVyZ2VzID1cbkxhdGV4Q21kcy5kYXJyID0gTGF0ZXhDbWRzLmRuYXJyID0gTGF0ZXhDbWRzLmRuYXJyb3cgPSBMYXRleENtZHMuZG93bmFycm93ID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZG93bmFycm93ICcsJyZkYXJyOycpO1xuXG5MYXRleENtZHMuZEFyciA9IExhdGV4Q21kcy5kbkFyciA9IExhdGV4Q21kcy5kbkFycm93ID0gTGF0ZXhDbWRzLkRvd25hcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXERvd25hcnJvdyAnLCcmZEFycjsnKTtcblxuTGF0ZXhDbWRzLmRpdmVyZ2VzID0gTGF0ZXhDbWRzLnVhcnIgPSBMYXRleENtZHMudXBhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHVwYXJyb3cgJywnJnVhcnI7Jyk7XG5cbkxhdGV4Q21kcy51QXJyID0gTGF0ZXhDbWRzLlVwYXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxVcGFycm93ICcsJyZ1QXJyOycpO1xuXG5MYXRleENtZHMudG8gPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcdG8gJywnJnJhcnI7Jyk7XG5cbkxhdGV4Q21kcy5yYXJyID0gTGF0ZXhDbWRzLnJpZ2h0YXJyb3cgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFxyaWdodGFycm93ICcsJyZyYXJyOycpO1xuXG5MYXRleENtZHMuaW1wbGllcyA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsJ1xcXFxSaWdodGFycm93ICcsJyZyQXJyOycpO1xuXG5MYXRleENtZHMuckFyciA9IExhdGV4Q21kcy5SaWdodGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcUmlnaHRhcnJvdyAnLCcmckFycjsnKTtcblxuTGF0ZXhDbWRzLmdldHMgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcZ2V0cyAnLCcmbGFycjsnKTtcblxuTGF0ZXhDbWRzLmxhcnIgPSBMYXRleENtZHMubGVmdGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbGVmdGFycm93ICcsJyZsYXJyOycpO1xuXG5MYXRleENtZHMuaW1wbGllZGJ5ID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXExlZnRhcnJvdyAnLCcmbEFycjsnKTtcblxuTGF0ZXhDbWRzLmxBcnIgPSBMYXRleENtZHMuTGVmdGFycm93ID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcTGVmdGFycm93ICcsJyZsQXJyOycpO1xuXG5MYXRleENtZHMuaGFyciA9IExhdGV4Q21kcy5scmFyciA9IExhdGV4Q21kcy5sZWZ0cmlnaHRhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGxlZnRyaWdodGFycm93ICcsJyZoYXJyOycpO1xuXG5MYXRleENtZHMuaWZmID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXExlZnRyaWdodGFycm93ICcsJyZoQXJyOycpO1xuXG5MYXRleENtZHMuaEFyciA9IExhdGV4Q21kcy5sckFyciA9IExhdGV4Q21kcy5MZWZ0cmlnaHRhcnJvdyA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXExlZnRyaWdodGFycm93ICcsJyZoQXJyOycpO1xuXG5MYXRleENtZHMuUmUgPSBMYXRleENtZHMuUmVhbCA9IExhdGV4Q21kcy5yZWFsID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcUmUgJywnJnJlYWw7Jyk7XG5cbkxhdGV4Q21kcy5JbSA9IExhdGV4Q21kcy5pbWFnID1cbkxhdGV4Q21kcy5pbWFnZSA9IExhdGV4Q21kcy5pbWFnaW4gPSBMYXRleENtZHMuaW1hZ2luYXJ5ID0gTGF0ZXhDbWRzLkltYWdpbmFyeSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXEltICcsJyZpbWFnZTsnKTtcblxuTGF0ZXhDbWRzLnBhcnQgPSBMYXRleENtZHMucGFydGlhbCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXHBhcnRpYWwgJywnJnBhcnQ7Jyk7XG5cbkxhdGV4Q21kcy5pbmZ0eSA9IExhdGV4Q21kcy5pbmZpbiA9IExhdGV4Q21kcy5pbmZpbml0eSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGluZnR5ICcsJyZpbmZpbjsnKTtcblxuTGF0ZXhDbWRzLmFsZWYgPSBMYXRleENtZHMuYWxlZnN5bSA9IExhdGV4Q21kcy5hbGVwaCA9IExhdGV4Q21kcy5hbGVwaHN5bSA9XG4gIGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGFsZXBoICcsJyZhbGVmc3ltOycpO1xuXG5MYXRleENtZHMueGlzdCA9IC8vTE9MXG5MYXRleENtZHMueGlzdHMgPSBMYXRleENtZHMuZXhpc3QgPSBMYXRleENtZHMuZXhpc3RzID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcZXhpc3RzICcsJyZleGlzdDsnKTtcbiAgXG5MYXRleENtZHMubmV4aXN0cyA9IExhdGV4Q21kcy5uZXhpc3QgPVxuICAgICAgYmluZChWYW5pbGxhU3ltYm9sLCAnXFxcXG5leGlzdHMgJywgJyYjODcwODsnKTtcblxuTGF0ZXhDbWRzLmFuZCA9IExhdGV4Q21kcy5sYW5kID0gTGF0ZXhDbWRzLndlZGdlID1cbiAgYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcd2VkZ2UgJywnJmFuZDsnKTtcblxuTGF0ZXhDbWRzLm9yID0gTGF0ZXhDbWRzLmxvciA9IExhdGV4Q21kcy52ZWUgPSBiaW5kKFZhbmlsbGFTeW1ib2wsJ1xcXFx2ZWUgJywnJm9yOycpO1xuXG5MYXRleENtZHMubyA9IExhdGV4Q21kcy5PID1cbkxhdGV4Q21kcy5lbXB0eSA9IExhdGV4Q21kcy5lbXB0eXNldCA9XG5MYXRleENtZHMub3NsYXNoID0gTGF0ZXhDbWRzLk9zbGFzaCA9XG5MYXRleENtZHMubm90aGluZyA9IExhdGV4Q21kcy52YXJub3RoaW5nID1cbiAgYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXHZhcm5vdGhpbmcgJywnJmVtcHR5OycpO1xuXG5MYXRleENtZHMuY3VwID0gTGF0ZXhDbWRzLnVuaW9uID0gYmluZChCaW5hcnlPcGVyYXRvciwnXFxcXGN1cCAnLCcmY3VwOycpO1xuXG5MYXRleENtZHMuY2FwID0gTGF0ZXhDbWRzLmludGVyc2VjdCA9IExhdGV4Q21kcy5pbnRlcnNlY3Rpb24gPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcY2FwICcsJyZjYXA7Jyk7XG5cbi8vIEZJWE1FOiB0aGUgY29ycmVjdCBMYVRlWCB3b3VsZCBiZSBeXFxjaXJjIGJ1dCB3ZSBjYW4ndCBwYXJzZSB0aGF0XG5MYXRleENtZHMuZGVnID0gTGF0ZXhDbWRzLmRlZ3JlZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGRlZ3JlZSAnLCcmZGVnOycpO1xuXG5MYXRleENtZHMuYW5nID0gTGF0ZXhDbWRzLmFuZ2xlID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcYW5nbGUgJywnJmFuZzsnKTtcbkxhdGV4Q21kcy5tZWFzdXJlZGFuZ2xlID0gYmluZChWYW5pbGxhU3ltYm9sLCdcXFxcbWVhc3VyZWRhbmdsZSAnLCcmIzg3Mzc7Jyk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTeW1ib2xzIGZvciBCYXNpYyBNYXRoZW1hdGljc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgRGlnaXQgPSBQKFZhbmlsbGFTeW1ib2wsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3Iub3B0aW9ucy5hdXRvU3Vic2NyaXB0TnVtZXJhbHNcbiAgICAgICAgJiYgY3Vyc29yLnBhcmVudCAhPT0gY3Vyc29yLnBhcmVudC5wYXJlbnQuc3ViXG4gICAgICAgICYmICgoY3Vyc29yW0xdIGluc3RhbmNlb2YgVmFyaWFibGUgJiYgY3Vyc29yW0xdLmlzSXRhbGljICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHx8IChjdXJzb3JbTF0gaW5zdGFuY2VvZiBTdXBTdWJcbiAgICAgICAgICAgICAgICAmJiBjdXJzb3JbTF1bTF0gaW5zdGFuY2VvZiBWYXJpYWJsZVxuICAgICAgICAgICAgICAgICYmIGN1cnNvcltMXVtMXS5pc0l0YWxpYyAhPT0gZmFsc2UpKSkge1xuICAgICAgTGF0ZXhDbWRzLl8oKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuICAgICAgY3Vyc29yLmluc1JpZ2h0T2YoY3Vyc29yLnBhcmVudC5wYXJlbnQpO1xuICAgIH1cbiAgICBlbHNlIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuICB9O1xufSk7XG5cbnZhciBWYXJpYWJsZSA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oY2gsIGh0bWwpIHtcbiAgICBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIGNoLCAnPHZhcj4nKyhodG1sIHx8IGNoKSsnPC92YXI+Jyk7XG4gIH07XG4gIF8udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy5jdHJsU2VxO1xuICAgIGlmICh0aGlzW0xdICYmICEodGhpc1tMXSBpbnN0YW5jZW9mIFZhcmlhYmxlKVxuICAgICAgICAmJiAhKHRoaXNbTF0gaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvcilcbiAgICAgICAgJiYgdGhpc1tMXS5jdHJsU2VxICE9PSBcIlxcXFwgXCIpXG4gICAgICB0ZXh0ID0gJyonICsgdGV4dDtcbiAgICBpZiAodGhpc1tSXSAmJiAhKHRoaXNbUl0gaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvcilcbiAgICAgICAgJiYgISh0aGlzW1JdIGluc3RhbmNlb2YgU3VwU3ViKSlcbiAgICAgIHRleHQgKz0gJyonO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufSk7XG5cbk9wdGlvbnMucC5hdXRvQ29tbWFuZHMgPSB7IF9tYXhMZW5ndGg6IDAgfTtcbm9wdGlvblByb2Nlc3NvcnMuYXV0b0NvbW1hbmRzID0gZnVuY3Rpb24oY21kcykge1xuICBpZiAoIS9eW2Etel0rKD86IFthLXpdKykqJC9pLnRlc3QoY21kcykpIHtcbiAgICB0aHJvdyAnXCInK2NtZHMrJ1wiIG5vdCBhIHNwYWNlLWRlbGltaXRlZCBsaXN0IG9mIG9ubHkgbGV0dGVycyc7XG4gIH1cbiAgdmFyIGxpc3QgPSBjbWRzLnNwbGl0KCcgJyksIGRpY3QgPSB7fSwgbWF4TGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNtZCA9IGxpc3RbaV07XG4gICAgaWYgKGNtZC5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyAnYXV0b2NvbW1hbmQgXCInK2NtZCsnXCIgbm90IG1pbmltdW0gbGVuZ3RoIG9mIDInO1xuICAgIH1cbiAgICBpZiAoTGF0ZXhDbWRzW2NtZF0gPT09IE9wZXJhdG9yTmFtZSkge1xuICAgICAgdGhyb3cgJ1wiJyArIGNtZCArICdcIiBpcyBhIGJ1aWx0LWluIG9wZXJhdG9yIG5hbWUnO1xuICAgIH1cbiAgICBkaWN0W2NtZF0gPSAxO1xuICAgIG1heExlbmd0aCA9IG1heChtYXhMZW5ndGgsIGNtZC5sZW5ndGgpO1xuICB9XG4gIGRpY3QuX21heExlbmd0aCA9IG1heExlbmd0aDtcbiAgcmV0dXJuIGRpY3Q7XG59O1xuXG52YXIgTGV0dGVyID0gUChWYXJpYWJsZSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGNoKSB7IHJldHVybiBzdXBlcl8uaW5pdC5jYWxsKHRoaXMsIHRoaXMubGV0dGVyID0gY2gpOyB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYXV0b0NtZHMgPSBjdXJzb3Iub3B0aW9ucy5hdXRvQ29tbWFuZHMsIG1heExlbmd0aCA9IGF1dG9DbWRzLl9tYXhMZW5ndGg7XG4gICAgaWYgKG1heExlbmd0aCA+IDApIHtcbiAgICAgIC8vIHdhbnQgbG9uZ2VzdCBwb3NzaWJsZSBhdXRvY29tbWFuZCwgc28gam9pbiB0b2dldGhlciBsb25nZXN0XG4gICAgICAvLyBzZXF1ZW5jZSBvZiBsZXR0ZXJzXG4gICAgICB2YXIgc3RyID0gJycsIGwgPSB0aGlzLCBpID0gMDtcbiAgICAgIC8vIEZJWE1FOiBsLmN0cmxTZXEgPT09IGwubGV0dGVyIGNoZWNrcyBpZiBmaXJzdCBvciBsYXN0IGluIGFuIG9wZXJhdG9yIG5hbWVcbiAgICAgIHdoaWxlIChsIGluc3RhbmNlb2YgTGV0dGVyICYmIGwuY3RybFNlcSA9PT0gbC5sZXR0ZXIgJiYgaSA8IG1heExlbmd0aCkge1xuICAgICAgICBzdHIgPSBsLmxldHRlciArIHN0ciwgbCA9IGxbTF0sIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGZvciBhbiBhdXRvY29tbWFuZCwgZ29pbmcgdGhydSBzdWJzdHJpbmdzIGxvbmdlc3QgdG8gc2hvcnRlc3RcbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhdXRvQ21kcy5oYXNPd25Qcm9wZXJ0eShzdHIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSB0aGlzOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxLCBsID0gbFtMXSk7XG4gICAgICAgICAgRnJhZ21lbnQobCwgdGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgY3Vyc29yW0xdID0gbFtMXTtcbiAgICAgICAgICByZXR1cm4gTGF0ZXhDbWRzW3N0cl0oc3RyKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfLml0YWxpY2l6ZSA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICB0aGlzLmlzSXRhbGljID0gYm9vbDtcbiAgICB0aGlzLmpRLnRvZ2dsZUNsYXNzKCdtcS1vcGVyYXRvci1uYW1lJywgIWJvb2wpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfLmZpbmFsaXplVHJlZSA9IF8uc2libGluZ0RlbGV0ZWQgPSBfLnNpYmxpbmdDcmVhdGVkID0gZnVuY3Rpb24ob3B0cywgZGlyKSB7XG4gICAgLy8gZG9uJ3QgYXV0by11bi1pdGFsaWNpemUgaWYgdGhlIHNpYmxpbmcgdG8gbXkgcmlnaHQgY2hhbmdlZCAoZGlyID09PSBSIG9yXG4gICAgLy8gdW5kZWZpbmVkKSBhbmQgaXQncyBub3cgYSBMZXR0ZXIsIGl0IHdpbGwgdW4taXRhbGljaXplIGV2ZXJ5b25lXG4gICAgaWYgKGRpciAhPT0gTCAmJiB0aGlzW1JdIGluc3RhbmNlb2YgTGV0dGVyKSByZXR1cm47XG4gICAgdGhpcy5hdXRvVW5JdGFsaWNpemUob3B0cyk7XG4gIH07XG4gIF8uYXV0b1VuSXRhbGljaXplID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHZhciBhdXRvT3BzID0gb3B0cy5hdXRvT3BlcmF0b3JOYW1lcztcbiAgICBpZiAoYXV0b09wcy5fbWF4TGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLy8gd2FudCBsb25nZXN0IHBvc3NpYmxlIG9wZXJhdG9yIG5hbWVzLCBzbyBqb2luIHRvZ2V0aGVyIGVudGlyZSBjb250aWd1b3VzXG4gICAgLy8gc2VxdWVuY2Ugb2YgbGV0dGVyc1xuICAgIHZhciBzdHIgPSB0aGlzLmxldHRlcjtcbiAgICBmb3IgKHZhciBsID0gdGhpc1tMXTsgbCBpbnN0YW5jZW9mIExldHRlcjsgbCA9IGxbTF0pIHN0ciA9IGwubGV0dGVyICsgc3RyO1xuICAgIGZvciAodmFyIHIgPSB0aGlzW1JdOyByIGluc3RhbmNlb2YgTGV0dGVyOyByID0gcltSXSkgc3RyICs9IHIubGV0dGVyO1xuXG4gICAgLy8gcmVtb3ZlQ2xhc3MgYW5kIGRlbGV0ZSBmbGFncyBmcm9tIGFsbCBsZXR0ZXJzIGJlZm9yZSBmaWd1cmluZyBvdXRcbiAgICAvLyB3aGljaCwgaWYgYW55LCBhcmUgcGFydCBvZiBhbiBvcGVyYXRvciBuYW1lXG4gICAgRnJhZ21lbnQobFtSXSB8fCB0aGlzLnBhcmVudC5lbmRzW0xdLCByW0xdIHx8IHRoaXMucGFyZW50LmVuZHNbUl0pLmVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIGVsLml0YWxpY2l6ZSh0cnVlKS5qUS5yZW1vdmVDbGFzcygnbXEtZmlyc3QgbXEtbGFzdCBtcS1mb2xsb3dlZC1ieS1zdXBzdWInKTtcbiAgICAgIGVsLmN0cmxTZXEgPSBlbC5sZXR0ZXI7XG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmb3Igb3BlcmF0b3IgbmFtZXM6IGF0IGVhY2ggcG9zaXRpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0LCBjaGVja1xuICAgIC8vIHN1YnN0cmluZ3MgZnJvbSBsb25nZXN0IHRvIHNob3J0ZXN0XG4gICAgb3V0ZXI6IGZvciAodmFyIGkgPSAwLCBmaXJzdCA9IGxbUl0gfHwgdGhpcy5wYXJlbnQuZW5kc1tMXTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSwgZmlyc3QgPSBmaXJzdFtSXSkge1xuICAgICAgZm9yICh2YXIgbGVuID0gbWluKGF1dG9PcHMuX21heExlbmd0aCwgc3RyLmxlbmd0aCAtIGkpOyBsZW4gPiAwOyBsZW4gLT0gMSkge1xuICAgICAgICB2YXIgd29yZCA9IHN0ci5zbGljZShpLCBpICsgbGVuKTtcbiAgICAgICAgaWYgKGF1dG9PcHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGV0dGVyID0gZmlyc3Q7IGogPCBsZW47IGogKz0gMSwgbGV0dGVyID0gbGV0dGVyW1JdKSB7XG4gICAgICAgICAgICBsZXR0ZXIuaXRhbGljaXplKGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gbGV0dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0J1aWx0SW4gPSBCdWlsdEluT3BOYW1lcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKTtcbiAgICAgICAgICBmaXJzdC5jdHJsU2VxID0gKGlzQnVpbHRJbiA/ICdcXFxcJyA6ICdcXFxcb3BlcmF0b3JuYW1leycpICsgZmlyc3QuY3RybFNlcTtcbiAgICAgICAgICBsYXN0LmN0cmxTZXEgKz0gKGlzQnVpbHRJbiA/ICcgJyA6ICd9Jyk7XG4gICAgICAgICAgaWYgKFR3b1dvcmRPcE5hbWVzLmhhc093blByb3BlcnR5KHdvcmQpKSBsYXN0W0xdW0xdW0xdLmpRLmFkZENsYXNzKCdtcS1sYXN0Jyk7XG4gICAgICAgICAgaWYgKCFzaG91bGRPbWl0UGFkZGluZyhmaXJzdFtMXSkpIGZpcnN0LmpRLmFkZENsYXNzKCdtcS1maXJzdCcpO1xuICAgICAgICAgIGlmICghc2hvdWxkT21pdFBhZGRpbmcobGFzdFtSXSkpIHtcbiAgICAgICAgICAgIGlmIChsYXN0W1JdIGluc3RhbmNlb2YgU3VwU3ViKSB7XG4gICAgICAgICAgICAgIHZhciBzdXBzdWIgPSBsYXN0W1JdOyAvLyBYWFggbW9ua2V5LXBhdGNoaW5nLCBidXQgd2hhdCdzIHRoZSByaWdodCB0aGluZyBoZXJlP1xuICAgICAgICAgICAgICAvLyBIYXZlIG9wZXJhdG9ybmFtZS1zcGVjaWZpYyBjb2RlIGluIFN1cFN1Yj8gQSBDU1MtbGlrZSBsYW5ndWFnZSB0byBzdHlsZSB0aGVcbiAgICAgICAgICAgICAgLy8gbWF0aCB0cmVlLCBidXQgd2hpY2ggaWdub3JlcyBjdXJzb3IgYW5kIHNlbGVjdGlvbiAod2hpY2ggQ1NTIGNhbid0KT9cbiAgICAgICAgICAgICAgdmFyIHJlc3BhY2UgPSBzdXBzdWIuc2libGluZ0NyZWF0ZWQgPSBzdXBzdWIuc2libGluZ0RlbGV0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdXBzdWIualEudG9nZ2xlQ2xhc3MoJ21xLWFmdGVyLW9wZXJhdG9yLW5hbWUnLCAhKHN1cHN1YltSXSBpbnN0YW5jZW9mIEJyYWNrZXQpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3QualEudG9nZ2xlQ2xhc3MoJ21xLWxhc3QnLCAhKGxhc3RbUl0gaW5zdGFuY2VvZiBCcmFja2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSBsZW4gLSAxO1xuICAgICAgICAgIGZpcnN0ID0gbGFzdDtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gc2hvdWxkT21pdFBhZGRpbmcobm9kZSkge1xuICAgIC8vIG9taXQgcGFkZGluZyBpZiBubyBub2RlLCBvciBpZiBub2RlIGFscmVhZHkgaGFzIHBhZGRpbmcgKHRvIGF2b2lkIGRvdWJsZS1wYWRkaW5nKVxuICAgIHJldHVybiAhbm9kZSB8fCAobm9kZSBpbnN0YW5jZW9mIEJpbmFyeU9wZXJhdG9yKSB8fCAobm9kZSBpbnN0YW5jZW9mIFN1bW1hdGlvbk5vdGF0aW9uKTtcbiAgfVxufSk7XG52YXIgQnVpbHRJbk9wTmFtZXMgPSB7fTsgLy8gdGhlIHNldCBvZiBvcGVyYXRvciBuYW1lcyBsaWtlIFxcc2luLCBcXGNvcywgZXRjIHRoYXRcbiAgLy8gYXJlIGJ1aWx0LWludG8gTGFUZVgsIHNlZSBTZWN0aW9uIDMuMTcgb2YgdGhlIFNob3J0IE1hdGggR3VpZGU6IGh0dHA6Ly90aW55dXJsLmNvbS9qbTlva2pjXG4gIC8vIE1hdGhRdWlsbCBhdXRvLXVuaXRhbGljaXplcyBzb21lIG9wZXJhdG9yIG5hbWVzIG5vdCBpbiB0aGF0IHNldCwgbGlrZSAnaGNmJ1xuICAvLyBhbmQgJ2Fyc2luaCcsIHdoaWNoIG11c3QgYmUgZXhwb3J0ZWQgYXMgXFxvcGVyYXRvcm5hbWV7aGNmfSBhbmRcbiAgLy8gXFxvcGVyYXRvcm5hbWV7YXJzaW5ofS4gTm90ZTogb3Zlci91bmRlciBsaW5lL2Fycm93IFxcbGltIHZhcmlhbnRzIGxpa2VcbiAgLy8gXFx2YXJsaW1zdXAgYXJlIG5vdCBzdXBwb3J0ZWRcbnZhciBBdXRvT3BOYW1lcyA9IE9wdGlvbnMucC5hdXRvT3BlcmF0b3JOYW1lcyA9IHsgX21heExlbmd0aDogOSB9OyAvLyB0aGUgc2V0XG4gIC8vIG9mIG9wZXJhdG9yIG5hbWVzIHRoYXQgTWF0aFF1aWxsIGF1dG8tdW5pdGFsaWNpemVzIGJ5IGRlZmF1bHQ7IG92ZXJyaWRhYmxlXG52YXIgVHdvV29yZE9wTmFtZXMgPSB7IGxpbXN1cDogMSwgbGltaW5mOiAxLCBwcm9qbGltOiAxLCBpbmpsaW06IDEgfTtcbihmdW5jdGlvbigpIHtcbiAgdmFyIG1vc3RPcHMgPSAoJ2FyZyBkZWcgZGV0IGRpbSBleHAgZ2NkIGhvbSBpbmYga2VyIGxnIGxpbSBsbiBsb2cgbWF4IG1pbiBzdXAnXG4gICAgICAgICAgICAgICAgICsgJyBsaW1zdXAgbGltaW5mIGluamxpbSBwcm9qbGltIFByJykuc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3N0T3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgQnVpbHRJbk9wTmFtZXNbbW9zdE9wc1tpXV0gPSBBdXRvT3BOYW1lc1ttb3N0T3BzW2ldXSA9IDE7XG4gIH1cblxuICB2YXIgYnVpbHRJblRyaWdzID0gLy8gd2h5IGNvdGggYnV0IG5vdCBzZWNoIGFuZCBjc2NoLCBMYVRlWD9cbiAgICAnc2luIGNvcyB0YW4gYXJjc2luIGFyY2NvcyBhcmN0YW4gc2luaCBjb3NoIHRhbmggc2VjIGNzYyBjb3QgY290aCcuc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWlsdEluVHJpZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBCdWlsdEluT3BOYW1lc1tidWlsdEluVHJpZ3NbaV1dID0gMTtcbiAgfVxuXG4gIHZhciBhdXRvVHJpZ3MgPSAnc2luIGNvcyB0YW4gc2VjIGNvc2VjIGNzYyBjb3RhbiBjb3QgY3RnJy5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF1dG9Ucmlncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIEF1dG9PcE5hbWVzW2F1dG9Ucmlnc1tpXV0gPVxuICAgIEF1dG9PcE5hbWVzWydhcmMnK2F1dG9Ucmlnc1tpXV0gPVxuICAgIEF1dG9PcE5hbWVzW2F1dG9Ucmlnc1tpXSsnaCddID1cbiAgICBBdXRvT3BOYW1lc1snYXInK2F1dG9Ucmlnc1tpXSsnaCddID1cbiAgICBBdXRvT3BOYW1lc1snYXJjJythdXRvVHJpZ3NbaV0rJ2gnXSA9IDE7XG4gIH1cblxuICAvLyBjb21wYXQgd2l0aCBzb21lIG9mIHRoZSBub25zdGFuZGFyZCBMYVRlWCBleHBvcnRlZCBieSBNYXRoUXVpbGxcbiAgLy8gYmVmb3JlICMyNDcuIE5vbmUgb2YgdGhlc2UgYXJlIHJlYWwgTGFUZVggY29tbWFuZHMgc28sIHNlZW1zIHNhZmVcbiAgdmFyIG1vcmVOb25zdGFuZGFyZE9wcyA9ICdnY2YgaGNmIGxjbSBwcm9qIHNwYW4nLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9yZU5vbnN0YW5kYXJkT3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgQXV0b09wTmFtZXNbbW9yZU5vbnN0YW5kYXJkT3BzW2ldXSA9IDE7XG4gIH1cbn0oKSk7XG5vcHRpb25Qcm9jZXNzb3JzLmF1dG9PcGVyYXRvck5hbWVzID0gZnVuY3Rpb24oY21kcykge1xuICBpZiAoIS9eW2Etel0rKD86IFthLXpdKykqJC9pLnRlc3QoY21kcykpIHtcbiAgICB0aHJvdyAnXCInK2NtZHMrJ1wiIG5vdCBhIHNwYWNlLWRlbGltaXRlZCBsaXN0IG9mIG9ubHkgbGV0dGVycyc7XG4gIH1cbiAgdmFyIGxpc3QgPSBjbWRzLnNwbGl0KCcgJyksIGRpY3QgPSB7fSwgbWF4TGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGNtZCA9IGxpc3RbaV07XG4gICAgaWYgKGNtZC5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyAnXCInK2NtZCsnXCIgbm90IG1pbmltdW0gbGVuZ3RoIG9mIDInO1xuICAgIH1cbiAgICBkaWN0W2NtZF0gPSAxO1xuICAgIG1heExlbmd0aCA9IG1heChtYXhMZW5ndGgsIGNtZC5sZW5ndGgpO1xuICB9XG4gIGRpY3QuX21heExlbmd0aCA9IG1heExlbmd0aDtcbiAgcmV0dXJuIGRpY3Q7XG59O1xudmFyIE9wZXJhdG9yTmFtZSA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oZm4pIHsgdGhpcy5jdHJsU2VxID0gZm47IH07XG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgdmFyIGZuID0gdGhpcy5jdHJsU2VxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIExldHRlcihmbi5jaGFyQXQoaSkpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgIH1cbiAgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm4gPSB0aGlzLmN0cmxTZXE7XG4gICAgdmFyIGJsb2NrID0gTWF0aEJsb2NrKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgTGV0dGVyKGZuLmNoYXJBdChpKSkuYWRvcHQoYmxvY2ssIGJsb2NrLmVuZHNbUl0sIDApO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyLnN1Y2NlZWQoYmxvY2suY2hpbGRyZW4oKSk7XG4gIH07XG59KTtcbmZvciAodmFyIGZuIGluIEF1dG9PcE5hbWVzKSBpZiAoQXV0b09wTmFtZXMuaGFzT3duUHJvcGVydHkoZm4pKSB7XG4gIExhdGV4Q21kc1tmbl0gPSBPcGVyYXRvck5hbWU7XG59XG5MYXRleENtZHMub3BlcmF0b3JuYW1lID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXykge1xuICBfLmNyZWF0ZUxlZnRPZiA9IG5vb3A7XG4gIF8ubnVtQmxvY2tzID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYXRleE1hdGhQYXJzZXIuYmxvY2subWFwKGZ1bmN0aW9uKGIpIHsgcmV0dXJuIGIuY2hpbGRyZW4oKTsgfSk7XG4gIH07XG59KTtcblxuTGF0ZXhDbWRzLmYgPSBQKExldHRlciwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIFN5bWJvbC5wLmluaXQuY2FsbCh0aGlzLCB0aGlzLmxldHRlciA9ICdmJywgJzx2YXIgY2xhc3M9XCJtcS1mXCI+ZjwvdmFyPicpO1xuICB9O1xuICBfLml0YWxpY2l6ZSA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICB0aGlzLmpRLmh0bWwoJ2YnKS50b2dnbGVDbGFzcygnbXEtZicsIGJvb2wpO1xuICAgIHJldHVybiBzdXBlcl8uaXRhbGljaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxuLy8gVmFuaWxsYVN5bWJvbCdzXG5MYXRleENtZHNbJyAnXSA9IExhdGV4Q21kcy5zcGFjZSA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFwgJywgJyZuYnNwOycpO1xuXG5MYXRleENtZHNbXCInXCJdID0gTGF0ZXhDbWRzLnByaW1lID0gYmluZChWYW5pbGxhU3ltYm9sLCBcIidcIiwgJyZwcmltZTsnKTtcblxuTGF0ZXhDbWRzLmJhY2tzbGFzaCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwnXFxcXGJhY2tzbGFzaCAnLCdcXFxcJyk7XG5pZiAoIUNoYXJDbWRzWydcXFxcJ10pIENoYXJDbWRzWydcXFxcJ10gPSBMYXRleENtZHMuYmFja3NsYXNoO1xuXG5MYXRleENtZHMuJCA9IGJpbmQoVmFuaWxsYVN5bWJvbCwgJ1xcXFwkJywgJyQnKTtcblxuLy8gZG9lcyBub3QgdXNlIFN5bWJvbGEgZm9udFxudmFyIE5vblN5bWJvbGFTeW1ib2wgPSBQKFN5bWJvbCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGNoLCBodG1sKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCBjaCwgJzxzcGFuIGNsYXNzPVwibXEtbm9uU3ltYm9sYVwiPicrKGh0bWwgfHwgY2gpKyc8L3NwYW4+Jyk7XG4gIH07XG59KTtcblxuTGF0ZXhDbWRzWydAJ10gPSBOb25TeW1ib2xhU3ltYm9sO1xuTGF0ZXhDbWRzWycmJ10gPSBiaW5kKE5vblN5bWJvbGFTeW1ib2wsICdcXFxcJicsICcmYW1wOycpO1xuTGF0ZXhDbWRzWyclJ10gPSBiaW5kKE5vblN5bWJvbGFTeW1ib2wsICdcXFxcJScsICclJyk7XG5cbi8vdGhlIGZvbGxvd2luZyBhcmUgYWxsIEdyZWVrIHRvIG1lLCBidXQgdGhpcyBoZWxwZWQgYSBsb3Q6IGh0dHA6Ly93d3cuYW1zLm9yZy9TVElYL2lvbi9zdGl4c2lnMDMuaHRtbFxuXG4vL2xvd2VyY2FzZSBHcmVlayBsZXR0ZXIgdmFyaWFibGVzXG5MYXRleENtZHMuYWxwaGEgPVxuTGF0ZXhDbWRzLmJldGEgPVxuTGF0ZXhDbWRzLmdhbW1hID1cbkxhdGV4Q21kcy5kZWx0YSA9XG5MYXRleENtZHMuemV0YSA9XG5MYXRleENtZHMuZXRhID1cbkxhdGV4Q21kcy50aGV0YSA9XG5MYXRleENtZHMuaW90YSA9XG5MYXRleENtZHMua2FwcGEgPVxuTGF0ZXhDbWRzLm11ID1cbkxhdGV4Q21kcy5udSA9XG5MYXRleENtZHMueGkgPVxuTGF0ZXhDbWRzLnJobyA9XG5MYXRleENtZHMuc2lnbWEgPVxuTGF0ZXhDbWRzLnRhdSA9XG5MYXRleENtZHMuY2hpID1cbkxhdGV4Q21kcy5wc2kgPVxuTGF0ZXhDbWRzLm9tZWdhID0gUChWYXJpYWJsZSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGxhdGV4KSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCdcXFxcJytsYXRleCsnICcsJyYnK2xhdGV4Kyc7Jyk7XG4gIH07XG59KTtcblxuLy93aHkgY2FuJ3QgYW55Ym9keSBGVUNLSU5HIGFncmVlIG9uIHRoZXNlXG5MYXRleENtZHMucGhpID0gLy9XM0Mgb3IgVW5pY29kZT9cbiAgYmluZChWYXJpYWJsZSwnXFxcXHBoaSAnLCcmIzk4MTsnKTtcblxuTGF0ZXhDbWRzLnBoaXYgPSAvL0Vsc2V2aWVyIGFuZCA5NTczLTEzXG5MYXRleENtZHMudmFycGhpID0gLy9BTVMgYW5kIExhVGVYXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx2YXJwaGkgJywnJnBoaTsnKTtcblxuTGF0ZXhDbWRzLmVwc2lsb24gPSAvL1czQyBvciBVbmljb2RlP1xuICBiaW5kKFZhcmlhYmxlLCdcXFxcZXBzaWxvbiAnLCcmIzEwMTM7Jyk7XG5cbkxhdGV4Q21kcy5lcHNpdiA9IC8vRWxzZXZpZXIgYW5kIDk1NzMtMTNcbkxhdGV4Q21kcy52YXJlcHNpbG9uID0gLy9BTVMgYW5kIExhVGVYXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx2YXJlcHNpbG9uICcsJyZlcHNpbG9uOycpO1xuXG5MYXRleENtZHMucGl2ID0gLy9XM0MvVW5pY29kZSBhbmQgRWxzZXZpZXIgYW5kIDk1NzMtMTNcbkxhdGV4Q21kcy52YXJwaSA9IC8vQU1TIGFuZCBMYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFycGkgJywnJnBpdjsnKTtcblxuTGF0ZXhDbWRzLnNpZ21hZiA9IC8vVzNDL1VuaWNvZGVcbkxhdGV4Q21kcy5zaWdtYXYgPSAvL0Vsc2V2aWVyXG5MYXRleENtZHMudmFyc2lnbWEgPSAvL0xhVGVYXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx2YXJzaWdtYSAnLCcmc2lnbWFmOycpO1xuXG5MYXRleENtZHMudGhldGF2ID0gLy9FbHNldmllciBhbmQgOTU3My0xM1xuTGF0ZXhDbWRzLnZhcnRoZXRhID0gLy9BTVMgYW5kIExhVGVYXG5MYXRleENtZHMudGhldGFzeW0gPSAvL1czQy9Vbmljb2RlXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx2YXJ0aGV0YSAnLCcmdGhldGFzeW07Jyk7XG5cbkxhdGV4Q21kcy51cHNpbG9uID0gLy9BTVMgYW5kIExhVGVYIGFuZCBXM0MvVW5pY29kZVxuTGF0ZXhDbWRzLnVwc2kgPSAvL0Vsc2V2aWVyIGFuZCA5NTczLTEzXG4gIGJpbmQoVmFyaWFibGUsJ1xcXFx1cHNpbG9uICcsJyZ1cHNpbG9uOycpO1xuXG4vL3RoZXNlIGFyZW4ndCBldmVuIG1lbnRpb25lZCBpbiB0aGUgSFRNTCBjaGFyYWN0ZXIgZW50aXR5IHJlZmVyZW5jZXNcbkxhdGV4Q21kcy5nYW1tYWQgPSAvL0Vsc2V2aWVyXG5MYXRleENtZHMuR2FtbWFkID0gLy85NTczLTEzIC0tIFdURiwgcmlnaHQ/IEkgZHVubm8gaWYgdGhpcyB3YXMgYSB0eXBvIGluIHRoZSByZWZlcmVuY2UgKHNlZSBhYm92ZSlcbkxhdGV4Q21kcy5kaWdhbW1hID0gLy9MYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcZGlnYW1tYSAnLCcmIzk4OTsnKTtcblxuTGF0ZXhDbWRzLmthcHBhdiA9IC8vRWxzZXZpZXJcbkxhdGV4Q21kcy52YXJrYXBwYSA9IC8vQU1TIGFuZCBMYVRlWFxuICBiaW5kKFZhcmlhYmxlLCdcXFxcdmFya2FwcGEgJywnJiMxMDA4OycpO1xuXG5MYXRleENtZHMucmhvdiA9IC8vRWxzZXZpZXIgYW5kIDk1NzMtMTNcbkxhdGV4Q21kcy52YXJyaG8gPSAvL0FNUyBhbmQgTGFUZVhcbiAgYmluZChWYXJpYWJsZSwnXFxcXHZhcnJobyAnLCcmIzEwMDk7Jyk7XG5cbi8vR3JlZWsgY29uc3RhbnRzLCBsb29rIGJlc3QgaW4gbm9uLWl0YWxpY2l6ZWQgVGltZXMgTmV3IFJvbWFuXG5MYXRleENtZHMucGkgPSBMYXRleENtZHNbJ1xcdTAzYzAnXSA9IGJpbmQoTm9uU3ltYm9sYVN5bWJvbCwnXFxcXHBpICcsJyZwaTsnKTtcbkxhdGV4Q21kcy5sYW1iZGEgPSBiaW5kKE5vblN5bWJvbGFTeW1ib2wsJ1xcXFxsYW1iZGEgJywnJmxhbWJkYTsnKTtcblxuLy91cHBlcmNhc2UgZ3JlZWsgbGV0dGVyc1xuXG5MYXRleENtZHMuVXBzaWxvbiA9IC8vTGFUZVhcbkxhdGV4Q21kcy5VcHNpID0gLy9FbHNldmllciBhbmQgOTU3My0xM1xuTGF0ZXhDbWRzLnVwc2loID0gLy9XM0MvVW5pY29kZSBcInVwc2lsb24gd2l0aCBob29rXCJcbkxhdGV4Q21kcy5VcHNpaCA9IC8vJ2NvcyBpdCBtYWtlcyBzZW5zZSB0byBtZVxuICBiaW5kKFN5bWJvbCwnXFxcXFVwc2lsb24gJywnPHZhciBzdHlsZT1cImZvbnQtZmFtaWx5OiBzZXJpZlwiPiZ1cHNpaDs8L3Zhcj4nKTsgLy9TeW1ib2xhJ3MgJ3Vwc2lsb24gd2l0aCBhIGhvb2snIGlzIGEgY2FwaXRhbCBZIHdpdGhvdXQgaG9va3MgOihcblxuLy9vdGhlciBzeW1ib2xzIHdpdGggdGhlIHNhbWUgTGFUZVggY29tbWFuZCBhbmQgSFRNTCBjaGFyYWN0ZXIgZW50aXR5IHJlZmVyZW5jZVxuTGF0ZXhDbWRzLkdhbW1hID1cbkxhdGV4Q21kcy5EZWx0YSA9XG5MYXRleENtZHMuVGhldGEgPVxuTGF0ZXhDbWRzLkxhbWJkYSA9XG5MYXRleENtZHMuWGkgPVxuTGF0ZXhDbWRzLlBpID1cbkxhdGV4Q21kcy5TaWdtYSA9XG5MYXRleENtZHMuUGhpID1cbkxhdGV4Q21kcy5Qc2kgPVxuTGF0ZXhDbWRzLk9tZWdhID1cbkxhdGV4Q21kcy5mb3JhbGwgPSBQKFZhbmlsbGFTeW1ib2wsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihsYXRleCkge1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywnXFxcXCcrbGF0ZXgrJyAnLCcmJytsYXRleCsnOycpO1xuICB9O1xufSk7XG5cbi8vIHN5bWJvbHMgdGhhdCBhcmVuJ3QgYSBzaW5nbGUgTWF0aENvbW1hbmQsIGJ1dCBhcmUgaW5zdGVhZCBhIHdob2xlXG4vLyBGcmFnbWVudC4gQ3JlYXRlcyB0aGUgRnJhZ21lbnQgZnJvbSBhIExhVGVYIHN0cmluZ1xudmFyIExhdGV4RnJhZ21lbnQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGxhdGV4KSB7IHRoaXMubGF0ZXggPSBsYXRleDsgfTtcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICB2YXIgYmxvY2sgPSBsYXRleE1hdGhQYXJzZXIucGFyc2UodGhpcy5sYXRleCk7XG4gICAgYmxvY2suY2hpbGRyZW4oKS5hZG9wdChjdXJzb3IucGFyZW50LCBjdXJzb3JbTF0sIGN1cnNvcltSXSk7XG4gICAgY3Vyc29yW0xdID0gYmxvY2suZW5kc1tSXTtcbiAgICBibG9jay5qUWl6ZSgpLmluc2VydEJlZm9yZShjdXJzb3IualEpO1xuICAgIGJsb2NrLmZpbmFsaXplSW5zZXJ0KGN1cnNvci5vcHRpb25zLCBjdXJzb3IpO1xuICAgIGlmIChibG9jay5lbmRzW1JdW1JdLnNpYmxpbmdDcmVhdGVkKSBibG9jay5lbmRzW1JdW1JdLnNpYmxpbmdDcmVhdGVkKGN1cnNvci5vcHRpb25zLCBMKTtcbiAgICBpZiAoYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZCkgYmxvY2suZW5kc1tMXVtMXS5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgUik7XG4gICAgY3Vyc29yLnBhcmVudC5idWJibGUoJ3JlZmxvdycpO1xuICB9O1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcmFnID0gbGF0ZXhNYXRoUGFyc2VyLnBhcnNlKHRoaXMubGF0ZXgpLmNoaWxkcmVuKCk7XG4gICAgcmV0dXJuIFBhcnNlci5zdWNjZWVkKGZyYWcpO1xuICB9O1xufSk7XG5cbi8vIGZvciB3aGF0IHNlZW1zIHRvIG1lIGxpa2UgW3N0dXBpZCByZWFzb25zXVsxXSwgVW5pY29kZSBwcm92aWRlc1xuLy8gc3Vic2NyaXB0ZWQgYW5kIHN1cGVyc2NyaXB0ZWQgdmVyc2lvbnMgb2YgYWxsIHRlbiBBcmFiaWMgbnVtZXJhbHMsXG4vLyBhcyB3ZWxsIGFzIFtzby1jYWxsZWQgXCJ2dWxnYXIgZnJhY3Rpb25zXCJdWzJdLlxuLy8gTm9ib2R5IHJlYWxseSBjYXJlcyBhYm91dCBtb3N0IG9mIHRoZW0sIGJ1dCBzb21lIG9mIHRoZW0gYWN0dWFsbHlcbi8vIHByZWRhdGUgVW5pY29kZSwgZGF0aW5nIGJhY2sgdG8gW0lTTy04ODU5LTFdWzNdLCBhcHBhcmVudGx5IGFsc29cbi8vIGtub3duIGFzIFwiTGF0aW4tMVwiLCB3aGljaCBhbW9uZyBvdGhlciB0aGluZ3MgW1dpbmRvd3MtMTI1Ml1bNF1cbi8vIGxhcmdlbHkgY29pbmNpZGVzIHdpdGgsIHNvIE1pY3Jvc29mdCBXb3JkIHNvbWV0aW1lcyBpbnNlcnRzIHRoZW1cbi8vIGFuZCB0aGV5IGdldCBjb3B5LXBhc3RlZCBpbnRvIE1hdGhRdWlsbC5cbi8vXG4vLyAoSXJyZWxldmFudCBidXQgZnVubnkgc3Rvcnk6IHRob3VnaCBub3QgYSBzdXBlcnNldCBvZiBMYXRpbi0xIGFrYVxuLy8gSVNPLTg4NTktMSwgV2luZG93cy0xMjUyICoqaXMqKiBhIHN0cmljdCBzdXBlcnNldCBvZiB0aGUgXCJjbG9zZWx5XG4vLyByZWxhdGVkIGJ1dCBkaXN0aW5jdFwiWzNdIFwiSVNPIDg4NTktMVwiIC0tIHNlZSB0aGUgbGFjayBvZiBhIGRhc2hcbi8vIGFmdGVyIFwiSVNPXCI/IENvbXBsZXRlbHkgZGlmZmVyZW50IGNoYXJhY3RlciBzZXQsIGxpa2UgZWxlcGhhbnRzIHZzXG4vLyBlbGVwaGFudCBzZWFscywgb3IgXCJab21iaWVzXCIgdnMgXCJab21iaWUgUmVkbmVjayBUb3J0dXJlIEZhbWlseVwiLlxuLy8gV2hhdCBraW5kIG9mIGlkaW90IHdvdWxkIGdldCB0aGVtIGNvbmZ1c2VkLlxuLy8gUGVvcGxlIGluIGZhY3QgZ290IHRoZW0gY29uZnVzZWQgc28gbXVjaCwgaXQgd2FzIHNvIGNvbW1vbiB0b1xuLy8gbWlzbGFiZWwgV2luZG93cy0xMjUyIHRleHQgYXMgSVNPLTg4NTktMSwgdGhhdCBtb3N0IG1vZGVybiB3ZWJcbi8vIGJyb3dzZXJzIGFuZCBlbWFpbCBjbGllbnRzIHRyZWF0IHRoZSBNSU1FIGNoYXJzZXQgb2YgSVNPLTg4NTktMVxuLy8gYXMgYWN0dWFsbHkgV2luZG93cy0xMjUyLCBiZWhhdmlvciBub3cgc3RhbmRhcmQgaW4gdGhlIEhUTUw1IHNwZWMuKVxuLy9cbi8vIFsxXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbmljb2RlX3N1YnNjcmlwdHNfYW5kc3VwZXJfc2NyaXB0c1xuLy8gWzJdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL051bWJlcl9Gb3Jtc1xuLy8gWzNdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTTy9JRUNfODg1OS0xXG4vLyBbNF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2luZG93cy0xMjUyXG5MYXRleENtZHNbJ1xcdTAwYjknXSA9IGJpbmQoTGF0ZXhGcmFnbWVudCwgJ14xJyk7XG5MYXRleENtZHNbJ1xcdTAwYjInXSA9IGJpbmQoTGF0ZXhGcmFnbWVudCwgJ14yJyk7XG5MYXRleENtZHNbJ1xcdTAwYjMnXSA9IGJpbmQoTGF0ZXhGcmFnbWVudCwgJ14zJyk7XG5MYXRleENtZHNbJ1xcdTAwYmMnXSA9IGJpbmQoTGF0ZXhGcmFnbWVudCwgJ1xcXFxmcmFjMTQnKTtcbkxhdGV4Q21kc1snXFx1MDBiZCddID0gYmluZChMYXRleEZyYWdtZW50LCAnXFxcXGZyYWMxMicpO1xuTGF0ZXhDbWRzWydcXHUwMGJlJ10gPSBiaW5kKExhdGV4RnJhZ21lbnQsICdcXFxcZnJhYzM0Jyk7XG5cbnZhciBQbHVzTWludXMgPSBQKEJpbmFyeU9wZXJhdG9yLCBmdW5jdGlvbihfKSB7XG4gIF8uaW5pdCA9IFZhbmlsbGFTeW1ib2wucHJvdG90eXBlLmluaXQ7XG5cbiAgXy5jb250YWN0V2VsZCA9IF8uc2libGluZ0NyZWF0ZWQgPSBfLnNpYmxpbmdEZWxldGVkID0gZnVuY3Rpb24ob3B0cywgZGlyKSB7XG4gICAgaWYgKGRpciA9PT0gUikgcmV0dXJuOyAvLyBpZ25vcmUgaWYgc2libGluZyBvbmx5IGNoYW5nZWQgb24gdGhlIHJpZ2h0XG4gICAgLy8gSWYgdGhlIGxlZnQgc2libGluZyBpcyBhIGJpbmFyeSBvcGVyYXRvciBvciBhIHNlcGFyYXRvciAoY29tbWEsIHNlbWljb2xvbiwgY29sb24pXG4gICAgLy8gb3IgYW4gb3BlbiBicmFja2V0IChvcGVuIHBhcmVudGhlc2lzLCBvcGVuIHNxdWFyZSBicmFja2V0KVxuICAgIC8vIGNvbnNpZGVyIHRoZSBvcGVyYXRvciB0byBiZSB1bmFyeSwgb3RoZXJ3aXNlIGJpbmFyeVxuICAgIHRoaXMualFbMF0uY2xhc3NOYW1lID1cbiAgICAgICghdGhpc1tMXSB8fCB0aGlzW0xdIGluc3RhbmNlb2YgQmluYXJ5T3BlcmF0b3IgfHwgL15bLDs6XFwoXFxbXSQvLnRlc3QodGhpc1tMXS5jdHJsU2VxKSA/ICcnIDogJ21xLWJpbmFyeS1vcGVyYXRvcicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbkxhdGV4Q21kc1snKyddID0gYmluZChQbHVzTWludXMsICcrJywgJysnKTtcbi8veWVzLCB0aGVzZSBhcmUgZGlmZmVyZW50IGRhc2hlcywgSSB0aGluayBvbmUgaXMgYW4gZW4gZGFzaCBhbmQgdGhlIG90aGVyIGlzIGEgaHlwaGVuXG5MYXRleENtZHNbJ1xcdTIwMTMnXSA9IExhdGV4Q21kc1snLSddID0gYmluZChQbHVzTWludXMsICctJywgJyZtaW51czsnKTtcbkxhdGV4Q21kc1snXFx1MDBiMSddID0gTGF0ZXhDbWRzLnBtID0gTGF0ZXhDbWRzLnBsdXNtbiA9IExhdGV4Q21kcy5wbHVzbWludXMgPVxuICBiaW5kKFBsdXNNaW51cywnXFxcXHBtICcsJyZwbHVzbW47Jyk7XG5MYXRleENtZHMubXAgPSBMYXRleENtZHMubW5wbHVzID0gTGF0ZXhDbWRzLm1pbnVzcGx1cyA9XG4gIGJpbmQoUGx1c01pbnVzLCdcXFxcbXAgJywnJiM4NzIzOycpO1xuXG5DaGFyQ21kc1snKiddID0gTGF0ZXhDbWRzLnNkb3QgPSBMYXRleENtZHMuY2RvdCA9XG4gIGJpbmQoQmluYXJ5T3BlcmF0b3IsICdcXFxcY2RvdCAnLCAnJm1pZGRvdDsnLCAnKicpO1xuLy9zZW1hbnRpY2FsbHkgc2hvdWxkIGJlICZzZG90OywgYnV0ICZtaWRkb3Q7IGxvb2tzIGJldHRlclxuXG52YXIgSW5lcXVhbGl0eSA9IFAoQmluYXJ5T3BlcmF0b3IsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihkYXRhLCBzdHJpY3QpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc3RyaWN0ID0gc3RyaWN0O1xuICAgIHZhciBzdHJpY3RuZXNzID0gKHN0cmljdCA/ICdTdHJpY3QnIDogJycpO1xuICAgIHN1cGVyXy5pbml0LmNhbGwodGhpcywgZGF0YVsnY3RybFNlcScrc3RyaWN0bmVzc10sIGRhdGFbJ2h0bWwnK3N0cmljdG5lc3NdLFxuICAgICAgICAgICAgICAgICAgICAgZGF0YVsndGV4dCcrc3RyaWN0bmVzc10pO1xuICB9O1xuICBfLnN3YXAgPSBmdW5jdGlvbihzdHJpY3QpIHtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdDtcbiAgICB2YXIgc3RyaWN0bmVzcyA9IChzdHJpY3QgPyAnU3RyaWN0JyA6ICcnKTtcbiAgICB0aGlzLmN0cmxTZXEgPSB0aGlzLmRhdGFbJ2N0cmxTZXEnK3N0cmljdG5lc3NdO1xuICAgIHRoaXMualEuaHRtbCh0aGlzLmRhdGFbJ2h0bWwnK3N0cmljdG5lc3NdKTtcbiAgICB0aGlzLnRleHRUZW1wbGF0ZSA9IFsgdGhpcy5kYXRhWyd0ZXh0JytzdHJpY3RuZXNzXSBdO1xuICB9O1xuICBfLmRlbGV0ZVRvd2FyZHMgPSBmdW5jdGlvbihkaXIsIGN1cnNvcikge1xuICAgIGlmIChkaXIgPT09IEwgJiYgIXRoaXMuc3RyaWN0KSB7XG4gICAgICB0aGlzLnN3YXAodHJ1ZSk7XG4gICAgICB0aGlzLmJ1YmJsZSgncmVmbG93Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyXy5kZWxldGVUb3dhcmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxudmFyIGxlc3MgPSB7IGN0cmxTZXE6ICdcXFxcbGUgJywgaHRtbDogJyZsZTsnLCB0ZXh0OiAnXFx1MjI2NCcsXG4gICAgICAgICAgICAgY3RybFNlcVN0cmljdDogJzwnLCBodG1sU3RyaWN0OiAnJmx0OycsIHRleHRTdHJpY3Q6ICc8JyB9O1xudmFyIGdyZWF0ZXIgPSB7IGN0cmxTZXE6ICdcXFxcZ2UgJywgaHRtbDogJyZnZTsnLCB0ZXh0OiAnXFx1MjI2NScsXG4gICAgICAgICAgICAgICAgY3RybFNlcVN0cmljdDogJz4nLCBodG1sU3RyaWN0OiAnJmd0OycsIHRleHRTdHJpY3Q6ICc+JyB9O1xuXG5MYXRleENtZHNbJzwnXSA9IExhdGV4Q21kcy5sdCA9IGJpbmQoSW5lcXVhbGl0eSwgbGVzcywgdHJ1ZSk7XG5MYXRleENtZHNbJz4nXSA9IExhdGV4Q21kcy5ndCA9IGJpbmQoSW5lcXVhbGl0eSwgZ3JlYXRlciwgdHJ1ZSk7XG5MYXRleENtZHNbJ1xcdTIyNjQnXSA9IExhdGV4Q21kcy5sZSA9IExhdGV4Q21kcy5sZXEgPSBiaW5kKEluZXF1YWxpdHksIGxlc3MsIGZhbHNlKTtcbkxhdGV4Q21kc1snXFx1MjI2NSddID0gTGF0ZXhDbWRzLmdlID0gTGF0ZXhDbWRzLmdlcSA9IGJpbmQoSW5lcXVhbGl0eSwgZ3JlYXRlciwgZmFsc2UpO1xuXG52YXIgRXF1YWxpdHkgPSBQKEJpbmFyeU9wZXJhdG9yLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCAnPScsICc9Jyk7XG4gIH07XG4gIF8uY3JlYXRlTGVmdE9mID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgaWYgKGN1cnNvcltMXSBpbnN0YW5jZW9mIEluZXF1YWxpdHkgJiYgY3Vyc29yW0xdLnN0cmljdCkge1xuICAgICAgY3Vyc29yW0xdLnN3YXAoZmFsc2UpO1xuICAgICAgY3Vyc29yW0xdLmJ1YmJsZSgncmVmbG93Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuTGF0ZXhDbWRzWyc9J10gPSBFcXVhbGl0eTtcblxuTGF0ZXhDbWRzWydcXHUwMGQ3J10gPSBMYXRleENtZHMudGltZXMgPSBiaW5kKEJpbmFyeU9wZXJhdG9yLCAnXFxcXHRpbWVzICcsICcmdGltZXM7JywgJ1t4XScpO1xuXG5MYXRleENtZHNbJ1xcdTAwZjcnXSA9IExhdGV4Q21kcy5kaXYgPSBMYXRleENtZHMuZGl2aWRlID0gTGF0ZXhDbWRzLmRpdmlkZXMgPVxuICBiaW5kKEJpbmFyeU9wZXJhdG9yLCdcXFxcZGl2ICcsJyZkaXZpZGU7JywgJ1svXScpO1xuXG5DaGFyQ21kc1snfiddID0gTGF0ZXhDbWRzLnNpbSA9IGJpbmQoQmluYXJ5T3BlcmF0b3IsICdcXFxcc2ltICcsICd+JywgJ34nKTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvbW1hbmRzIGFuZCBPcGVyYXRvcnMuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBzY2FsZSwgLy8gPSBmdW5jdGlvbihqUSwgeCwgeSkgeyAuLi4gfVxuLy93aWxsIHVzZSBhIENTUyAyRCB0cmFuc2Zvcm0gdG8gc2NhbGUgdGhlIGpRdWVyeS13cmFwcGVkIEhUTUwgZWxlbWVudHMsXG4vL29yIHRoZSBmaWx0ZXIgbWF0cml4IHRyYW5zZm9ybSBmYWxsYmFjayBmb3IgSUUgNS41LTgsIG9yIGdyYWNlZnVsbHkgZGVncmFkZSB0b1xuLy9pbmNyZWFzaW5nIHRoZSBmb250U2l6ZSB0byBtYXRjaCB0aGUgdmVydGljYWwgWSBzY2FsaW5nIGZhY3Rvci5cblxuLy9pZGVhcyBmcm9tIGh0dHA6Ly9naXRodWIuY29tL2xvdWlzcmVtaS9qcXVlcnkudHJhbnNmb3JtLmpzXG4vL3NlZSBhbHNvIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMzAxNCh2PXZzLjg1KS5hc3B4XG5cbiAgZm9yY2VJRVJlZHJhdyA9IG5vb3AsXG4gIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICBkaXZfc3R5bGUgPSBkaXYuc3R5bGUsXG4gIHRyYW5zZm9ybVByb3BOYW1lcyA9IHtcbiAgICB0cmFuc2Zvcm06MSxcbiAgICBXZWJraXRUcmFuc2Zvcm06MSxcbiAgICBNb3pUcmFuc2Zvcm06MSxcbiAgICBPVHJhbnNmb3JtOjEsXG4gICAgbXNUcmFuc2Zvcm06MVxuICB9LFxuICB0cmFuc2Zvcm1Qcm9wTmFtZTtcblxuZm9yICh2YXIgcHJvcCBpbiB0cmFuc2Zvcm1Qcm9wTmFtZXMpIHtcbiAgaWYgKHByb3AgaW4gZGl2X3N0eWxlKSB7XG4gICAgdHJhbnNmb3JtUHJvcE5hbWUgPSBwcm9wO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmlmICh0cmFuc2Zvcm1Qcm9wTmFtZSkge1xuICBzY2FsZSA9IGZ1bmN0aW9uKGpRLCB4LCB5KSB7XG4gICAgalEuY3NzKHRyYW5zZm9ybVByb3BOYW1lLCAnc2NhbGUoJyt4KycsJyt5KycpJyk7XG4gIH07XG59XG5lbHNlIGlmICgnZmlsdGVyJyBpbiBkaXZfc3R5bGUpIHsgLy9JRSA2LCA3LCAmIDggZmFsbGJhY2ssIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGF1Z2hpbmdoYW4vbWF0aHF1aWxsL3dpa2kvVHJhbnNmb3Jtc1xuICBmb3JjZUlFUmVkcmF3ID0gZnVuY3Rpb24oZWwpeyBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWU7IH07XG4gIHNjYWxlID0gZnVuY3Rpb24oalEsIHgsIHkpIHsgLy9OT1RFOiBhc3N1bWVzIHkgPiB4XG4gICAgeCAvPSAoMSsoeS0xKS8yKTtcbiAgICBqUS5jc3MoJ2ZvbnRTaXplJywgeSArICdlbScpO1xuICAgIGlmICghalEuaGFzQ2xhc3MoJ21xLW1hdHJpeGVkLWNvbnRhaW5lcicpKSB7XG4gICAgICBqUS5hZGRDbGFzcygnbXEtbWF0cml4ZWQtY29udGFpbmVyJylcbiAgICAgIC53cmFwSW5uZXIoJzxzcGFuIGNsYXNzPVwibXEtbWF0cml4ZWRcIj48L3NwYW4+Jyk7XG4gICAgfVxuICAgIHZhciBpbm5lcmpRID0galEuY2hpbGRyZW4oKVxuICAgIC5jc3MoJ2ZpbHRlcicsICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnXG4gICAgICAgICsgJy5NYXRyaXgoTTExPScgKyB4ICsgXCIsU2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCJcbiAgICApO1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU1hcmdpblJpZ2h0KCkge1xuICAgICAgalEuY3NzKCdtYXJnaW5SaWdodCcsIChpbm5lcmpRLndpZHRoKCktMSkqKHgtMSkveCArICdweCcpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVNYXJnaW5SaWdodCgpO1xuICAgIHZhciBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoY2FsY3VsYXRlTWFyZ2luUmlnaHQpO1xuICAgICQod2luZG93KS5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsSWQpO1xuICAgICAgY2FsY3VsYXRlTWFyZ2luUmlnaHQoKTtcbiAgICB9KTtcbiAgfTtcbn1cbmVsc2Uge1xuICBzY2FsZSA9IGZ1bmN0aW9uKGpRLCB4LCB5KSB7XG4gICAgalEuY3NzKCdmb250U2l6ZScsIHkgKyAnZW0nKTtcbiAgfTtcbn1cblxudmFyIFN0eWxlID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaW5pdCA9IGZ1bmN0aW9uKGN0cmxTZXEsIHRhZ05hbWUsIGF0dHJzKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCBjdHJsU2VxLCAnPCcrdGFnTmFtZSsnICcrYXR0cnMrJz4mMDwvJyt0YWdOYW1lKyc+Jyk7XG4gIH07XG59KTtcblxuLy9mb250c1xuTGF0ZXhDbWRzLm1hdGhybSA9IGJpbmQoU3R5bGUsICdcXFxcbWF0aHJtJywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1yb21hbiBtcS1mb250XCInKTtcbkxhdGV4Q21kcy5tYXRoaXQgPSBiaW5kKFN0eWxlLCAnXFxcXG1hdGhpdCcsICdpJywgJ2NsYXNzPVwibXEtZm9udFwiJyk7XG5MYXRleENtZHMubWF0aGJmID0gYmluZChTdHlsZSwgJ1xcXFxtYXRoYmYnLCAnYicsICdjbGFzcz1cIm1xLWZvbnRcIicpO1xuTGF0ZXhDbWRzLm1hdGhzZiA9IGJpbmQoU3R5bGUsICdcXFxcbWF0aHNmJywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1zYW5zLXNlcmlmIG1xLWZvbnRcIicpO1xuTGF0ZXhDbWRzLm1hdGh0dCA9IGJpbmQoU3R5bGUsICdcXFxcbWF0aHR0JywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1tb25vc3BhY2UgbXEtZm9udFwiJyk7XG4vL3RleHQtZGVjb3JhdGlvblxuTGF0ZXhDbWRzLnVuZGVybGluZSA9IGJpbmQoU3R5bGUsICdcXFxcdW5kZXJsaW5lJywgJ3NwYW4nLCAnY2xhc3M9XCJtcS1ub24tbGVhZiBtcS11bmRlcmxpbmVcIicpO1xuTGF0ZXhDbWRzLm92ZXJsaW5lID0gTGF0ZXhDbWRzLmJhciA9IGJpbmQoU3R5bGUsICdcXFxcb3ZlcmxpbmUnLCAnc3BhbicsICdjbGFzcz1cIm1xLW5vbi1sZWFmIG1xLW92ZXJsaW5lXCInKTtcbkxhdGV4Q21kcy5vdmVycmlnaHRhcnJvdyA9IGJpbmQoU3R5bGUsICdcXFxcb3ZlcnJpZ2h0YXJyb3cnLCAnc3BhbicsICdjbGFzcz1cIm1xLW5vbi1sZWFmIG1xLW92ZXJhcnJvdyBtcS1hcnJvdy1yaWdodFwiJyk7XG5MYXRleENtZHMub3ZlcmxlZnRhcnJvdyA9IGJpbmQoU3R5bGUsICdcXFxcb3ZlcmxlZnRhcnJvdycsICdzcGFuJywgJ2NsYXNzPVwibXEtbm9uLWxlYWYgbXEtb3ZlcmFycm93IG1xLWFycm93LWxlZnRcIicpO1xuXG4vLyBgXFx0ZXh0Y29sb3J7Y29sb3J9e21hdGh9YCB3aWxsIGFwcGx5IGEgY29sb3IgdG8gdGhlIGdpdmVuIG1hdGggY29udGVudCwgd2hlcmVcbi8vIGBjb2xvcmAgaXMgYW55IHZhbGlkIENTUyBDb2xvciBWYWx1ZSAoc2VlIFtTaXRlUG9pbnQgZG9jc11bXSAocmVjb21tZW5kZWQpLFxuLy8gW01vemlsbGEgZG9jc11bXSwgb3IgW1czQyBzcGVjXVtdKS5cbi8vXG4vLyBbU2l0ZVBvaW50IGRvY3NdOiBodHRwOi8vcmVmZXJlbmNlLnNpdGVwb2ludC5jb20vY3NzL2NvbG9ydmFsdWVzXG4vLyBbTW96aWxsYSBkb2NzXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvY29sb3JfdmFsdWUjVmFsdWVzXG4vLyBbVzNDIHNwZWNdOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MzLWNvbG9yLyNjb2xvcnVuaXRzXG52YXIgVGV4dENvbG9yID0gTGF0ZXhDbWRzLnRleHRjb2xvciA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLnNldENvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtdGV4dGNvbG9yXCIgc3R5bGU9XCJjb2xvcjonICsgY29sb3IgKyAnXCI+JjA8L3NwYW4+JztcbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnXFxcXHRleHRjb2xvcnsnICsgdGhpcy5jb2xvciArICd9eycgKyB0aGlzLmJsb2Nrc1swXS5sYXRleCgpICsgJ30nO1xuICB9O1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0V2hpdGVzcGFjZSA9IFBhcnNlci5vcHRXaGl0ZXNwYWNlO1xuICAgIHZhciBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nO1xuICAgIHZhciByZWdleCA9IFBhcnNlci5yZWdleDtcblxuICAgIHJldHVybiBvcHRXaGl0ZXNwYWNlXG4gICAgICAudGhlbihzdHJpbmcoJ3snKSlcbiAgICAgIC50aGVuKHJlZ2V4KC9eWyNcXHdcXHMuLCgpJS1dKi8pKVxuICAgICAgLnNraXAoc3RyaW5nKCd9JykpXG4gICAgICAudGhlbihmdW5jdGlvbihjb2xvcikge1xuICAgICAgICBzZWxmLnNldENvbG9yKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyXy5wYXJzZXIuY2FsbChzZWxmKTtcbiAgICAgIH0pXG4gICAgO1xuICB9O1xufSk7XG5cbi8vIFZlcnkgc2ltaWxhciB0byB0aGUgXFx0ZXh0Y29sb3IgY29tbWFuZCwgYnV0IHdpbGwgYWRkIHRoZSBnaXZlbiBDU1MgY2xhc3MuXG4vLyBVc2FnZTogXFxjbGFzc3tjbGFzc25hbWV9e21hdGh9XG4vLyBOb3RlIHJlZ2V4IHRoYXQgd2hpdGVsaXN0cyB2YWxpZCBDU1MgY2xhc3NuYW1lIGNoYXJhY3RlcnM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aHF1aWxsL21hdGhxdWlsbC9wdWxsLzE5MSNkaXNjdXNzaW9uX3I0MzI3NDQyXG52YXIgQ2xhc3MgPSBMYXRleENtZHNbJ2NsYXNzJ10gPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0cmluZyA9IFBhcnNlci5zdHJpbmcsIHJlZ2V4ID0gUGFyc2VyLnJlZ2V4O1xuICAgIHJldHVybiBQYXJzZXIub3B0V2hpdGVzcGFjZVxuICAgICAgLnRoZW4oc3RyaW5nKCd7JykpXG4gICAgICAudGhlbihyZWdleCgvXlstXFx3XFxzXFxcXFxceEEwLVxceEZGXSovKSlcbiAgICAgIC5za2lwKHN0cmluZygnfScpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oY2xzKSB7XG4gICAgICAgIHNlbGYuaHRtbFRlbXBsYXRlID0gJzxzcGFuIGNsYXNzPVwibXEtY2xhc3MgJytjbHMrJ1wiPiYwPC9zcGFuPic7XG4gICAgICAgIHJldHVybiBzdXBlcl8ucGFyc2VyLmNhbGwoc2VsZik7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xuXG52YXIgU3VwU3ViID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdfey4uLn1eey4uLn0nO1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmICghY3Vyc29yW0xdICYmIGN1cnNvci5vcHRpb25zLnN1cFN1YnNSZXF1aXJlT3BlcmFuZCkgcmV0dXJuO1xuICAgIHJldHVybiBzdXBlcl8uY3JlYXRlTGVmdE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIF8uY29udGFjdFdlbGQgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAvLyBMb29rIG9uIGVpdGhlciBzaWRlIGZvciBhIFN1cFN1YiwgaWYgb25lIGlzIGZvdW5kIGNvbXBhcmUgbXlcbiAgICAvLyAuc3ViLCAuc3VwIHdpdGggaXRzIC5zdWIsIC5zdXAuIElmIEkgaGF2ZSBvbmUgdGhhdCBpdCBkb2Vzbid0LFxuICAgIC8vIHRoZW4gY2FsbCAuYWRkQmxvY2soKSBvbiBpdCB3aXRoIG15IGJsb2NrOyBpZiBJIGhhdmUgb25lIHRoYXRcbiAgICAvLyBpdCBhbHNvIGhhcywgdGhlbiBpbnNlcnQgbXkgYmxvY2sncyBjaGlsZHJlbiBpbnRvIGl0cyBibG9jayxcbiAgICAvLyB1bmxlc3MgbXkgYmxvY2sgaGFzIG5vbmUsIGluIHdoaWNoIGNhc2UgaW5zZXJ0IHRoZSBjdXJzb3IgaW50b1xuICAgIC8vIGl0cyBibG9jayAoYW5kIG5vdCBtaW5lLCBJJ20gYWJvdXQgdG8gcmVtb3ZlIG15c2VsZikgaW4gdGhlIGNhc2VcbiAgICAvLyBJIHdhcyBqdXN0IHR5cGVkLlxuICAgIC8vIFRPRE86IHNpbXBsaWZ5XG5cbiAgICAvLyBlcXVpdi4gdG8gW0wsIFJdLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7IC4uLiB9KTtcbiAgICBmb3IgKHZhciBkaXIgPSBMOyBkaXI7IGRpciA9IChkaXIgPT09IEwgPyBSIDogZmFsc2UpKSB7XG4gICAgICBpZiAodGhpc1tkaXJdIGluc3RhbmNlb2YgU3VwU3ViKSB7XG4gICAgICAgIC8vIGVxdWl2LiB0byAnc3ViIHN1cCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKHN1cHN1YikgeyAuLi4gfSk7XG4gICAgICAgIGZvciAodmFyIHN1cHN1YiA9ICdzdWInOyBzdXBzdWI7IHN1cHN1YiA9IChzdXBzdWIgPT09ICdzdWInID8gJ3N1cCcgOiBmYWxzZSkpIHtcbiAgICAgICAgICB2YXIgc3JjID0gdGhpc1tzdXBzdWJdLCBkZXN0ID0gdGhpc1tkaXJdW3N1cHN1Yl07XG4gICAgICAgICAgaWYgKCFzcmMpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghZGVzdCkgdGhpc1tkaXJdLmFkZEJsb2NrKHNyYy5kaXNvd24oKSk7XG4gICAgICAgICAgZWxzZSBpZiAoIXNyYy5pc0VtcHR5KCkpIHsgLy8gaW5zIHNyYyBjaGlsZHJlbiBhdCAtZGlyIGVuZCBvZiBkZXN0XG4gICAgICAgICAgICBzcmMualEuY2hpbGRyZW4oKS5pbnNBdERpckVuZCgtZGlyLCBkZXN0LmpRKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHNyYy5jaGlsZHJlbigpLmRpc293bigpO1xuICAgICAgICAgICAgdmFyIHB0ID0gUG9pbnQoZGVzdCwgY2hpbGRyZW4uZW5kc1tSXSwgZGVzdC5lbmRzW0xdKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT09IEwpIGNoaWxkcmVuLmFkb3B0KGRlc3QsIGRlc3QuZW5kc1tSXSwgMCk7XG4gICAgICAgICAgICBlbHNlIGNoaWxkcmVuLmFkb3B0KGRlc3QsIDAsIGRlc3QuZW5kc1tMXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgdmFyIHB0ID0gUG9pbnQoZGVzdCwgMCwgZGVzdC5lbmRzW0xdKTtcbiAgICAgICAgICB0aGlzLnBsYWNlQ3Vyc29yID0gKGZ1bmN0aW9uKGRlc3QsIHNyYykgeyAvLyBUT0RPOiBkb24ndCBtb25rZXktcGF0Y2hcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjdXJzb3IpIHsgY3Vyc29yLmluc0F0RGlyRW5kKC1kaXIsIGRlc3QgfHwgc3JjKTsgfTtcbiAgICAgICAgICB9KGRlc3QsIHNyYykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIGlmIChjdXJzb3IgJiYgY3Vyc29yW0xdID09PSB0aGlzKSB7XG4gICAgICAgICAgaWYgKGRpciA9PT0gUiAmJiBwdCkge1xuICAgICAgICAgICAgcHRbTF0gPyBjdXJzb3IuaW5zUmlnaHRPZihwdFtMXSkgOiBjdXJzb3IuaW5zQXRMZWZ0RW5kKHB0LnBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgY3Vyc29yLmluc1JpZ2h0T2YodGhpc1tkaXJdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE9wdGlvbnMucC5jaGFyc1RoYXRCcmVha091dE9mU3VwU3ViID0gJyc7XG4gIF8uZmluYWxpemVUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmRzW0xdLndyaXRlID0gZnVuY3Rpb24oY3Vyc29yLCBjaCkge1xuICAgICAgaWYgKGN1cnNvci5vcHRpb25zLmF1dG9TdWJzY3JpcHROdW1lcmFscyAmJiB0aGlzID09PSB0aGlzLnBhcmVudC5zdWIpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIHJldHVybjtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY2hUb0NtZChjaCk7XG4gICAgICAgIGlmIChjbWQgaW5zdGFuY2VvZiBTeW1ib2wpIGN1cnNvci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgZWxzZSBjdXJzb3IuY2xlYXJTZWxlY3Rpb24oKS5pbnNSaWdodE9mKHRoaXMucGFyZW50KTtcbiAgICAgICAgcmV0dXJuIGNtZC5jcmVhdGVMZWZ0T2YoY3Vyc29yLnNob3coKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3Vyc29yW0xdICYmICFjdXJzb3JbUl0gJiYgIWN1cnNvci5zZWxlY3Rpb25cbiAgICAgICAgICAmJiBjdXJzb3Iub3B0aW9ucy5jaGFyc1RoYXRCcmVha091dE9mU3VwU3ViLmluZGV4T2YoY2gpID4gLTEpIHtcbiAgICAgICAgY3Vyc29yLmluc1JpZ2h0T2YodGhpcy5wYXJlbnQpO1xuICAgICAgfVxuICAgICAgTWF0aEJsb2NrLnAud3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuICBfLm1vdmVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IsIHVwZG93bikge1xuICAgIGlmIChjdXJzb3Iub3B0aW9ucy5hdXRvU3Vic2NyaXB0TnVtZXJhbHMgJiYgIXRoaXMuc3VwKSB7XG4gICAgICBjdXJzb3IuaW5zRGlyT2YoZGlyLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBzdXBlcl8ubW92ZVRvd2FyZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXy5kZWxldGVUb3dhcmRzID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICBpZiAoY3Vyc29yLm9wdGlvbnMuYXV0b1N1YnNjcmlwdE51bWVyYWxzICYmIHRoaXMuc3ViKSB7XG4gICAgICB2YXIgY21kID0gdGhpcy5zdWIuZW5kc1stZGlyXTtcbiAgICAgIGlmIChjbWQgaW5zdGFuY2VvZiBTeW1ib2wpIGNtZC5yZW1vdmUoKTtcbiAgICAgIGVsc2UgaWYgKGNtZCkgY21kLmRlbGV0ZVRvd2FyZHMoZGlyLCBjdXJzb3IuaW5zQXREaXJFbmQoLWRpciwgdGhpcy5zdWIpKTtcblxuICAgICAgLy8gVE9ETzogZmFjdG9yIG91dCBhIC5yZW1vdmVCbG9jaygpIG9yIHNvbWV0aGluZ1xuICAgICAgaWYgKHRoaXMuc3ViLmlzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLnN1Yi5kZWxldGVPdXRPZihMLCBjdXJzb3IuaW5zQXRMZWZ0RW5kKHRoaXMuc3ViKSk7XG4gICAgICAgIGlmICh0aGlzLnN1cCkgY3Vyc29yLmluc0Rpck9mKC1kaXIsIHRoaXMpO1xuICAgICAgICAvLyBOb3RlIGAtZGlyYCBiZWNhdXNlIGluIGUuZy4geF8xXjJ8IHdhbnQgYmFja3NwYWNpbmcgKGxlZnR3YXJkKVxuICAgICAgICAvLyB0byBkZWxldGUgdGhlIDEgYnV0IHRvIGVuZCB1cCByaWdodHdhcmQgb2YgeF4yOyB3aXRoIG5vbi1uZWdhdGVkXG4gICAgICAgIC8vIGBkaXJgICh0cnkgaXQpLCB0aGUgY3Vyc29yIGFwcGVhcnMgdG8gaGF2ZSBnb25lIFwidGhyb3VnaFwiIHRoZSBeMi5cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBzdXBlcl8uZGVsZXRlVG93YXJkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbGF0ZXgocHJlZml4LCBibG9jaykge1xuICAgICAgdmFyIGwgPSBibG9jayAmJiBibG9jay5sYXRleCgpO1xuICAgICAgcmV0dXJuIGJsb2NrID8gcHJlZml4ICsgKGwubGVuZ3RoID09PSAxID8gbCA6ICd7JyArIChsIHx8ICcgJykgKyAnfScpIDogJyc7XG4gICAgfVxuICAgIHJldHVybiBsYXRleCgnXycsIHRoaXMuc3ViKSArIGxhdGV4KCdeJywgdGhpcy5zdXApO1xuICB9O1xuICBfLmFkZEJsb2NrID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICBpZiAodGhpcy5zdXBzdWIgPT09ICdzdWInKSB7XG4gICAgICB0aGlzLnN1cCA9IHRoaXMudXBJbnRvID0gdGhpcy5zdWIudXBPdXRPZiA9IGJsb2NrO1xuICAgICAgYmxvY2suYWRvcHQodGhpcywgdGhpcy5zdWIsIDApLmRvd25PdXRPZiA9IHRoaXMuc3ViO1xuICAgICAgYmxvY2sualEgPSAkKCc8c3BhbiBjbGFzcz1cIm1xLXN1cFwiLz4nKS5hcHBlbmQoYmxvY2sualEuY2hpbGRyZW4oKSlcbiAgICAgICAgLmF0dHIobXFCbG9ja0lkLCBibG9jay5pZCkucHJlcGVuZFRvKHRoaXMualEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc3ViID0gdGhpcy5kb3duSW50byA9IHRoaXMuc3VwLmRvd25PdXRPZiA9IGJsb2NrO1xuICAgICAgYmxvY2suYWRvcHQodGhpcywgMCwgdGhpcy5zdXApLnVwT3V0T2YgPSB0aGlzLnN1cDtcbiAgICAgIGJsb2NrLmpRID0gJCgnPHNwYW4gY2xhc3M9XCJtcS1zdWJcIj48L3NwYW4+JykuYXBwZW5kKGJsb2NrLmpRLmNoaWxkcmVuKCkpXG4gICAgICAgIC5hdHRyKG1xQmxvY2tJZCwgYmxvY2suaWQpLmFwcGVuZFRvKHRoaXMualEucmVtb3ZlQ2xhc3MoJ21xLXN1cC1vbmx5JykpO1xuICAgICAgdGhpcy5qUS5hcHBlbmQoJzxzcGFuIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MFwiPiYjODIwMzs8L3NwYW4+Jyk7XG4gICAgfVxuICAgIC8vIGxpa2UgJ3N1YiBzdXAnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihzdXBzdWIpIHsgLi4uIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSArPSAxKSAoZnVuY3Rpb24oY21kLCBzdXBzdWIsIG9wcG9zaXRlU3Vwc3ViLCB1cGRvd24pIHtcbiAgICAgIGNtZFtzdXBzdWJdLmRlbGV0ZU91dE9mID0gZnVuY3Rpb24oZGlyLCBjdXJzb3IpIHtcbiAgICAgICAgY3Vyc29yLmluc0Rpck9mKCh0aGlzW2Rpcl0gPyAtZGlyIDogZGlyKSwgdGhpcy5wYXJlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kc1tkaXJdO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4oKS5kaXNvd24oKVxuICAgICAgICAgICAgLndpdGhEaXJBZG9wdChkaXIsIGN1cnNvci5wYXJlbnQsIGN1cnNvcltkaXJdLCBjdXJzb3JbLWRpcl0pXG4gICAgICAgICAgICAualEuaW5zRGlyT2YoLWRpciwgY3Vyc29yLmpRKTtcbiAgICAgICAgICBjdXJzb3JbLWRpcl0gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY21kLnN1cHN1YiA9IG9wcG9zaXRlU3Vwc3ViO1xuICAgICAgICBkZWxldGUgY21kW3N1cHN1Yl07XG4gICAgICAgIGRlbGV0ZSBjbWRbdXBkb3duKydJbnRvJ107XG4gICAgICAgIGNtZFtvcHBvc2l0ZVN1cHN1Yl1bdXBkb3duKydPdXRPZiddID0gaW5zTGVmdE9mTWVVbmxlc3NBdEVuZDtcbiAgICAgICAgZGVsZXRlIGNtZFtvcHBvc2l0ZVN1cHN1Yl0uZGVsZXRlT3V0T2Y7XG4gICAgICAgIGlmIChzdXBzdWIgPT09ICdzdWInKSAkKGNtZC5qUS5hZGRDbGFzcygnbXEtc3VwLW9ubHknKVswXS5sYXN0Q2hpbGQpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgfTtcbiAgICB9KHRoaXMsICdzdWIgc3VwJy5zcGxpdCgnICcpW2ldLCAnc3VwIHN1Yicuc3BsaXQoJyAnKVtpXSwgJ2Rvd24gdXAnLnNwbGl0KCcgJylbaV0pKTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpbnNMZWZ0T2ZNZVVubGVzc0F0RW5kKGN1cnNvcikge1xuICAvLyBjdXJzb3IuaW5zTGVmdE9mKGNtZCksIHVubGVzcyBjdXJzb3IgYXQgdGhlIGVuZCBvZiBibG9jaywgYW5kIGV2ZXJ5XG4gIC8vIGFuY2VzdG9yIGNtZCBpcyBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGFuY2VzdG9yIGJsb2NrXG4gIHZhciBjbWQgPSB0aGlzLnBhcmVudCwgYW5jZXN0b3JDbWQgPSBjdXJzb3I7XG4gIGRvIHtcbiAgICBpZiAoYW5jZXN0b3JDbWRbUl0pIHJldHVybiBjdXJzb3IuaW5zTGVmdE9mKGNtZCk7XG4gICAgYW5jZXN0b3JDbWQgPSBhbmNlc3RvckNtZC5wYXJlbnQucGFyZW50O1xuICB9IHdoaWxlIChhbmNlc3RvckNtZCAhPT0gY21kKTtcbiAgY3Vyc29yLmluc1JpZ2h0T2YoY21kKTtcbn1cblxuTGF0ZXhDbWRzLnN1YnNjcmlwdCA9XG5MYXRleENtZHMuXyA9IFAoU3VwU3ViLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5zdXBzdWIgPSAnc3ViJztcbiAgXy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtc3Vwc3ViIG1xLW5vbi1sZWFmXCI+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zdWJcIj4mMDwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjBcIj4mIzgyMDM7PC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWyAnXycgXTtcbiAgXy5maW5hbGl6ZVRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvd25JbnRvID0gdGhpcy5zdWIgPSB0aGlzLmVuZHNbTF07XG4gICAgdGhpcy5zdWIudXBPdXRPZiA9IGluc0xlZnRPZk1lVW5sZXNzQXRFbmQ7XG4gICAgc3VwZXJfLmZpbmFsaXplVHJlZS5jYWxsKHRoaXMpO1xuICB9O1xufSk7XG5cbkxhdGV4Q21kcy5zdXBlcnNjcmlwdCA9XG5MYXRleENtZHMuc3Vwc2NyaXB0ID1cbkxhdGV4Q21kc1snXiddID0gUChTdXBTdWIsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLnN1cHN1YiA9ICdzdXAnO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1zdXBzdWIgbXEtbm9uLWxlYWYgbXEtc3VwLW9ubHlcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXN1cFwiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWyAnXicgXTtcbiAgXy5maW5hbGl6ZVRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVwSW50byA9IHRoaXMuc3VwID0gdGhpcy5lbmRzW1JdO1xuICAgIHRoaXMuc3VwLmRvd25PdXRPZiA9IGluc0xlZnRPZk1lVW5sZXNzQXRFbmQ7XG4gICAgc3VwZXJfLmZpbmFsaXplVHJlZS5jYWxsKHRoaXMpO1xuICB9O1xufSk7XG5cbnZhciBTdW1tYXRpb25Ob3RhdGlvbiA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihjaCwgaHRtbCkge1xuICAgIHZhciBodG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtbGFyZ2Utb3BlcmF0b3IgbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXRvXCI+PHNwYW4+JjE8L3NwYW4+PC9zcGFuPidcbiAgICArICAgJzxiaWc+JytodG1sKyc8L2JpZz4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLWZyb21cIj48c3Bhbj4mMDwvc3Bhbj48L3NwYW4+J1xuICAgICsgJzwvc3Bhbj4nXG4gICAgO1xuICAgIFN5bWJvbC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGNoLCBodG1sVGVtcGxhdGUpO1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoY3Vyc29yLm9wdGlvbnMuc3VtU3RhcnRzV2l0aE5FcXVhbHMpIHtcbiAgICAgIExldHRlcignbicpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgICAgRXF1YWxpdHkoKS5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICB9XG4gIH07XG4gIF8ubGF0ZXggPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaW1wbGlmeShsYXRleCkge1xuICAgICAgcmV0dXJuIGxhdGV4Lmxlbmd0aCA9PT0gMSA/IGxhdGV4IDogJ3snICsgKGxhdGV4IHx8ICcgJykgKyAnfSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN0cmxTZXEgKyAnXycgKyBzaW1wbGlmeSh0aGlzLmVuZHNbTF0ubGF0ZXgoKSkgK1xuICAgICAgJ14nICsgc2ltcGxpZnkodGhpcy5lbmRzW1JdLmxhdGV4KCkpO1xuICB9O1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nO1xuICAgIHZhciBvcHRXaGl0ZXNwYWNlID0gUGFyc2VyLm9wdFdoaXRlc3BhY2U7XG4gICAgdmFyIHN1Y2NlZWQgPSBQYXJzZXIuc3VjY2VlZDtcbiAgICB2YXIgYmxvY2sgPSBsYXRleE1hdGhQYXJzZXIuYmxvY2s7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJsb2NrcyA9IHNlbGYuYmxvY2tzID0gWyBNYXRoQmxvY2soKSwgTWF0aEJsb2NrKCkgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgYmxvY2tzW2ldLmFkb3B0KHNlbGYsIHNlbGYuZW5kc1tSXSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdFdoaXRlc3BhY2UudGhlbihzdHJpbmcoJ18nKS5vcihzdHJpbmcoJ14nKSkpLnRoZW4oZnVuY3Rpb24oc3VwT3JTdWIpIHtcbiAgICAgIHZhciBjaGlsZCA9IGJsb2Nrc1tzdXBPclN1YiA9PT0gJ18nID8gMCA6IDFdO1xuICAgICAgcmV0dXJuIGJsb2NrLnRoZW4oZnVuY3Rpb24oYmxvY2spIHtcbiAgICAgICAgYmxvY2suY2hpbGRyZW4oKS5hZG9wdChjaGlsZCwgY2hpbGQuZW5kc1tSXSwgMCk7XG4gICAgICAgIHJldHVybiBzdWNjZWVkKHNlbGYpO1xuICAgICAgfSk7XG4gICAgfSkubWFueSgpLnJlc3VsdChzZWxmKTtcbiAgfTtcbiAgXy5maW5hbGl6ZVRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvd25JbnRvID0gdGhpcy5lbmRzW0xdO1xuICAgIHRoaXMudXBJbnRvID0gdGhpcy5lbmRzW1JdO1xuICAgIHRoaXMuZW5kc1tMXS51cE91dE9mID0gdGhpcy5lbmRzW1JdO1xuICAgIHRoaXMuZW5kc1tSXS5kb3duT3V0T2YgPSB0aGlzLmVuZHNbTF07XG4gIH07XG59KTtcblxuTGF0ZXhDbWRzWydcXHUyMjExJ10gPVxuTGF0ZXhDbWRzLnN1bSA9XG5MYXRleENtZHMuc3VtbWF0aW9uID0gYmluZChTdW1tYXRpb25Ob3RhdGlvbiwnXFxcXHN1bSAnLCcmc3VtOycpO1xuXG5MYXRleENtZHNbJ1xcdTIyMGYnXSA9XG5MYXRleENtZHMucHJvZCA9XG5MYXRleENtZHMucHJvZHVjdCA9IGJpbmQoU3VtbWF0aW9uTm90YXRpb24sJ1xcXFxwcm9kICcsJyZwcm9kOycpO1xuXG5MYXRleENtZHMuY29wcm9kID1cbkxhdGV4Q21kcy5jb3Byb2R1Y3QgPSBiaW5kKFN1bW1hdGlvbk5vdGF0aW9uLCdcXFxcY29wcm9kICcsJyYjODcyMDsnKTtcblxuTGF0ZXhDbWRzWydcXHUyMjJiJ10gPVxuTGF0ZXhDbWRzWydpbnQnXSA9XG5MYXRleENtZHMuaW50ZWdyYWwgPSBQKFN1bW1hdGlvbk5vdGF0aW9uLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1pbnQgbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8YmlnPiZpbnQ7PC9iaWc+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zdXBzdWIgbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICAgJzxzcGFuIGNsYXNzPVwibXEtc3VwXCI+PHNwYW4gY2xhc3M9XCJtcS1zdXAtaW5uZXJcIj4mMTwvc3Bhbj48L3NwYW4+J1xuICAgICsgICAgICc8c3BhbiBjbGFzcz1cIm1xLXN1YlwiPiYwPC9zcGFuPidcbiAgICArICAgICAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowXCI+JiM4MjAzPC9zcGFuPidcbiAgICArICAgJzwvc3Bhbj4nXG4gICAgKyAnPC9zcGFuPidcbiAgICA7XG4gICAgU3ltYm9sLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgJ1xcXFxpbnQgJywgaHRtbFRlbXBsYXRlKTtcbiAgfTtcbiAgLy8gRklYTUU6IHJlZmFjdG9yIHJhdGhlciB0aGFuIG92ZXJyaWRpbmdcbiAgXy5jcmVhdGVMZWZ0T2YgPSBNYXRoQ29tbWFuZC5wLmNyZWF0ZUxlZnRPZjtcbn0pO1xuXG52YXIgRnJhY3Rpb24gPVxuTGF0ZXhDbWRzLmZyYWMgPVxuTGF0ZXhDbWRzLmRmcmFjID1cbkxhdGV4Q21kcy5jZnJhYyA9XG5MYXRleENtZHMuZnJhY3Rpb24gPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFxmcmFjJztcbiAgXy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtZnJhY3Rpb24gbXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW51bWVyYXRvclwiPiYwPC9zcGFuPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtZGVub21pbmF0b3JcIj4mMTwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjBcIj4mIzgyMDM7PC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWycoJywgJykvKCcsICcpJ107XG4gIF8uZmluYWxpemVUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51cEludG8gPSB0aGlzLmVuZHNbUl0udXBPdXRPZiA9IHRoaXMuZW5kc1tMXTtcbiAgICB0aGlzLmRvd25JbnRvID0gdGhpcy5lbmRzW0xdLmRvd25PdXRPZiA9IHRoaXMuZW5kc1tSXTtcbiAgfTtcbn0pO1xuXG52YXIgTGl2ZUZyYWN0aW9uID1cbkxhdGV4Q21kcy5vdmVyID1cbkNoYXJDbWRzWycvJ10gPSBQKEZyYWN0aW9uLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jcmVhdGVMZWZ0T2YgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICBpZiAoIXRoaXMucmVwbGFjZWRGcmFnbWVudCkge1xuICAgICAgdmFyIGxlZnR3YXJkID0gY3Vyc29yW0xdO1xuICAgICAgd2hpbGUgKGxlZnR3YXJkICYmXG4gICAgICAgICEoXG4gICAgICAgICAgbGVmdHdhcmQgaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvciB8fFxuICAgICAgICAgIGxlZnR3YXJkIGluc3RhbmNlb2YgKExhdGV4Q21kcy50ZXh0IHx8IG5vb3ApIHx8XG4gICAgICAgICAgbGVmdHdhcmQgaW5zdGFuY2VvZiBTdW1tYXRpb25Ob3RhdGlvbiB8fFxuICAgICAgICAgIGxlZnR3YXJkLmN0cmxTZXEgPT09ICdcXFxcICcgfHxcbiAgICAgICAgICAvXlssOzpdJC8udGVzdChsZWZ0d2FyZC5jdHJsU2VxKVxuICAgICAgICApIC8vbG9va2JlaGluZCBmb3Igb3BlcmF0b3JcbiAgICAgICkgbGVmdHdhcmQgPSBsZWZ0d2FyZFtMXTtcblxuICAgICAgaWYgKGxlZnR3YXJkIGluc3RhbmNlb2YgU3VtbWF0aW9uTm90YXRpb24gJiYgbGVmdHdhcmRbUl0gaW5zdGFuY2VvZiBTdXBTdWIpIHtcbiAgICAgICAgbGVmdHdhcmQgPSBsZWZ0d2FyZFtSXTtcbiAgICAgICAgaWYgKGxlZnR3YXJkW1JdIGluc3RhbmNlb2YgU3VwU3ViICYmIGxlZnR3YXJkW1JdLmN0cmxTZXEgIT0gbGVmdHdhcmQuY3RybFNlcSlcbiAgICAgICAgICBsZWZ0d2FyZCA9IGxlZnR3YXJkW1JdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdHdhcmQgIT09IGN1cnNvcltMXSkge1xuICAgICAgICB0aGlzLnJlcGxhY2VzKEZyYWdtZW50KGxlZnR3YXJkW1JdIHx8IGN1cnNvci5wYXJlbnQuZW5kc1tMXSwgY3Vyc29yW0xdKSk7XG4gICAgICAgIGN1cnNvcltMXSA9IGxlZnR3YXJkO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcl8uY3JlYXRlTGVmdE9mLmNhbGwodGhpcywgY3Vyc29yKTtcbiAgfTtcbn0pO1xuXG52YXIgU3F1YXJlUm9vdCA9XG5MYXRleENtZHMuc3FydCA9XG5MYXRleENtZHNbJ1xcdTIyMWEnXSA9IFAoTWF0aENvbW1hbmQsIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmN0cmxTZXEgPSAnXFxcXHNxcnQnO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtc2NhbGVkIG1xLXNxcnQtcHJlZml4XCI+JnJhZGljOzwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmIG1xLXNxcnQtc3RlbVwiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWydzcXJ0KCcsICcpJ107XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhdGV4TWF0aFBhcnNlci5vcHRCbG9jay50aGVuKGZ1bmN0aW9uKG9wdEJsb2NrKSB7XG4gICAgICByZXR1cm4gbGF0ZXhNYXRoUGFyc2VyLmJsb2NrLm1hcChmdW5jdGlvbihibG9jaykge1xuICAgICAgICB2YXIgbnRocm9vdCA9IE50aFJvb3QoKTtcbiAgICAgICAgbnRocm9vdC5ibG9ja3MgPSBbIG9wdEJsb2NrLCBibG9jayBdO1xuICAgICAgICBvcHRCbG9jay5hZG9wdChudGhyb290LCAwLCAwKTtcbiAgICAgICAgYmxvY2suYWRvcHQobnRocm9vdCwgb3B0QmxvY2ssIDApO1xuICAgICAgICByZXR1cm4gbnRocm9vdDtcbiAgICAgIH0pO1xuICAgIH0pLm9yKHN1cGVyXy5wYXJzZXIuY2FsbCh0aGlzKSk7XG4gIH07XG4gIF8ucmVmbG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJsb2NrID0gdGhpcy5lbmRzW1JdLmpRO1xuICAgIHNjYWxlKGJsb2NrLnByZXYoKSwgMSwgYmxvY2suaW5uZXJIZWlnaHQoKS8rYmxvY2suY3NzKCdmb250U2l6ZScpLnNsaWNlKDAsLTIpIC0gLjEpO1xuICB9O1xufSk7XG5cbnZhciBWZWMgPSBMYXRleENtZHMudmVjID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdcXFxcdmVjJztcbiAgXy5odG1sVGVtcGxhdGUgPVxuICAgICAgJzxzcGFuIGNsYXNzPVwibXEtbm9uLWxlYWZcIj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXZlY3Rvci1wcmVmaXhcIj4mcmFycjs8L3NwYW4+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS12ZWN0b3Itc3RlbVwiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWyd2ZWMoJywgJyknXTtcbn0pO1xuXG52YXIgTnRoUm9vdCA9XG5MYXRleENtZHMubnRocm9vdCA9IFAoU3F1YXJlUm9vdCwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uaHRtbFRlbXBsYXRlID1cbiAgICAgICc8c3VwIGNsYXNzPVwibXEtbnRocm9vdCBtcS1ub24tbGVhZlwiPiYwPC9zdXA+J1xuICAgICsgJzxzcGFuIGNsYXNzPVwibXEtc2NhbGVkXCI+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zcXJ0LXByZWZpeCBtcS1zY2FsZWRcIj4mcmFkaWM7PC9zcGFuPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtc3FydC1zdGVtIG1xLW5vbi1sZWFmXCI+JjE8L3NwYW4+J1xuICAgICsgJzwvc3Bhbj4nXG4gIDtcbiAgXy50ZXh0VGVtcGxhdGUgPSBbJ3NxcnRbJywgJ10oJywgJyknXTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnXFxcXHNxcnRbJyt0aGlzLmVuZHNbTF0ubGF0ZXgoKSsnXXsnK3RoaXMuZW5kc1tSXS5sYXRleCgpKyd9JztcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBEZWxpbXNNaXhpbihfLCBzdXBlcl8pIHtcbiAgXy5qUWFkZCA9IGZ1bmN0aW9uKCkge1xuICAgIHN1cGVyXy5qUWFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsaW1qUXMgPSB0aGlzLmpRLmNoaWxkcmVuKCc6Zmlyc3QnKS5hZGQodGhpcy5qUS5jaGlsZHJlbignOmxhc3QnKSk7XG4gICAgdGhpcy5jb250ZW50alEgPSB0aGlzLmpRLmNoaWxkcmVuKCc6ZXEoMSknKTtcbiAgfTtcbiAgXy5yZWZsb3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jb250ZW50alEub3V0ZXJIZWlnaHQoKVxuICAgICAgICAgICAgICAgICAvIHBhcnNlRmxvYXQodGhpcy5jb250ZW50alEuY3NzKCdmb250U2l6ZScpKTtcbiAgICBzY2FsZSh0aGlzLmRlbGltalFzLCBtaW4oMSArIC4yKihoZWlnaHQgLSAxKSwgMS4yKSwgMS4yKmhlaWdodCk7XG4gIH07XG59XG5cbi8vIFJvdW5kL1NxdWFyZS9DdXJseS9BbmdsZSBCcmFja2V0cyAoYWthIFBhcmVucy9CcmFja2V0cy9CcmFjZXMpXG4vLyAgIGZpcnN0IHR5cGVkIGFzIG9uZS1zaWRlZCBicmFja2V0IHdpdGggbWF0Y2hpbmcgXCJnaG9zdFwiIGJyYWNrZXQgYXRcbi8vICAgZmFyIGVuZCBvZiBjdXJyZW50IGJsb2NrLCB1bnRpbCB5b3UgdHlwZSBhbiBvcHBvc2luZyBvbmVcbnZhciBCcmFja2V0ID0gUChQKE1hdGhDb21tYW5kLCBEZWxpbXNNaXhpbiksIGZ1bmN0aW9uKF8sIHN1cGVyXykge1xuICBfLmluaXQgPSBmdW5jdGlvbihzaWRlLCBvcGVuLCBjbG9zZSwgY3RybFNlcSwgZW5kKSB7XG4gICAgc3VwZXJfLmluaXQuY2FsbCh0aGlzLCAnXFxcXGxlZnQnK2N0cmxTZXEsIHVuZGVmaW5lZCwgW29wZW4sIGNsb3NlXSk7XG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLnNpZGVzID0ge307XG4gICAgdGhpcy5zaWRlc1tMXSA9IHsgY2g6IG9wZW4sIGN0cmxTZXE6IGN0cmxTZXEgfTtcbiAgICB0aGlzLnNpZGVzW1JdID0geyBjaDogY2xvc2UsIGN0cmxTZXE6IGVuZCB9O1xuICB9O1xuICBfLm51bUJsb2NrcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcbiAgXy5odG1sID0gZnVuY3Rpb24oKSB7IC8vIHdhaXQgdW50aWwgbm93IHNvIHRoYXQgLnNpZGUgbWF5XG4gICAgdGhpcy5odG1sVGVtcGxhdGUgPSAvLyBiZSBzZXQgYnkgY3JlYXRlTGVmdE9mIG9yIHBhcnNlclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1zY2FsZWQgbXEtcGFyZW4nKyh0aGlzLnNpZGUgPT09IFIgPyAnIG1xLWdob3N0JyA6ICcnKSsnXCI+J1xuICAgICAgKyAgICAgdGhpcy5zaWRlc1tMXS5jaFxuICAgICAgKyAgICc8L3NwYW4+J1xuICAgICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmXCI+JjA8L3NwYW4+J1xuICAgICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLXNjYWxlZCBtcS1wYXJlbicrKHRoaXMuc2lkZSA9PT0gTCA/ICcgbXEtZ2hvc3QnIDogJycpKydcIj4nXG4gICAgICArICAgICB0aGlzLnNpZGVzW1JdLmNoXG4gICAgICArICAgJzwvc3Bhbj4nXG4gICAgICArICc8L3NwYW4+J1xuICAgIDtcbiAgICByZXR1cm4gc3VwZXJfLmh0bWwuY2FsbCh0aGlzKTtcbiAgfTtcbiAgXy5sYXRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnXFxcXGxlZnQnK3RoaXMuc2lkZXNbTF0uY3RybFNlcSt0aGlzLmVuZHNbTF0ubGF0ZXgoKSsnXFxcXHJpZ2h0Jyt0aGlzLnNpZGVzW1JdLmN0cmxTZXE7XG4gIH07XG4gIF8ub3BwQnJhY2sgPSBmdW5jdGlvbihvcHRzLCBub2RlLCBleHBlY3RlZFNpZGUpIHtcbiAgICAvLyByZXR1cm4gbm9kZSBpZmYgaXQncyBhIDEtc2lkZWQgYnJhY2tldCBvZiBleHBlY3RlZCBzaWRlIChpZiBhbnksIG1heSBiZVxuICAgIC8vIHVuZGVmaW5lZCksIGFuZCBvZiBvcHBvc2l0ZSBzaWRlIGZyb20gbWUgaWYgSSdtIG5vdCBhIHBpcGVcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJyYWNrZXQgJiYgbm9kZS5zaWRlICYmIG5vZGUuc2lkZSAhPT0gLWV4cGVjdGVkU2lkZVxuICAgICAgJiYgKHRoaXMuc2lkZXNbdGhpcy5zaWRlXS5jaCA9PT0gJ3wnIHx8IG5vZGUuc2lkZSA9PT0gLXRoaXMuc2lkZSlcbiAgICAgICYmICghb3B0cy5yZXN0cmljdE1pc21hdGNoZWRCcmFja2V0c1xuICAgICAgICB8fCBPUFBfQlJBQ0tTW3RoaXMuc2lkZXNbdGhpcy5zaWRlXS5jaF0gPT09IG5vZGUuc2lkZXNbbm9kZS5zaWRlXS5jaFxuICAgICAgICB8fCB7ICcoJzogJ10nLCAnWyc6ICcpJyB9W3RoaXMuc2lkZXNbTF0uY2hdID09PSBub2RlLnNpZGVzW1JdLmNoKSAmJiBub2RlO1xuICB9O1xuICBfLmNsb3NlT3Bwb3NpbmcgPSBmdW5jdGlvbihicmFjaykge1xuICAgIGJyYWNrLnNpZGUgPSAwO1xuICAgIGJyYWNrLnNpZGVzW3RoaXMuc2lkZV0gPSB0aGlzLnNpZGVzW3RoaXMuc2lkZV07IC8vIGNvcHkgb3ZlciBteSBpbmZvIChtYXkgYmVcbiAgICBicmFjay5kZWxpbWpRcy5lcSh0aGlzLnNpZGUgPT09IEwgPyAwIDogMSkgLy8gbWlzbWF0Y2hlZCwgbGlrZSBbYSwgYikpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ21xLWdob3N0JykuaHRtbCh0aGlzLnNpZGVzW3RoaXMuc2lkZV0uY2gpO1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmICghdGhpcy5yZXBsYWNlZEZyYWdtZW50KSB7IC8vIHVubGVzcyB3cmFwcGluZyBzZWxuIGluIGJyYWNrZXRzLFxuICAgICAgICAvLyBjaGVjayBpZiBuZXh0IHRvIG9yIGluc2lkZSBhbiBvcHBvc2luZyBvbmUtc2lkZWQgYnJhY2tldFxuICAgICAgICAvLyAobXVzdCBjaGVjayBib3RoIHNpZGVzICdjb3MgSSBtaWdodCBiZSBhIHBpcGUpXG4gICAgICB2YXIgb3B0cyA9IGN1cnNvci5vcHRpb25zO1xuICAgICAgdmFyIGJyYWNrID0gdGhpcy5vcHBCcmFjayhvcHRzLCBjdXJzb3JbTF0sIEwpXG4gICAgICAgICAgICAgICAgICB8fCB0aGlzLm9wcEJyYWNrKG9wdHMsIGN1cnNvcltSXSwgUilcbiAgICAgICAgICAgICAgICAgIHx8IHRoaXMub3BwQnJhY2sob3B0cywgY3Vyc29yLnBhcmVudC5wYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoYnJhY2spIHtcbiAgICAgIHZhciBzaWRlID0gdGhpcy5zaWRlID0gLWJyYWNrLnNpZGU7IC8vIG1heSBiZSBwaXBlIHdpdGggLnNpZGUgbm90IHlldCBzZXRcbiAgICAgIHRoaXMuY2xvc2VPcHBvc2luZyhicmFjayk7XG4gICAgICBpZiAoYnJhY2sgPT09IGN1cnNvci5wYXJlbnQucGFyZW50ICYmIGN1cnNvcltzaWRlXSkgeyAvLyBtb3ZlIHRoZSBzdHVmZiBiZXR3ZWVuXG4gICAgICAgIEZyYWdtZW50KGN1cnNvcltzaWRlXSwgY3Vyc29yLnBhcmVudC5lbmRzW3NpZGVdLCAtc2lkZSkgLy8gbWUgYW5kIGdob3N0IG91dHNpZGVcbiAgICAgICAgICAuZGlzb3duKCkud2l0aERpckFkb3B0KC1zaWRlLCBicmFjay5wYXJlbnQsIGJyYWNrLCBicmFja1tzaWRlXSlcbiAgICAgICAgICAualEuaW5zRGlyT2Yoc2lkZSwgYnJhY2sualEpO1xuICAgICAgICBicmFjay5idWJibGUoJ3JlZmxvdycpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJyYWNrID0gdGhpcywgc2lkZSA9IGJyYWNrLnNpZGU7XG4gICAgICBpZiAoYnJhY2sucmVwbGFjZWRGcmFnbWVudCkgYnJhY2suc2lkZSA9IDA7IC8vIHdyYXBwaW5nIHNlbG4sIGRvbid0IGJlIG9uZS1zaWRlZFxuICAgICAgZWxzZSBpZiAoY3Vyc29yWy1zaWRlXSkgeyAvLyBlbHNld2lzZSwgYXV0by1leHBhbmQgc28gZ2hvc3QgaXMgYXQgZmFyIGVuZFxuICAgICAgICBicmFjay5yZXBsYWNlcyhGcmFnbWVudChjdXJzb3JbLXNpZGVdLCBjdXJzb3IucGFyZW50LmVuZHNbLXNpZGVdLCBzaWRlKSk7XG4gICAgICAgIGN1cnNvclstc2lkZV0gPSAwO1xuICAgICAgfVxuICAgICAgc3VwZXJfLmNyZWF0ZUxlZnRPZi5jYWxsKGJyYWNrLCBjdXJzb3IpO1xuICAgIH1cbiAgICBpZiAoc2lkZSA9PT0gTCkgY3Vyc29yLmluc0F0TGVmdEVuZChicmFjay5lbmRzW0xdKTtcbiAgICBlbHNlIGN1cnNvci5pbnNSaWdodE9mKGJyYWNrKTtcbiAgfTtcbiAgXy5wbGFjZUN1cnNvciA9IG5vb3A7XG4gIF8udW53cmFwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbmRzW0xdLmNoaWxkcmVuKCkuZGlzb3duKCkuYWRvcHQodGhpcy5wYXJlbnQsIHRoaXMsIHRoaXNbUl0pXG4gICAgICAualEuaW5zZXJ0QWZ0ZXIodGhpcy5qUSk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfTtcbiAgXy5kZWxldGVTaWRlID0gZnVuY3Rpb24oc2lkZSwgb3V0d2FyZCwgY3Vyc29yKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCBzaWIgPSB0aGlzW3NpZGVdLCBmYXJFbmQgPSBwYXJlbnQuZW5kc1tzaWRlXTtcblxuICAgIGlmIChzaWRlID09PSB0aGlzLnNpZGUpIHsgLy8gZGVsZXRpbmcgbm9uLWdob3N0IG9mIG9uZS1zaWRlZCBicmFja2V0LCB1bndyYXBcbiAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICBzaWIgPyBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYikgOiBjdXJzb3IuaW5zQXREaXJFbmQoc2lkZSwgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IGN1cnNvci5vcHRpb25zLCB3YXNTb2xpZCA9ICF0aGlzLnNpZGU7XG4gICAgdGhpcy5zaWRlID0gLXNpZGU7XG4gICAgLy8gaWYgZGVsZXRpbmcgbGlrZSwgb3V0ZXIgY2xvc2UtYnJhY2Ugb2YgWygxKzIpKzN9IHdoZXJlIGlubmVyIG9wZW4tcGFyZW5cbiAgICBpZiAodGhpcy5vcHBCcmFjayhvcHRzLCB0aGlzLmVuZHNbTF0uZW5kc1t0aGlzLnNpZGVdLCBzaWRlKSkgeyAvLyBpcyBnaG9zdCxcbiAgICAgIHRoaXMuY2xvc2VPcHBvc2luZyh0aGlzLmVuZHNbTF0uZW5kc1t0aGlzLnNpZGVdKTsgLy8gdGhlbiBiZWNvbWUgWzErMikrM1xuICAgICAgdmFyIG9yaWdFbmQgPSB0aGlzLmVuZHNbTF0uZW5kc1tzaWRlXTtcbiAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICBpZiAob3JpZ0VuZC5zaWJsaW5nQ3JlYXRlZCkgb3JpZ0VuZC5zaWJsaW5nQ3JlYXRlZChjdXJzb3Iub3B0aW9ucywgc2lkZSk7XG4gICAgICBzaWIgPyBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYikgOiBjdXJzb3IuaW5zQXREaXJFbmQoc2lkZSwgcGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGlmIGRlbGV0aW5nIGxpa2UsIGlubmVyIGNsb3NlLWJyYWNlIG9mIChbMSsyfSszKSB3aGVyZSBvdXRlclxuICAgICAgaWYgKHRoaXMub3BwQnJhY2sob3B0cywgdGhpcy5wYXJlbnQucGFyZW50LCBzaWRlKSkgeyAvLyBvcGVuLXBhcmVuIGlzXG4gICAgICAgIHRoaXMucGFyZW50LnBhcmVudC5jbG9zZU9wcG9zaW5nKHRoaXMpOyAvLyBnaG9zdCwgdGhlbiBiZWNvbWUgWzErMiszKVxuICAgICAgICB0aGlzLnBhcmVudC5wYXJlbnQudW53cmFwKCk7XG4gICAgICB9IC8vIGVsc2UgaWYgZGVsZXRpbmcgb3V0d2FyZCBmcm9tIGEgc29saWQgcGFpciwgdW53cmFwXG4gICAgICBlbHNlIGlmIChvdXR3YXJkICYmIHdhc1NvbGlkKSB7XG4gICAgICAgIHRoaXMudW53cmFwKCk7XG4gICAgICAgIHNpYiA/IGN1cnNvci5pbnNEaXJPZigtc2lkZSwgc2liKSA6IGN1cnNvci5pbnNBdERpckVuZChzaWRlLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZWxzZSBkZWxldGluZyBqdXN0IG9uZSBvZiBhIHBhaXIgb2YgYnJhY2tldHMsIGJlY29tZSBvbmUtc2lkZWRcbiAgICAgICAgdGhpcy5zaWRlc1tzaWRlXSA9IHsgY2g6IE9QUF9CUkFDS1NbdGhpcy5zaWRlc1t0aGlzLnNpZGVdLmNoXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybFNlcTogT1BQX0JSQUNLU1t0aGlzLnNpZGVzW3RoaXMuc2lkZV0uY3RybFNlcV0gfTtcbiAgICAgICAgdGhpcy5kZWxpbWpRcy5yZW1vdmVDbGFzcygnbXEtZ2hvc3QnKVxuICAgICAgICAgIC5lcShzaWRlID09PSBMID8gMCA6IDEpLmFkZENsYXNzKCdtcS1naG9zdCcpLmh0bWwodGhpcy5zaWRlc1tzaWRlXS5jaCk7XG4gICAgICB9XG4gICAgICBpZiAoc2liKSB7IC8vIGF1dG8tZXhwYW5kIHNvIGdob3N0IGlzIGF0IGZhciBlbmRcbiAgICAgICAgdmFyIG9yaWdFbmQgPSB0aGlzLmVuZHNbTF0uZW5kc1tzaWRlXTtcbiAgICAgICAgRnJhZ21lbnQoc2liLCBmYXJFbmQsIC1zaWRlKS5kaXNvd24oKVxuICAgICAgICAgIC53aXRoRGlyQWRvcHQoLXNpZGUsIHRoaXMuZW5kc1tMXSwgb3JpZ0VuZCwgMClcbiAgICAgICAgICAualEuaW5zQXREaXJFbmQoc2lkZSwgdGhpcy5lbmRzW0xdLmpRLnJlbW92ZUNsYXNzKCdtcS1lbXB0eScpKTtcbiAgICAgICAgaWYgKG9yaWdFbmQuc2libGluZ0NyZWF0ZWQpIG9yaWdFbmQuc2libGluZ0NyZWF0ZWQoY3Vyc29yLm9wdGlvbnMsIHNpZGUpO1xuICAgICAgICBjdXJzb3IuaW5zRGlyT2YoLXNpZGUsIHNpYik7XG4gICAgICB9IC8vIGRpZG4ndCBhdXRvLWV4cGFuZCwgY3Vyc29yIGdvZXMganVzdCBvdXRzaWRlIG9yIGp1c3QgaW5zaWRlIHBhcmVuc1xuICAgICAgZWxzZSAob3V0d2FyZCA/IGN1cnNvci5pbnNEaXJPZihzaWRlLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IGN1cnNvci5pbnNBdERpckVuZChzaWRlLCB0aGlzLmVuZHNbTF0pKTtcbiAgICB9XG4gIH07XG4gIF8uZGVsZXRlVG93YXJkcyA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgdGhpcy5kZWxldGVTaWRlKC1kaXIsIGZhbHNlLCBjdXJzb3IpO1xuICB9O1xuICBfLmZpbmFsaXplVHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5kc1tMXS5kZWxldGVPdXRPZiA9IGZ1bmN0aW9uKGRpciwgY3Vyc29yKSB7XG4gICAgICB0aGlzLnBhcmVudC5kZWxldGVTaWRlKGRpciwgdHJ1ZSwgY3Vyc29yKTtcbiAgICB9O1xuICAgIC8vIEZJWE1FIEhBQ0s6IGFmdGVyIGluaXRpYWwgY3JlYXRpb24vaW5zZXJ0aW9uLCBmaW5hbGl6ZVRyZWUgd291bGQgb25seSBiZVxuICAgIC8vIGNhbGxlZCBpZiB0aGUgcGFyZW4gaXMgc2VsZWN0ZWQgYW5kIHJlcGxhY2VkLCBlLmcuIGJ5IExpdmVGcmFjdGlvblxuICAgIHRoaXMuZmluYWxpemVUcmVlID0gdGhpcy5pbnRlbnRpb25hbEJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVsaW1qUXMuZXEodGhpcy5zaWRlID09PSBMID8gMSA6IDApLnJlbW92ZUNsYXNzKCdtcS1naG9zdCcpO1xuICAgICAgdGhpcy5zaWRlID0gMDtcbiAgICB9O1xuICB9O1xuICBfLnNpYmxpbmdDcmVhdGVkID0gZnVuY3Rpb24ob3B0cywgZGlyKSB7IC8vIGlmIHNvbWV0aGluZyB0eXBlZCBiZXR3ZWVuIGdob3N0IGFuZCBmYXJcbiAgICBpZiAoZGlyID09PSAtdGhpcy5zaWRlKSB0aGlzLmZpbmFsaXplVHJlZSgpOyAvLyBlbmQgb2YgaXRzIGJsb2NrLCBzb2xpZGlmeVxuICB9O1xufSk7XG5cbnZhciBPUFBfQlJBQ0tTID0ge1xuICAnKCc6ICcpJyxcbiAgJyknOiAnKCcsXG4gICdbJzogJ10nLFxuICAnXSc6ICdbJyxcbiAgJ3snOiAnfScsXG4gICd9JzogJ3snLFxuICAnXFxcXHsnOiAnXFxcXH0nLFxuICAnXFxcXH0nOiAnXFxcXHsnLFxuICAnJmxhbmc7JzogJyZyYW5nOycsXG4gICcmcmFuZzsnOiAnJmxhbmc7JyxcbiAgJ1xcXFxsYW5nbGUgJzogJ1xcXFxyYW5nbGUgJyxcbiAgJ1xcXFxyYW5nbGUgJzogJ1xcXFxsYW5nbGUgJyxcbiAgJ3wnOiAnfCdcbn07XG5cbmZ1bmN0aW9uIGJpbmRDaGFyQnJhY2tldFBhaXIob3BlbiwgY3RybFNlcSkge1xuICB2YXIgY3RybFNlcSA9IGN0cmxTZXEgfHwgb3BlbiwgY2xvc2UgPSBPUFBfQlJBQ0tTW29wZW5dLCBlbmQgPSBPUFBfQlJBQ0tTW2N0cmxTZXFdO1xuICBDaGFyQ21kc1tvcGVuXSA9IGJpbmQoQnJhY2tldCwgTCwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG4gIENoYXJDbWRzW2Nsb3NlXSA9IGJpbmQoQnJhY2tldCwgUiwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG59XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCcoJyk7XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCdbJyk7XG5iaW5kQ2hhckJyYWNrZXRQYWlyKCd7JywgJ1xcXFx7Jyk7XG5MYXRleENtZHMubGFuZ2xlID0gYmluZChCcmFja2V0LCBMLCAnJmxhbmc7JywgJyZyYW5nOycsICdcXFxcbGFuZ2xlICcsICdcXFxccmFuZ2xlICcpO1xuTGF0ZXhDbWRzLnJhbmdsZSA9IGJpbmQoQnJhY2tldCwgUiwgJyZsYW5nOycsICcmcmFuZzsnLCAnXFxcXGxhbmdsZSAnLCAnXFxcXHJhbmdsZSAnKTtcbkNoYXJDbWRzWyd8J10gPSBiaW5kKEJyYWNrZXQsIEwsICd8JywgJ3wnLCAnfCcsICd8Jyk7XG5cbkxhdGV4Q21kcy5sZWZ0ID0gUChNYXRoQ29tbWFuZCwgZnVuY3Rpb24oXykge1xuICBfLnBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdleCA9IFBhcnNlci5yZWdleDtcbiAgICB2YXIgc3RyaW5nID0gUGFyc2VyLnN0cmluZztcbiAgICB2YXIgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkO1xuICAgIHZhciBvcHRXaGl0ZXNwYWNlID0gUGFyc2VyLm9wdFdoaXRlc3BhY2U7XG5cbiAgICByZXR1cm4gb3B0V2hpdGVzcGFjZS50aGVuKHJlZ2V4KC9eKD86WyhbfF18XFxcXFxceykvKSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGN0cmxTZXEpIHsgLy8gVE9ETzogXFxsYW5nbGUsIFxccmFuZ2xlXG4gICAgICAgIHZhciBvcGVuID0gKGN0cmxTZXEuY2hhckF0KDApID09PSAnXFxcXCcgPyBjdHJsU2VxLnNsaWNlKDEpIDogY3RybFNlcSk7XG4gICAgICAgIHJldHVybiBsYXRleE1hdGhQYXJzZXIudGhlbihmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nKCdcXFxccmlnaHQnKS5za2lwKG9wdFdoaXRlc3BhY2UpXG4gICAgICAgICAgICAudGhlbihyZWdleCgvXig/OltcXF0pfF18XFxcXFxcfSkvKSkubWFwKGZ1bmN0aW9uKGVuZCkge1xuICAgICAgICAgICAgICB2YXIgY2xvc2UgPSAoZW5kLmNoYXJBdCgwKSA9PT0gJ1xcXFwnID8gZW5kLnNsaWNlKDEpIDogZW5kKTtcbiAgICAgICAgICAgICAgdmFyIGNtZCA9IEJyYWNrZXQoMCwgb3BlbiwgY2xvc2UsIGN0cmxTZXEsIGVuZCk7XG4gICAgICAgICAgICAgIGNtZC5ibG9ja3MgPSBbIGJsb2NrIF07XG4gICAgICAgICAgICAgIGJsb2NrLmFkb3B0KGNtZCwgMCwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xuXG5MYXRleENtZHMucmlnaHQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfKSB7XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhcnNlci5mYWlsKCd1bm1hdGNoZWQgXFxcXHJpZ2h0Jyk7XG4gIH07XG59KTtcblxudmFyIEJpbm9taWFsID1cbkxhdGV4Q21kcy5iaW5vbSA9XG5MYXRleENtZHMuYmlub21pYWwgPSBQKFAoTWF0aENvbW1hbmQsIERlbGltc01peGluKSwgZnVuY3Rpb24oXywgc3VwZXJfKSB7XG4gIF8uY3RybFNlcSA9ICdcXFxcYmlub20nO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1ub24tbGVhZlwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtcGFyZW4gbXEtc2NhbGVkXCI+KDwvc3Bhbj4nXG4gICAgKyAgICc8c3BhbiBjbGFzcz1cIm1xLW5vbi1sZWFmXCI+J1xuICAgICsgICAgICc8c3BhbiBjbGFzcz1cIm1xLWFycmF5IG1xLW5vbi1sZWFmXCI+J1xuICAgICsgICAgICAgJzxzcGFuPiYwPC9zcGFuPidcbiAgICArICAgICAgICc8c3Bhbj4mMTwvc3Bhbj4nXG4gICAgKyAgICAgJzwvc3Bhbj4nXG4gICAgKyAgICc8L3NwYW4+J1xuICAgICsgICAnPHNwYW4gY2xhc3M9XCJtcS1wYXJlbiBtcS1zY2FsZWRcIj4pPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8udGV4dFRlbXBsYXRlID0gWydjaG9vc2UoJywnLCcsJyknXTtcbn0pO1xuXG52YXIgQ2hvb3NlID1cbkxhdGV4Q21kcy5jaG9vc2UgPSBQKEJpbm9taWFsLCBmdW5jdGlvbihfKSB7XG4gIF8uY3JlYXRlTGVmdE9mID0gTGl2ZUZyYWN0aW9uLnByb3RvdHlwZS5jcmVhdGVMZWZ0T2Y7XG59KTtcblxuTGF0ZXhDbWRzLmVkaXRhYmxlID0gLy8gYmFja2NvbXBhdCB3aXRoIGJlZm9yZSBjZmQzNjIwIG9uICMyMzNcbkxhdGV4Q21kcy5NYXRoUXVpbGxNYXRoRmllbGQgPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFxNYXRoUXVpbGxNYXRoRmllbGQnO1xuICBfLmh0bWxUZW1wbGF0ZSA9XG4gICAgICAnPHNwYW4gY2xhc3M9XCJtcS1lZGl0YWJsZS1maWVsZFwiPidcbiAgICArICAgJzxzcGFuIGNsYXNzPVwibXEtcm9vdC1ibG9ja1wiPiYwPC9zcGFuPidcbiAgICArICc8L3NwYW4+J1xuICA7XG4gIF8ucGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgc3RyaW5nID0gUGFyc2VyLnN0cmluZywgcmVnZXggPSBQYXJzZXIucmVnZXgsIHN1Y2NlZWQgPSBQYXJzZXIuc3VjY2VlZDtcbiAgICByZXR1cm4gc3RyaW5nKCdbJykudGhlbihyZWdleCgvXlthLXpdW2EtejAtOV0qL2kpKS5za2lwKHN0cmluZygnXScpKVxuICAgICAgLm1hcChmdW5jdGlvbihuYW1lKSB7IHNlbGYubmFtZSA9IG5hbWU7IH0pLm9yKHN1Y2NlZWQoKSlcbiAgICAgIC50aGVuKHN1cGVyXy5wYXJzZXIuY2FsbChzZWxmKSk7XG4gIH07XG4gIF8uZmluYWxpemVUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0cmxyID0gQ29udHJvbGxlcih0aGlzLmVuZHNbTF0sIHRoaXMualEsIE9wdGlvbnMoKSk7XG4gICAgY3RybHIuS0lORF9PRl9NUSA9ICdNYXRoRmllbGQnO1xuICAgIGN0cmxyLmVkaXRhYmxlID0gdHJ1ZTtcbiAgICBjdHJsci5jcmVhdGVUZXh0YXJlYSgpO1xuICAgIGN0cmxyLmVkaXRhYmxlc1RleHRhcmVhRXZlbnRzKCk7XG4gICAgY3RybHIuY3Vyc29yLmluc0F0UmlnaHRFbmQoY3RybHIucm9vdCk7XG4gICAgUm9vdEJsb2NrTWl4aW4oY3RybHIucm9vdCk7XG4gIH07XG4gIF8ucmVnaXN0ZXJJbm5lckZpZWxkID0gZnVuY3Rpb24oaW5uZXJGaWVsZHMsIE1hdGhGaWVsZCkge1xuICAgIGlubmVyRmllbGRzLnB1c2goaW5uZXJGaWVsZHNbdGhpcy5uYW1lXSA9IE1hdGhGaWVsZCh0aGlzLmVuZHNbTF0uY29udHJvbGxlcikpO1xuICB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZW5kc1tMXS5sYXRleCgpOyB9O1xuICBfLnRleHQgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5lbmRzW0xdLnRleHQoKTsgfTtcbn0pO1xuXG4vLyBFbWJlZCBhcmJpdHJhcnkgdGhpbmdzXG4vLyBQcm9iYWJseSB0aGUgY2xvc2VzdCBET00gYW5hbG9ndWUgd291bGQgYmUgYW4gaWZyYW1lP1xuLy8gRnJvbSBNYXRoUXVpbGwncyBwZXJzcGVjdGl2ZSwgaXQncyBhIFN5bWJvbCwgaXQgY2FuIGJlXG4vLyBhbnl3aGVyZSBhbmQgdGhlIGN1cnNvciBjYW4gZ28gYXJvdW5kIGl0IGJ1dCBuZXZlciBpbiBpdC5cbi8vIENyZWF0ZSBieSBjYWxsaW5nIHB1YmxpYyBBUEkgbWV0aG9kIC5kcm9wRW1iZWRkZWQoKSxcbi8vIG9yIGJ5IGNhbGxpbmcgdGhlIGdsb2JhbCBwdWJsaWMgQVBJIG1ldGhvZCAucmVnaXN0ZXJFbWJlZCgpXG4vLyBhbmQgcmVuZGVyaW5nIExhVGVYIGxpa2UgXFxlbWJlZHtyZWdpc3RlcmVkTmFtZX0gKHNlZSB0ZXN0KS5cbnZhciBFbWJlZCA9IExhdGV4Q21kcy5lbWJlZCA9IFAoU3ltYm9sLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIG5vb3AgKCkgeyByZXR1cm4gXCJcIjsgfVxuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dCB8fCBub29wO1xuICAgIHRoaXMuaHRtbFRlbXBsYXRlID0gb3B0aW9ucy5odG1sU3RyaW5nIHx8IFwiXCI7XG4gICAgdGhpcy5sYXRleCA9IG9wdGlvbnMubGF0ZXggfHwgbm9vcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgXy5wYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzdHJpbmcgPSBQYXJzZXIuc3RyaW5nLCByZWdleCA9IFBhcnNlci5yZWdleCwgc3VjY2VlZCA9IFBhcnNlci5zdWNjZWVkO1xuICAgIHJldHVybiBzdHJpbmcoJ3snKS50aGVuKHJlZ2V4KC9eW2Etel1bYS16MC05XSovaSkpLnNraXAoc3RyaW5nKCd9JykpXG4gICAgICAudGhlbihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIC8vIHRoZSBjaGFycyBhbGxvd2VkIGluIHRoZSBvcHRpb25hbCBkYXRhIGJsb2NrIGFyZSBhcmJpdHJhcnkgb3RoZXIgdGhhblxuICAgICAgICAvLyBleGNsdWRpbmcgY3VybHkgYnJhY2VzIGFuZCBzcXVhcmUgYnJhY2tldHMgKHdoaWNoJ2QgYmUgdG9vIGNvbmZ1c2luZylcbiAgICAgICAgcmV0dXJuIHN0cmluZygnWycpLnRoZW4ocmVnZXgoL15bLVxcd1xcc10qLykpLnNraXAoc3RyaW5nKCddJykpXG4gICAgICAgICAgLm9yKHN1Y2NlZWQoKSkubWFwKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNldE9wdGlvbnMoRU1CRURTW25hbWVdKGRhdGEpKTtcbiAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgICB9KVxuICAgIDtcbiAgfTtcbn0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIElucHV0IGJveCB0byB0eXBlIGJhY2tzbGFzaCBjb21tYW5kc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIExhdGV4Q29tbWFuZElucHV0ID1cbkNoYXJDbWRzWydcXFxcJ10gPSBQKE1hdGhDb21tYW5kLCBmdW5jdGlvbihfLCBzdXBlcl8pIHtcbiAgXy5jdHJsU2VxID0gJ1xcXFwnO1xuICBfLnJlcGxhY2VzID0gZnVuY3Rpb24ocmVwbGFjZWRGcmFnbWVudCkge1xuICAgIHRoaXMuX3JlcGxhY2VkRnJhZ21lbnQgPSByZXBsYWNlZEZyYWdtZW50LmRpc293bigpO1xuICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gIH07XG4gIF8uaHRtbFRlbXBsYXRlID0gJzxzcGFuIGNsYXNzPVwibXEtbGF0ZXgtY29tbWFuZC1pbnB1dCBtcS1ub24tbGVhZlwiPlxcXFw8c3Bhbj4mMDwvc3Bhbj48L3NwYW4+JztcbiAgXy50ZXh0VGVtcGxhdGUgPSBbJ1xcXFwnXTtcbiAgXy5jcmVhdGVCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICBzdXBlcl8uY3JlYXRlQmxvY2tzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbmRzW0xdLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhcmVudC5qUS5hZGRDbGFzcygnbXEtaGFzQ3Vyc29yJyk7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpXG4gICAgICAgIHRoaXMucGFyZW50LmpRLnJlbW92ZUNsYXNzKCdtcS1lbXB0eScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMuZW5kc1tMXS5ibHVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhcmVudC5qUS5yZW1vdmVDbGFzcygnbXEtaGFzQ3Vyc29yJyk7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpXG4gICAgICAgIHRoaXMucGFyZW50LmpRLmFkZENsYXNzKCdtcS1lbXB0eScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMuZW5kc1tMXS53cml0ZSA9IGZ1bmN0aW9uKGN1cnNvciwgY2gpIHtcbiAgICAgIGN1cnNvci5zaG93KCkuZGVsZXRlU2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChjaC5tYXRjaCgvW2Etel0vaSkpIFZhbmlsbGFTeW1ib2woY2gpLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50LnJlbmRlckNvbW1hbmQoY3Vyc29yKTtcbiAgICAgICAgaWYgKGNoICE9PSAnXFxcXCcgfHwgIXRoaXMuaXNFbXB0eSgpKSB0aGlzLnBhcmVudC5wYXJlbnQud3JpdGUoY3Vyc29yLCBjaCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmVuZHNbTF0ua2V5c3Ryb2tlID0gZnVuY3Rpb24oa2V5LCBlLCBjdHJscikge1xuICAgICAgaWYgKGtleSA9PT0gJ1RhYicgfHwga2V5ID09PSAnRW50ZXInIHx8IGtleSA9PT0gJ1NwYWNlYmFyJykge1xuICAgICAgICB0aGlzLnBhcmVudC5yZW5kZXJDb21tYW5kKGN0cmxyLmN1cnNvcik7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyXy5rZXlzdHJva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuICBfLmNyZWF0ZUxlZnRPZiA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIHN1cGVyXy5jcmVhdGVMZWZ0T2YuY2FsbCh0aGlzLCBjdXJzb3IpO1xuXG4gICAgaWYgKHRoaXMuX3JlcGxhY2VkRnJhZ21lbnQpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMualFbMF07XG4gICAgICB0aGlzLmpRID1cbiAgICAgICAgdGhpcy5fcmVwbGFjZWRGcmFnbWVudC5qUS5hZGRDbGFzcygnbXEtYmx1cicpLmJpbmQoXG4gICAgICAgICAgJ21vdXNlZG93biBtb3VzZW1vdmUnLCAvL0ZJWE1FOiBpcyBtb25rZXktcGF0Y2hpbmcgdGhlIG1vdXNlZG93biBhbmQgbW91c2Vtb3ZlIGhhbmRsZXJzIHRoZSByaWdodCB3YXkgdG8gZG8gdGhpcz9cbiAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAkKGUudGFyZ2V0ID0gZWwpLnRyaWdnZXIoZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICApLmluc2VydEJlZm9yZSh0aGlzLmpRKS5hZGQodGhpcy5qUSk7XG4gICAgfVxuICB9O1xuICBfLmxhdGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHRoaXMuZW5kc1tMXS5sYXRleCgpICsgJyAnO1xuICB9O1xuICBfLnJlbmRlckNvbW1hbmQgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICB0aGlzLmpRID0gdGhpcy5qUS5sYXN0KCk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICBpZiAodGhpc1tSXSkge1xuICAgICAgY3Vyc29yLmluc0xlZnRPZih0aGlzW1JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yLmluc0F0UmlnaHRFbmQodGhpcy5wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBsYXRleCA9IHRoaXMuZW5kc1tMXS5sYXRleCgpO1xuICAgIGlmICghbGF0ZXgpIGxhdGV4ID0gJyAnO1xuICAgIHZhciBjbWQgPSBMYXRleENtZHNbbGF0ZXhdO1xuICAgIGlmIChjbWQpIHtcbiAgICAgIGNtZCA9IGNtZChsYXRleCk7XG4gICAgICBpZiAodGhpcy5fcmVwbGFjZWRGcmFnbWVudCkgY21kLnJlcGxhY2VzKHRoaXMuX3JlcGxhY2VkRnJhZ21lbnQpO1xuICAgICAgY21kLmNyZWF0ZUxlZnRPZihjdXJzb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNtZCA9IFRleHRCbG9jaygpO1xuICAgICAgY21kLnJlcGxhY2VzKGxhdGV4KTtcbiAgICAgIGNtZC5jcmVhdGVMZWZ0T2YoY3Vyc29yKTtcbiAgICAgIGN1cnNvci5pbnNSaWdodE9mKGNtZCk7XG4gICAgICBpZiAodGhpcy5fcmVwbGFjZWRGcmFnbWVudClcbiAgICAgICAgdGhpcy5fcmVwbGFjZWRGcmFnbWVudC5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG59KTtcblxudmFyIE1RMSA9IGdldEludGVyZmFjZSgxKTtcbmZvciAodmFyIGtleSBpbiBNUTEpIChmdW5jdGlvbihrZXksIHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE1hdGhRdWlsbFtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbnNpc3RPbkludGVyVmVyKCk7XG4gICAgICByZXR1cm4gdmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBNYXRoUXVpbGxba2V5XS5wcm90b3R5cGUgPSB2YWwucHJvdG90eXBlO1xuICB9XG4gIGVsc2UgTWF0aFF1aWxsW2tleV0gPSB2YWw7XG59KGtleSwgTVExW2tleV0pKTtcblxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"72baf6dc\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT83NDIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLENBQXdQO0FBQzlRLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBMEQ7QUFDNUUsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNzJiYWY2ZGNcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL0FwcC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, "\\n#app {\\n  font-family: \'Avenir\', Helvetica, Arial, sans-serif;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n", "", {"version":3,"sources":["E:/mygithub/math-keyboard/src/src/App.vue"],"names":[],"mappings":";AAuCA;EACA,oDAAA;EACA,oCAAA;EACA,mCAAA;CACA","file":"App.vue","sourcesContent":["<template>\\n  <div id=\\"app\\">\\n\x3c!--    <div v-on:click=\\"show = !show\\">--\x3e\\n    <div style=\\"display: none\\">\\n      <math-render :value.sync=\\"value\\" :imgshow=\'!show\'></math-render>\\n      <code @click=\\"a\\">latex: {{value}}</code>\\n    </div>\\n    <math-keyboard\\n        :show.sync=\\"show\\"\\n        v-bind:keypanel=\'1\'\\n        :value.sync=\\"value\\"\\n        :output.sync=\\"output\\"\\n    ></math-keyboard>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  data(){\\n    return{\\n      show:true,\\n      value:\'\',\\n      output:\'\'\\n    }\\n  },\\n  methods:{\\n    a(){\\n      this.value = \'2^6\'\\n    }\\n  },\\n  watch:{\\n    ctrl(nval,oval){\\n      console.log(\'ctrl\'+nval)\\n    }\\n  }\\n}\\n<\/script>\\n\\n<style>\\n#app {\\n  font-family: \'Avenir\', Helvetica, Arial, sans-serif;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n</style>\\n"],"sourceRoot":""}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT8wNWNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQTRDO0FBQy9FOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyxXQUFXLHdEQUF3RCx3Q0FBd0MsdUNBQXVDLEdBQUcsVUFBVSw0RkFBNEYsTUFBTSxXQUFXLFdBQVcsV0FBVyx1UUFBdVEsT0FBTyw2T0FBNk8sV0FBVyxhQUFhLDJEQUEyRCxLQUFLLGNBQWMsVUFBVSxpQ0FBaUMsS0FBSyxZQUFZLHNCQUFzQix1Q0FBdUMsS0FBSyxHQUFHLDhCQUE4Qix3REFBd0Qsd0NBQXdDLHVDQUF1QyxHQUFHLCtCQUErQjs7QUFFbHVDIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuI2FwcCB7XFxuICBmb250LWZhbWlseTogJ0F2ZW5pcicsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJFOi9teWdpdGh1Yi9tYXRoLWtleWJvYXJkL3NyYy9zcmMvQXBwLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBdUNBO0VBQ0Esb0RBQUE7RUFDQSxvQ0FBQTtFQUNBLG1DQUFBO0NBQ0FcIixcImZpbGVcIjpcIkFwcC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBpZD1cXFwiYXBwXFxcIj5cXG48IS0tICAgIDxkaXYgdi1vbjpjbGljaz1cXFwic2hvdyA9ICFzaG93XFxcIj4tLT5cXG4gICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZVxcXCI+XFxuICAgICAgPG1hdGgtcmVuZGVyIDp2YWx1ZS5zeW5jPVxcXCJ2YWx1ZVxcXCIgOmltZ3Nob3c9JyFzaG93Jz48L21hdGgtcmVuZGVyPlxcbiAgICAgIDxjb2RlIEBjbGljaz1cXFwiYVxcXCI+bGF0ZXg6IHt7dmFsdWV9fTwvY29kZT5cXG4gICAgPC9kaXY+XFxuICAgIDxtYXRoLWtleWJvYXJkXFxuICAgICAgICA6c2hvdy5zeW5jPVxcXCJzaG93XFxcIlxcbiAgICAgICAgdi1iaW5kOmtleXBhbmVsPScxJ1xcbiAgICAgICAgOnZhbHVlLnN5bmM9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgOm91dHB1dC5zeW5jPVxcXCJvdXRwdXRcXFwiXFxuICAgID48L21hdGgta2V5Ym9hcmQ+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgZGF0YSgpe1xcbiAgICByZXR1cm57XFxuICAgICAgc2hvdzp0cnVlLFxcbiAgICAgIHZhbHVlOicnLFxcbiAgICAgIG91dHB1dDonJ1xcbiAgICB9XFxuICB9LFxcbiAgbWV0aG9kczp7XFxuICAgIGEoKXtcXG4gICAgICB0aGlzLnZhbHVlID0gJzJeNidcXG4gICAgfVxcbiAgfSxcXG4gIHdhdGNoOntcXG4gICAgY3RybChudmFsLG92YWwpe1xcbiAgICAgIGNvbnNvbGUubG9nKCdjdHJsJytudmFsKVxcbiAgICB9XFxuICB9XFxufVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4jYXBwIHtcXG4gIGZvbnQtZmFtaWx5OiAnQXZlbmlyJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"97fe3112\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL21hdGhxdWlsbC5jc3M/NzYyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxDQUE2QztBQUNuRSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21hdGhxdWlsbC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI5N2ZlMzExMlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21hdGhxdWlsbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21hdGhxdWlsbC5jc3NcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval('var escape = __webpack_require__(10);\nexports = module.exports = __webpack_require__(0)(false);\n// imports\n\n\n// module\nexports.push([module.i, "/*\\n * MathQuill v0.10.1               http://mathquill.com\\n * by Han, Jeanine, and Mary  maintainers@mathquill.com\\n *\\n * This Source Code Form is subject to the terms of the\\n * Mozilla Public License, v. 2.0. If a copy of the MPL\\n * was not distributed with this file, You can obtain\\n * one at http://mozilla.org/MPL/2.0/.\\n */\\n@font-face {\\n  font-family: Symbola;\\n  src: url(" + escape(__webpack_require__(11)) + ");\\n  src: local(\\"Symbola Regular\\"), local(\\"Symbola\\"), url(" + escape(__webpack_require__(12)) + ") format(\\"woff2\\"), url(" + escape(__webpack_require__(13)) + ") format(\\"woff\\"), url(" + escape(__webpack_require__(14)) + ") format(\\"truetype\\"), url(" + escape(__webpack_require__(15)) + ") format(\\"opentype\\"), url(" + escape(__webpack_require__(16)) + "#Symbola) format(\\"svg\\");\\n}\\n.mq-editable-field {\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-editable-field .mq-cursor {\\n  border-left: 1px solid black;\\n  margin-left: -1px;\\n  position: relative;\\n  z-index: 1;\\n  padding: 0;\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-editable-field .mq-cursor.mq-blink {\\n  visibility: hidden;\\n}\\n.mq-editable-field,\\n.mq-math-mode .mq-editable-field {\\n  border: 1px solid gray;\\n}\\n.mq-editable-field.mq-focused,\\n.mq-math-mode .mq-editable-field.mq-focused {\\n  -webkit-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\\n  -moz-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\\n  box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\\n  border-color: #709AC0;\\n  border-radius: 1px;\\n}\\n.mq-math-mode .mq-editable-field {\\n  margin: 1px;\\n}\\n.mq-editable-field .mq-latex-command-input {\\n  color: inherit;\\n  font-family: \\"Courier New\\", monospace;\\n  border: 1px solid gray;\\n  padding-right: 1px;\\n  margin-right: 1px;\\n  margin-left: 2px;\\n}\\n.mq-editable-field .mq-latex-command-input.mq-empty {\\n  background: transparent;\\n}\\n.mq-editable-field .mq-latex-command-input.mq-hasCursor {\\n  border-color: ActiveBorder;\\n}\\n.mq-editable-field.mq-empty:after,\\n.mq-editable-field.mq-text-mode:after,\\n.mq-math-mode .mq-empty:after {\\n  visibility: hidden;\\n  content: \'c\';\\n}\\n.mq-editable-field .mq-cursor:only-child:after,\\n.mq-editable-field .mq-textarea + .mq-cursor:last-child:after {\\n  visibility: hidden;\\n  content: \'c\';\\n}\\n.mq-editable-field .mq-text-mode .mq-cursor:only-child:after {\\n  content: \'\';\\n}\\n.mq-editable-field.mq-text-mode {\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n.mq-root-block,\\n.mq-math-mode .mq-root-block {\\n  display: -moz-inline-box;\\n  display: inline-block;\\n  width: 100%;\\n  padding: 2px;\\n  -webkit-box-sizing: border-box;\\n  -moz-box-sizing: border-box;\\n  box-sizing: border-box;\\n  white-space: nowrap;\\n  overflow: hidden;\\n  vertical-align: middle;\\n}\\n.mq-math-mode {\\n  font-variant: normal;\\n  font-weight: normal;\\n  font-style: normal;\\n  font-size: 115%;\\n  line-height: 1;\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-math-mode .mq-non-leaf,\\n.mq-math-mode .mq-scaled {\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-math-mode var,\\n.mq-math-mode .mq-text-mode,\\n.mq-math-mode .mq-nonSymbola {\\n  font-family: \\"Times New Roman\\", Symbola, serif;\\n  line-height: .9;\\n}\\n.mq-math-mode * {\\n  font-size: inherit;\\n  line-height: inherit;\\n  margin: 0;\\n  padding: 0;\\n  border-color: black;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  user-select: none;\\n  box-sizing: border-box;\\n}\\n.mq-math-mode .mq-empty {\\n  background: #ccc;\\n}\\n.mq-math-mode .mq-empty.mq-root-block {\\n  background: transparent;\\n}\\n.mq-math-mode.mq-empty {\\n  background: transparent;\\n}\\n.mq-math-mode .mq-text-mode {\\n  display: inline-block;\\n}\\n.mq-math-mode .mq-text-mode.mq-hasCursor {\\n  box-shadow: inset darkgray 0 .1em .2em;\\n  padding: 0 .1em;\\n  margin: 0 -0.1em;\\n  min-width: 1ex;\\n}\\n.mq-math-mode .mq-font {\\n  font: 1em \\"Times New Roman\\", Symbola, serif;\\n}\\n.mq-math-mode .mq-font * {\\n  font-family: inherit;\\n  font-style: inherit;\\n}\\n.mq-math-mode b,\\n.mq-math-mode b.mq-font {\\n  font-weight: bolder;\\n}\\n.mq-math-mode var,\\n.mq-math-mode i,\\n.mq-math-mode i.mq-font {\\n  font-style: italic;\\n}\\n.mq-math-mode var.mq-f {\\n  margin-right: 0.2em;\\n  margin-left: 0.1em;\\n}\\n.mq-math-mode .mq-roman var.mq-f {\\n  margin: 0;\\n}\\n.mq-math-mode big {\\n  font-size: 200%;\\n}\\n.mq-math-mode .mq-int > big {\\n  display: inline-block;\\n  -webkit-transform: scaleX(0.7);\\n  -moz-transform: scaleX(0.7);\\n  -ms-transform: scaleX(0.7);\\n  -o-transform: scaleX(0.7);\\n  transform: scaleX(0.7);\\n  vertical-align: -0.16em;\\n}\\n.mq-math-mode .mq-int > .mq-supsub {\\n  font-size: 80%;\\n  vertical-align: -1.1em;\\n  padding-right: .2em;\\n}\\n.mq-math-mode .mq-int > .mq-supsub > .mq-sup > .mq-sup-inner {\\n  vertical-align: 1.3em;\\n}\\n.mq-math-mode .mq-int > .mq-supsub > .mq-sub {\\n  margin-left: -0.35em;\\n}\\n.mq-math-mode .mq-roman {\\n  font-style: normal;\\n}\\n.mq-math-mode .mq-sans-serif {\\n  font-family: sans-serif, Symbola, serif;\\n}\\n.mq-math-mode .mq-monospace {\\n  font-family: monospace, Symbola, serif;\\n}\\n.mq-math-mode .mq-overline {\\n  border-top: 1px solid black;\\n  margin-top: 1px;\\n}\\n.mq-math-mode .mq-underline {\\n  border-bottom: 1px solid black;\\n  margin-bottom: 1px;\\n}\\n.mq-math-mode .mq-binary-operator {\\n  padding: 0 0.2em;\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-math-mode .mq-supsub {\\n  text-align: left;\\n  font-size: 90%;\\n  vertical-align: -0.5em;\\n}\\n.mq-math-mode .mq-supsub.mq-sup-only {\\n  vertical-align: .5em;\\n}\\n.mq-math-mode .mq-supsub.mq-sup-only .mq-sup {\\n  display: inline-block;\\n  vertical-align: text-bottom;\\n}\\n.mq-math-mode .mq-supsub .mq-sup {\\n  display: block;\\n}\\n.mq-math-mode .mq-supsub .mq-sub {\\n  display: block;\\n  float: left;\\n}\\n.mq-math-mode .mq-supsub .mq-binary-operator {\\n  padding: 0 .1em;\\n}\\n.mq-math-mode .mq-supsub .mq-fraction {\\n  font-size: 70%;\\n}\\n.mq-math-mode sup.mq-nthroot {\\n  font-size: 80%;\\n  vertical-align: 0.8em;\\n  margin-right: -0.6em;\\n  margin-left: .2em;\\n  min-width: .5em;\\n}\\n.mq-math-mode .mq-paren {\\n  padding: 0 .1em;\\n  vertical-align: top;\\n  -webkit-transform-origin: center .06em;\\n  -moz-transform-origin: center .06em;\\n  -ms-transform-origin: center .06em;\\n  -o-transform-origin: center .06em;\\n  transform-origin: center .06em;\\n}\\n.mq-math-mode .mq-paren.mq-ghost {\\n  color: silver;\\n}\\n.mq-math-mode .mq-paren + span {\\n  margin-top: .1em;\\n  margin-bottom: .1em;\\n}\\n.mq-math-mode .mq-array {\\n  vertical-align: middle;\\n  text-align: center;\\n}\\n.mq-math-mode .mq-array > span {\\n  display: block;\\n}\\n.mq-math-mode .mq-operator-name {\\n  font-family: Symbola, \\"Times New Roman\\", serif;\\n  line-height: .9;\\n  font-style: normal;\\n}\\n.mq-math-mode var.mq-operator-name.mq-first {\\n  padding-left: .2em;\\n}\\n.mq-math-mode var.mq-operator-name.mq-last,\\n.mq-math-mode .mq-supsub.mq-after-operator-name {\\n  padding-right: .2em;\\n}\\n.mq-math-mode .mq-fraction {\\n  font-size: 90%;\\n  text-align: center;\\n  vertical-align: -0.4em;\\n  padding: 0 .2em;\\n}\\n.mq-math-mode .mq-fraction,\\n.mq-math-mode .mq-large-operator,\\n.mq-math-mode x:-moz-any-link {\\n  display: -moz-groupbox;\\n}\\n.mq-math-mode .mq-fraction,\\n.mq-math-mode .mq-large-operator,\\n.mq-math-mode x:-moz-any-link,\\n.mq-math-mode x:default {\\n  display: inline-block;\\n}\\n.mq-math-mode .mq-numerator,\\n.mq-math-mode .mq-denominator {\\n  display: block;\\n}\\n.mq-math-mode .mq-numerator {\\n  padding: 0 0.1em;\\n}\\n.mq-math-mode .mq-denominator {\\n  border-top: 1px solid;\\n  float: right;\\n  width: 100%;\\n  padding: 0.1em;\\n}\\n.mq-math-mode .mq-sqrt-prefix {\\n  padding-top: 0;\\n  position: relative;\\n  top: 0.1em;\\n  vertical-align: top;\\n  -webkit-transform-origin: top;\\n  -moz-transform-origin: top;\\n  -ms-transform-origin: top;\\n  -o-transform-origin: top;\\n  transform-origin: top;\\n}\\n.mq-math-mode .mq-sqrt-stem {\\n  border-top: 1px solid;\\n  margin-top: 1px;\\n  padding-left: .15em;\\n  padding-right: .2em;\\n  margin-right: .1em;\\n  padding-top: 1px;\\n}\\n.mq-math-mode .mq-vector-prefix {\\n  display: block;\\n  text-align: center;\\n  line-height: .25em;\\n  margin-bottom: -0.1em;\\n  font-size: 0.75em;\\n}\\n.mq-math-mode .mq-vector-stem {\\n  display: block;\\n}\\n.mq-math-mode .mq-large-operator {\\n  vertical-align: -0.2em;\\n  padding: .2em;\\n  text-align: center;\\n}\\n.mq-math-mode .mq-large-operator .mq-from,\\n.mq-math-mode .mq-large-operator big,\\n.mq-math-mode .mq-large-operator .mq-to {\\n  display: block;\\n}\\n.mq-math-mode .mq-large-operator .mq-from,\\n.mq-math-mode .mq-large-operator .mq-to {\\n  font-size: 80%;\\n}\\n.mq-math-mode .mq-large-operator .mq-from {\\n  float: right;\\n  /* take out of normal flow to manipulate baseline */\\n  width: 100%;\\n}\\n.mq-math-mode,\\n.mq-math-mode .mq-editable-field {\\n  cursor: text;\\n  font-family: Symbola, \\"Times New Roman\\", serif;\\n}\\n.mq-math-mode .mq-overarrow {\\n  border-top: 1px solid black;\\n  margin-top: 1px;\\n  padding-top: 0.2em;\\n}\\n.mq-math-mode .mq-overarrow:before {\\n  display: block;\\n  position: relative;\\n  top: -0.34em;\\n  font-size: 0.5em;\\n  line-height: 0em;\\n  content: \'\\\\27A4\';\\n  text-align: right;\\n}\\n.mq-math-mode .mq-overarrow.mq-arrow-left:before {\\n  -moz-transform: scaleX(-1);\\n  -o-transform: scaleX(-1);\\n  -webkit-transform: scaleX(-1);\\n  transform: scaleX(-1);\\n  filter: FlipH;\\n  -ms-filter: \\"FlipH\\";\\n}\\n.mq-math-mode .mq-selection,\\n.mq-editable-field .mq-selection,\\n.mq-math-mode .mq-selection .mq-non-leaf,\\n.mq-editable-field .mq-selection .mq-non-leaf,\\n.mq-math-mode .mq-selection .mq-scaled,\\n.mq-editable-field .mq-selection .mq-scaled {\\n  background: #B4D5FE !important;\\n  background: Highlight !important;\\n  color: HighlightText;\\n  border-color: HighlightText;\\n}\\n.mq-math-mode .mq-selection .mq-matrixed,\\n.mq-editable-field .mq-selection .mq-matrixed {\\n  background: #39F !important;\\n}\\n.mq-math-mode .mq-selection .mq-matrixed-container,\\n.mq-editable-field .mq-selection .mq-matrixed-container {\\n  filter: progid:DXImageTransform.Microsoft.Chroma(color=\'#3399FF\') !important;\\n}\\n.mq-math-mode .mq-selection.mq-blur,\\n.mq-editable-field .mq-selection.mq-blur,\\n.mq-math-mode .mq-selection.mq-blur .mq-non-leaf,\\n.mq-editable-field .mq-selection.mq-blur .mq-non-leaf,\\n.mq-math-mode .mq-selection.mq-blur .mq-scaled,\\n.mq-editable-field .mq-selection.mq-blur .mq-scaled,\\n.mq-math-mode .mq-selection.mq-blur .mq-matrixed,\\n.mq-editable-field .mq-selection.mq-blur .mq-matrixed {\\n  background: #D4D4D4 !important;\\n  color: black;\\n  border-color: black;\\n}\\n.mq-math-mode .mq-selection.mq-blur .mq-matrixed-container,\\n.mq-editable-field .mq-selection.mq-blur .mq-matrixed-container {\\n  filter: progid:DXImageTransform.Microsoft.Chroma(color=\'#D4D4D4\') !important;\\n}\\n.mq-editable-field .mq-textarea,\\n.mq-math-mode .mq-textarea {\\n  position: relative;\\n  -webkit-user-select: text;\\n  -moz-user-select: text;\\n  user-select: text;\\n}\\n.mq-editable-field .mq-textarea *,\\n.mq-math-mode .mq-textarea *,\\n.mq-editable-field .mq-selectable,\\n.mq-math-mode .mq-selectable {\\n  -webkit-user-select: text;\\n  -moz-user-select: text;\\n  user-select: text;\\n  position: absolute;\\n  clip: rect(1em 1em 1em 1em);\\n  -webkit-transform: scale(0);\\n  -moz-transform: scale(0);\\n  -ms-transform: scale(0);\\n  -o-transform: scale(0);\\n  transform: scale(0);\\n  resize: none;\\n  width: 1px;\\n  height: 1px;\\n}\\n.mq-math-mode .mq-matrixed {\\n  background: white;\\n  display: -moz-inline-box;\\n  display: inline-block;\\n}\\n.mq-math-mode .mq-matrixed-container {\\n  filter: progid:DXImageTransform.Microsoft.Chroma(color=\'white\');\\n  margin-top: -0.1em;\\n}\\n", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL21hdGhxdWlsbC5jc3M/NGJhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsRUFBb0M7QUFDekQsMkJBQTJCLG1CQUFPLENBQUMsQ0FBa0M7QUFDckU7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLCtWQUErVix5QkFBeUIsd0JBQXdCLG1CQUFPLENBQUMsRUFBb0IsUUFBUSx3RUFBd0UsbUJBQU8sQ0FBQyxFQUFzQiwwQ0FBMEMsbUJBQU8sQ0FBQyxFQUFxQix5Q0FBeUMsbUJBQU8sQ0FBQyxFQUFvQiw2Q0FBNkMsbUJBQU8sQ0FBQyxFQUFvQiw2Q0FBNkMsbUJBQU8sQ0FBQyxFQUFvQixnQ0FBZ0MsR0FBRyxzQkFBc0IsNkJBQTZCLDBCQUEwQixHQUFHLGlDQUFpQyxpQ0FBaUMsc0JBQXNCLHVCQUF1QixlQUFlLGVBQWUsNkJBQTZCLDBCQUEwQixHQUFHLDBDQUEwQyx1QkFBdUIsR0FBRyx5REFBeUQsMkJBQTJCLEdBQUcsK0VBQStFLCtEQUErRCw0REFBNEQsdURBQXVELDBCQUEwQix1QkFBdUIsR0FBRyxvQ0FBb0MsZ0JBQWdCLEdBQUcsOENBQThDLG1CQUFtQiw0Q0FBNEMsMkJBQTJCLHVCQUF1QixzQkFBc0IscUJBQXFCLEdBQUcsdURBQXVELDRCQUE0QixHQUFHLDJEQUEyRCwrQkFBK0IsR0FBRyw2R0FBNkcsdUJBQXVCLGlCQUFpQixHQUFHLGtIQUFrSCx1QkFBdUIsaUJBQWlCLEdBQUcsZ0VBQWdFLGdCQUFnQixHQUFHLG1DQUFtQyxxQkFBcUIsdUJBQXVCLEdBQUcsaURBQWlELDZCQUE2QiwwQkFBMEIsZ0JBQWdCLGlCQUFpQixtQ0FBbUMsZ0NBQWdDLDJCQUEyQix3QkFBd0IscUJBQXFCLDJCQUEyQixHQUFHLGlCQUFpQix5QkFBeUIsd0JBQXdCLHVCQUF1QixvQkFBb0IsbUJBQW1CLDZCQUE2QiwwQkFBMEIsR0FBRyx5REFBeUQsNkJB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QXdCLEdBQUcsZ0lBQWdJLGlGQUFpRixHQUFHLGdFQUFnRSx1QkFBdUIsOEJBQThCLDJCQUEyQixzQkFBc0IsR0FBRyx1SUFBdUksOEJBQThCLDJCQUEyQixzQkFBc0IsdUJBQXVCLGdDQUFnQyxnQ0FBZ0MsNkJBQTZCLDRCQUE0QiwyQkFBMkIsd0JBQXdCLGlCQUFpQixlQUFlLGdCQUFnQixHQUFHLDhCQUE4QixzQkFBc0IsNkJBQTZCLDBCQUEwQixHQUFHLHdDQUF3QyxvRUFBb0UsdUJBQXVCLEdBQUc7O0FBRTE3VyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGVzY2FwZSA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qXFxuICogTWF0aFF1aWxsIHYwLjEwLjEgICAgICAgICAgICAgICBodHRwOi8vbWF0aHF1aWxsLmNvbVxcbiAqIGJ5IEhhbiwgSmVhbmluZSwgYW5kIE1hcnkgIG1haW50YWluZXJzQG1hdGhxdWlsbC5jb21cXG4gKlxcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGVcXG4gKiBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMXFxuICogd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW5cXG4gKiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxcbiAqL1xcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFN5bWJvbGE7XFxuICBzcmM6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250L1N5bWJvbGEuZW90XCIpKSArIFwiKTtcXG4gIHNyYzogbG9jYWwoXFxcIlN5bWJvbGEgUmVndWxhclxcXCIpLCBsb2NhbChcXFwiU3ltYm9sYVxcXCIpLCB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vZm9udC9TeW1ib2xhLndvZmYyXCIpKSArIFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250L1N5bWJvbGEud29mZlwiKSkgKyBcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250L1N5bWJvbGEudHRmXCIpKSArIFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250L1N5bWJvbGEub3RmXCIpKSArIFwiKSBmb3JtYXQoXFxcIm9wZW50eXBlXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9mb250L1N5bWJvbGEuc3ZnXCIpKSArIFwiI1N5bWJvbGEpIGZvcm1hdChcXFwic3ZnXFxcIik7XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCB7XFxuICBkaXNwbGF5OiAtbW96LWlubGluZS1ib3g7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtY3Vyc29yIHtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgYmxhY2s7XFxuICBtYXJnaW4tbGVmdDogLTFweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDE7XFxuICBwYWRkaW5nOiAwO1xcbiAgZGlzcGxheTogLW1vei1pbmxpbmUtYm94O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ubXEtZWRpdGFibGUtZmllbGQgLm1xLWN1cnNvci5tcS1ibGluayB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCxcXG4ubXEtbWF0aC1tb2RlIC5tcS1lZGl0YWJsZS1maWVsZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCBncmF5O1xcbn1cXG4ubXEtZWRpdGFibGUtZmllbGQubXEtZm9jdXNlZCxcXG4ubXEtbWF0aC1tb2RlIC5tcS1lZGl0YWJsZS1maWVsZC5tcS1mb2N1c2VkIHtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogIzhiZCAwIDAgMXB4IDJweCwgaW5zZXQgIzZhZSAwIDAgMnB4IDA7XFxuICAtbW96LWJveC1zaGFkb3c6ICM4YmQgMCAwIDFweCAycHgsIGluc2V0ICM2YWUgMCAwIDJweCAwO1xcbiAgYm94LXNoYWRvdzogIzhiZCAwIDAgMXB4IDJweCwgaW5zZXQgIzZhZSAwIDAgMnB4IDA7XFxuICBib3JkZXItY29sb3I6ICM3MDlBQzA7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLWVkaXRhYmxlLWZpZWxkIHtcXG4gIG1hcmdpbjogMXB4O1xcbn1cXG4ubXEtZWRpdGFibGUtZmllbGQgLm1xLWxhdGV4LWNvbW1hbmQtaW5wdXQge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LWZhbWlseTogXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgZ3JheTtcXG4gIHBhZGRpbmctcmlnaHQ6IDFweDtcXG4gIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgbWFyZ2luLWxlZnQ6IDJweDtcXG59XFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1sYXRleC1jb21tYW5kLWlucHV0Lm1xLWVtcHR5IHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG4ubXEtZWRpdGFibGUtZmllbGQgLm1xLWxhdGV4LWNvbW1hbmQtaW5wdXQubXEtaGFzQ3Vyc29yIHtcXG4gIGJvcmRlci1jb2xvcjogQWN0aXZlQm9yZGVyO1xcbn1cXG4ubXEtZWRpdGFibGUtZmllbGQubXEtZW1wdHk6YWZ0ZXIsXFxuLm1xLWVkaXRhYmxlLWZpZWxkLm1xLXRleHQtbW9kZTphZnRlcixcXG4ubXEtbWF0aC1tb2RlIC5tcS1lbXB0eTphZnRlciB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBjb250ZW50OiAnYyc7XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtY3Vyc29yOm9ubHktY2hpbGQ6YWZ0ZXIsXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS10ZXh0YXJlYSArIC5tcS1jdXJzb3I6bGFzdC1jaGlsZDphZnRlciB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBjb250ZW50OiAnYyc7XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtdGV4dC1tb2RlIC5tcS1jdXJzb3I6b25seS1jaGlsZDphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG59XFxuLm1xLWVkaXRhYmxlLWZpZWxkLm1xLXRleHQtbW9kZSB7XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbn1cXG4ubXEtcm9vdC1ibG9jayxcXG4ubXEtbWF0aC1tb2RlIC5tcS1yb290LWJsb2NrIHtcXG4gIGRpc3BsYXk6IC1tb3otaW5saW5lLWJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMnB4O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLm1xLW1hdGgtbW9kZSB7XFxuICBmb250LXZhcmlhbnQ6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LXNpemU6IDExNSU7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGRpc3BsYXk6IC1tb3otaW5saW5lLWJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtbm9uLWxlYWYsXFxuLm1xLW1hdGgtbW9kZSAubXEtc2NhbGVkIHtcXG4gIGRpc3BsYXk6IC1tb3otaW5saW5lLWJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLm1xLW1hdGgtbW9kZSB2YXIsXFxuLm1xLW1hdGgtbW9kZSAubXEtdGV4dC1tb2RlLFxcbi5tcS1tYXRoLW1vZGUgLm1xLW5vblN5bWJvbGEge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiLCBTeW1ib2xhLCBzZXJpZjtcXG4gIGxpbmUtaGVpZ2h0OiAuOTtcXG59XFxuLm1xLW1hdGgtbW9kZSAqIHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlci1jb2xvcjogYmxhY2s7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtZW1wdHkge1xcbiAgYmFja2dyb3VuZDogI2NjYztcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtZW1wdHkubXEtcm9vdC1ibG9jayB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuLm1xLW1hdGgtbW9kZS5tcS1lbXB0eSB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtdGV4dC1tb2RlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtdGV4dC1tb2RlLm1xLWhhc0N1cnNvciB7XFxuICBib3gtc2hhZG93OiBpbnNldCBkYXJrZ3JheSAwIC4xZW0gLjJlbTtcXG4gIHBhZGRpbmc6IDAgLjFlbTtcXG4gIG1hcmdpbjogMCAtMC4xZW07XFxuICBtaW4td2lkdGg6IDFleDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtZm9udCB7XFxuICBmb250OiAxZW0gXFxcIlRpbWVzIE5ldyBSb21hblxcXCIsIFN5bWJvbGEsIHNlcmlmO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1mb250ICoge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBmb250LXN0eWxlOiBpbmhlcml0O1xcbn1cXG4ubXEtbWF0aC1tb2RlIGIsXFxuLm1xLW1hdGgtbW9kZSBiLm1xLWZvbnQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuLm1xLW1hdGgtbW9kZSB2YXIsXFxuLm1xLW1hdGgtbW9kZSBpLFxcbi5tcS1tYXRoLW1vZGUgaS5tcS1mb250IHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuLm1xLW1hdGgtbW9kZSB2YXIubXEtZiB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuMmVtO1xcbiAgbWFyZ2luLWxlZnQ6IDAuMWVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1yb21hbiB2YXIubXEtZiB7XFxuICBtYXJnaW46IDA7XFxufVxcbi5tcS1tYXRoLW1vZGUgYmlnIHtcXG4gIGZvbnQtc2l6ZTogMjAwJTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtaW50ID4gYmlnIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZVgoMC43KTtcXG4gIC1tb3otdHJhbnNmb3JtOiBzY2FsZVgoMC43KTtcXG4gIC1tcy10cmFuc2Zvcm06IHNjYWxlWCgwLjcpO1xcbiAgLW8tdHJhbnNmb3JtOiBzY2FsZVgoMC43KTtcXG4gIHRyYW5zZm9ybTogc2NhbGVYKDAuNyk7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuMTZlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtaW50ID4gLm1xLXN1cHN1YiB7XFxuICBmb250LXNpemU6IDgwJTtcXG4gIHZlcnRpY2FsLWFsaWduOiAtMS4xZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAuMmVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1pbnQgPiAubXEtc3Vwc3ViID4gLm1xLXN1cCA+IC5tcS1zdXAtaW5uZXIge1xcbiAgdmVydGljYWwtYWxpZ246IDEuM2VtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1pbnQgPiAubXEtc3Vwc3ViID4gLm1xLXN1YiB7XFxuICBtYXJnaW4tbGVmdDogLTAuMzVlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtcm9tYW4ge1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zYW5zLXNlcmlmIHtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmLCBTeW1ib2xhLCBzZXJpZjtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtbW9ub3NwYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIFN5bWJvbGEsIHNlcmlmO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1vdmVybGluZSB7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XFxuICBtYXJnaW4tdG9wOiAxcHg7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXVuZGVybGluZSB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgYmxhY2s7XFxuICBtYXJnaW4tYm90dG9tOiAxcHg7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLWJpbmFyeS1vcGVyYXRvciB7XFxuICBwYWRkaW5nOiAwIDAuMmVtO1xcbiAgZGlzcGxheTogLW1vei1pbmxpbmUtYm94O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zdXBzdWIge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGZvbnQtc2l6ZTogOTAlO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjVlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtc3Vwc3ViLm1xLXN1cC1vbmx5IHtcXG4gIHZlcnRpY2FsLWFsaWduOiAuNWVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zdXBzdWIubXEtc3VwLW9ubHkgLm1xLXN1cCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC1ib3R0b207XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXN1cHN1YiAubXEtc3VwIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zdXBzdWIgLm1xLXN1YiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zdXBzdWIgLm1xLWJpbmFyeS1vcGVyYXRvciB7XFxuICBwYWRkaW5nOiAwIC4xZW07XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXN1cHN1YiAubXEtZnJhY3Rpb24ge1xcbiAgZm9udC1zaXplOiA3MCU7XFxufVxcbi5tcS1tYXRoLW1vZGUgc3VwLm1xLW50aHJvb3Qge1xcbiAgZm9udC1zaXplOiA4MCU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogMC44ZW07XFxuICBtYXJnaW4tcmlnaHQ6IC0wLjZlbTtcXG4gIG1hcmdpbi1sZWZ0OiAuMmVtO1xcbiAgbWluLXdpZHRoOiAuNWVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1wYXJlbiB7XFxuICBwYWRkaW5nOiAwIC4xZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgLjA2ZW07XFxuICAtbW96LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciAuMDZlbTtcXG4gIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgLjA2ZW07XFxuICAtby10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgLjA2ZW07XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgLjA2ZW07XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXBhcmVuLm1xLWdob3N0IHtcXG4gIGNvbG9yOiBzaWx2ZXI7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXBhcmVuICsgc3BhbiB7XFxuICBtYXJnaW4tdG9wOiAuMWVtO1xcbiAgbWFyZ2luLWJvdHRvbTogLjFlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtYXJyYXkge1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtYXJyYXkgPiBzcGFuIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1vcGVyYXRvci1uYW1lIHtcXG4gIGZvbnQtZmFtaWx5OiBTeW1ib2xhLCBcXFwiVGltZXMgTmV3IFJvbWFuXFxcIiwgc2VyaWY7XFxuICBsaW5lLWhlaWdodDogLjk7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcbi5tcS1tYXRoLW1vZGUgdmFyLm1xLW9wZXJhdG9yLW5hbWUubXEtZmlyc3Qge1xcbiAgcGFkZGluZy1sZWZ0OiAuMmVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIHZhci5tcS1vcGVyYXRvci1uYW1lLm1xLWxhc3QsXFxuLm1xLW1hdGgtbW9kZSAubXEtc3Vwc3ViLm1xLWFmdGVyLW9wZXJhdG9yLW5hbWUge1xcbiAgcGFkZGluZy1yaWdodDogLjJlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtZnJhY3Rpb24ge1xcbiAgZm9udC1zaXplOiA5MCU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLTAuNGVtO1xcbiAgcGFkZGluZzogMCAuMmVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1mcmFjdGlvbixcXG4ubXEtbWF0aC1tb2RlIC5tcS1sYXJnZS1vcGVyYXRvcixcXG4ubXEtbWF0aC1tb2RlIHg6LW1vei1hbnktbGluayB7XFxuICBkaXNwbGF5OiAtbW96LWdyb3VwYm94O1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1mcmFjdGlvbixcXG4ubXEtbWF0aC1tb2RlIC5tcS1sYXJnZS1vcGVyYXRvcixcXG4ubXEtbWF0aC1tb2RlIHg6LW1vei1hbnktbGluayxcXG4ubXEtbWF0aC1tb2RlIHg6ZGVmYXVsdCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLW51bWVyYXRvcixcXG4ubXEtbWF0aC1tb2RlIC5tcS1kZW5vbWluYXRvciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtbnVtZXJhdG9yIHtcXG4gIHBhZGRpbmc6IDAgMC4xZW07XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLWRlbm9taW5hdG9yIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZDtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMC4xZW07XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXNxcnQtcHJlZml4IHtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAwLjFlbTtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHRvcDtcXG4gIC1tb3otdHJhbnNmb3JtLW9yaWdpbjogdG9wO1xcbiAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IHRvcDtcXG4gIC1vLXRyYW5zZm9ybS1vcmlnaW46IHRvcDtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IHRvcDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtc3FydC1zdGVtIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZDtcXG4gIG1hcmdpbi10b3A6IDFweDtcXG4gIHBhZGRpbmctbGVmdDogLjE1ZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAuMmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAuMWVtO1xcbiAgcGFkZGluZy10b3A6IDFweDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtdmVjdG9yLXByZWZpeCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAuMjVlbTtcXG4gIG1hcmdpbi1ib3R0b206IC0wLjFlbTtcXG4gIGZvbnQtc2l6ZTogMC43NWVtO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS12ZWN0b3Itc3RlbSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtbGFyZ2Utb3BlcmF0b3Ige1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjJlbTtcXG4gIHBhZGRpbmc6IC4yZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLWxhcmdlLW9wZXJhdG9yIC5tcS1mcm9tLFxcbi5tcS1tYXRoLW1vZGUgLm1xLWxhcmdlLW9wZXJhdG9yIGJpZyxcXG4ubXEtbWF0aC1tb2RlIC5tcS1sYXJnZS1vcGVyYXRvciAubXEtdG8ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLWxhcmdlLW9wZXJhdG9yIC5tcS1mcm9tLFxcbi5tcS1tYXRoLW1vZGUgLm1xLWxhcmdlLW9wZXJhdG9yIC5tcS10byB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtbGFyZ2Utb3BlcmF0b3IgLm1xLWZyb20ge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgLyogdGFrZSBvdXQgb2Ygbm9ybWFsIGZsb3cgdG8gbWFuaXB1bGF0ZSBiYXNlbGluZSAqL1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5tcS1tYXRoLW1vZGUsXFxuLm1xLW1hdGgtbW9kZSAubXEtZWRpdGFibGUtZmllbGQge1xcbiAgY3Vyc29yOiB0ZXh0O1xcbiAgZm9udC1mYW1pbHk6IFN5bWJvbGEsIFxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiLCBzZXJpZjtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtb3ZlcmFycm93IHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbi10b3A6IDFweDtcXG4gIHBhZGRpbmctdG9wOiAwLjJlbTtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtb3ZlcmFycm93OmJlZm9yZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogLTAuMzRlbTtcXG4gIGZvbnQtc2l6ZTogMC41ZW07XFxuICBsaW5lLWhlaWdodDogMGVtO1xcbiAgY29udGVudDogJ1xcXFwyN0E0JztcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1vdmVyYXJyb3cubXEtYXJyb3ctbGVmdDpiZWZvcmUge1xcbiAgLW1vei10cmFuc2Zvcm06IHNjYWxlWCgtMSk7XFxuICAtby10cmFuc2Zvcm06IHNjYWxlWCgtMSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGVYKC0xKTtcXG4gIHRyYW5zZm9ybTogc2NhbGVYKC0xKTtcXG4gIGZpbHRlcjogRmxpcEg7XFxuICAtbXMtZmlsdGVyOiBcXFwiRmxpcEhcXFwiO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zZWxlY3Rpb24sXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3Rpb24sXFxuLm1xLW1hdGgtbW9kZSAubXEtc2VsZWN0aW9uIC5tcS1ub24tbGVhZixcXG4ubXEtZWRpdGFibGUtZmllbGQgLm1xLXNlbGVjdGlvbiAubXEtbm9uLWxlYWYsXFxuLm1xLW1hdGgtbW9kZSAubXEtc2VsZWN0aW9uIC5tcS1zY2FsZWQsXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3Rpb24gLm1xLXNjYWxlZCB7XFxuICBiYWNrZ3JvdW5kOiAjQjRENUZFICFpbXBvcnRhbnQ7XFxuICBiYWNrZ3JvdW5kOiBIaWdobGlnaHQgIWltcG9ydGFudDtcXG4gIGNvbG9yOiBIaWdobGlnaHRUZXh0O1xcbiAgYm9yZGVyLWNvbG9yOiBIaWdobGlnaHRUZXh0O1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1zZWxlY3Rpb24gLm1xLW1hdHJpeGVkLFxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtc2VsZWN0aW9uIC5tcS1tYXRyaXhlZCB7XFxuICBiYWNrZ3JvdW5kOiAjMzlGICFpbXBvcnRhbnQ7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXNlbGVjdGlvbiAubXEtbWF0cml4ZWQtY29udGFpbmVyLFxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtc2VsZWN0aW9uIC5tcS1tYXRyaXhlZC1jb250YWluZXIge1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQ2hyb21hKGNvbG9yPScjMzM5OUZGJykgIWltcG9ydGFudDtcXG59XFxuLm1xLW1hdGgtbW9kZSAubXEtc2VsZWN0aW9uLm1xLWJsdXIsXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3Rpb24ubXEtYmx1cixcXG4ubXEtbWF0aC1tb2RlIC5tcS1zZWxlY3Rpb24ubXEtYmx1ciAubXEtbm9uLWxlYWYsXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3Rpb24ubXEtYmx1ciAubXEtbm9uLWxlYWYsXFxuLm1xLW1hdGgtbW9kZSAubXEtc2VsZWN0aW9uLm1xLWJsdXIgLm1xLXNjYWxlZCxcXG4ubXEtZWRpdGFibGUtZmllbGQgLm1xLXNlbGVjdGlvbi5tcS1ibHVyIC5tcS1zY2FsZWQsXFxuLm1xLW1hdGgtbW9kZSAubXEtc2VsZWN0aW9uLm1xLWJsdXIgLm1xLW1hdHJpeGVkLFxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtc2VsZWN0aW9uLm1xLWJsdXIgLm1xLW1hdHJpeGVkIHtcXG4gIGJhY2tncm91bmQ6ICNENEQ0RDQgIWltcG9ydGFudDtcXG4gIGNvbG9yOiBibGFjaztcXG4gIGJvcmRlci1jb2xvcjogYmxhY2s7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLXNlbGVjdGlvbi5tcS1ibHVyIC5tcS1tYXRyaXhlZC1jb250YWluZXIsXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3Rpb24ubXEtYmx1ciAubXEtbWF0cml4ZWQtY29udGFpbmVyIHtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkNocm9tYShjb2xvcj0nI0Q0RDRENCcpICFpbXBvcnRhbnQ7XFxufVxcbi5tcS1lZGl0YWJsZS1maWVsZCAubXEtdGV4dGFyZWEsXFxuLm1xLW1hdGgtbW9kZSAubXEtdGV4dGFyZWEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IHRleHQ7XFxuICB1c2VyLXNlbGVjdDogdGV4dDtcXG59XFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS10ZXh0YXJlYSAqLFxcbi5tcS1tYXRoLW1vZGUgLm1xLXRleHRhcmVhICosXFxuLm1xLWVkaXRhYmxlLWZpZWxkIC5tcS1zZWxlY3RhYmxlLFxcbi5tcS1tYXRoLW1vZGUgLm1xLXNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IHRleHQ7XFxuICB1c2VyLXNlbGVjdDogdGV4dDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNsaXA6IHJlY3QoMWVtIDFlbSAxZW0gMWVtKTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gIC1tb3otdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gIC1tcy10cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgLW8tdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICByZXNpemU6IG5vbmU7XFxuICB3aWR0aDogMXB4O1xcbiAgaGVpZ2h0OiAxcHg7XFxufVxcbi5tcS1tYXRoLW1vZGUgLm1xLW1hdHJpeGVkIHtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgZGlzcGxheTogLW1vei1pbmxpbmUtYm94O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ubXEtbWF0aC1tb2RlIC5tcS1tYXRyaXhlZC1jb250YWluZXIge1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQ2hyb21hKGNvbG9yPSd3aGl0ZScpO1xcbiAgbWFyZ2luLXRvcDogLTAuMWVtO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,exports){eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz9iMDQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.eot?e4ae9ff7ac2476ae421fc4278e5d3806";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS5lb3Q/MTdkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL1N5bWJvbGEuZW90P2U0YWU5ZmY3YWMyNDc2YWU0MjFmYzQyNzhlNWQzODA2XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.woff2?cb8d804a242b86175fdd6cb8e11b1a35";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS53b2ZmMj81MjI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvU3ltYm9sYS53b2ZmMj9jYjhkODA0YTI0MmI4NjE3NWZkZDZjYjhlMTFiMWEzNVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.woff?b1445a46ceac48f13cec0860ab1acf5f";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS53b2ZmPzdjMDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9TeW1ib2xhLndvZmY/YjE0NDVhNDZjZWFjNDhmMTNjZWMwODYwYWIxYWNmNWZcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.ttf?52a6aac18ae26b6ecbd4f3a0d9579c9f";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS50dGY/NTMwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL1N5bWJvbGEudHRmPzUyYTZhYWMxOGFlMjZiNmVjYmQ0ZjNhMGQ5NTc5YzlmXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.otf?4621fcfd9def63c694914f7ec5add610";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS5vdGY/OTVkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL1N5bWJvbGEub3RmPzQ2MjFmY2ZkOWRlZjYzYzY5NDkxNGY3ZWM1YWRkNjEwXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/Symbola.svg?20db57ba32a046dfea3c30519898b278";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWF0aHF1aWxsL2J1aWxkL2ZvbnQvU3ltYm9sYS5zdmc/MmE4YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL1N5bWJvbGEuc3ZnPzIwZGI1N2JhMzJhMDQ2ZGZlYTNjMzA1MTk4OThiMjc4XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(18);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"6372eaaf\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2tleWJvYXJkLnZ1ZT83NzdmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQWdTO0FBQ3RULDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBNkQ7QUFDL0UsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc4ZTA5MmU0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4va2V5Ym9hcmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjYzNzJlYWFmXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzhlMDkyZTRcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9rZXlib2FyZC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc4ZTA5MmU0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4va2V5Ym9hcmQudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n")},function(module,exports,__webpack_require__){eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n*[data-v-78e092e4] {\\n  box-sizing: content-box !important;\\n}\\n#mathinput[data-v-78e092e4] {\\n  margin: 3px;\\n  background: #fff;\\n  border: 2px solid #0099FF;\\n  border-radius: 4px;\\n  width: 65%\\n}\\n.keyboard[data-v-78e092e4] {\\n  margin-top: -8px;\\n  width: auto;\\n  position: fixed;\\n  padding-bottom: 4px;\\n  left: 0;\\n  background-color: #F1F1F1;\\n  z-index: 16777271;\\n  transition: all 0.5s;\\n}\\n.keyboard-output[data-v-78e092e4] {\\n  width: calc(100% - 4px);\\n  position: relative;\\n  padding: 2px;\\n  background-color: #fff;\\n}\\n.left-right[data-v-78e092e4] {\\n  position: absolute;\\n  display: block;\\n  margin-left: calc(65% + 15px);\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n.left-right img[data-v-78e092e4] {\\n  width: 15px;\\n  height: 15px;\\n}\\n.keyboard-output > a[data-v-78e092e4] {\\n  display: block;\\n  text-decoration: none;\\n  line-height: 40px;\\n  width: 42px;\\n  text-align: center;\\n  background-color: #fff;\\n  color: #2e7bfd;\\n  font-size: 15px;\\n  position: absolute;\\n  right: 2px;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n@-webkit-keyframes van-circular-data-v-78e092e4 {\\n0% {\\n    stroke-dasharray: 1, 200;\\n    stroke-dashoffset: 0;\\n}\\n50% {\\n    stroke-dasharray: 90, 150;\\n    stroke-dashoffset: -40;\\n}\\nto {\\n    stroke-dasharray: 90, 150;\\n    stroke-dashoffset: -120;\\n}\\n}\\n@keyframes van-circular-data-v-78e092e4 {\\n0% {\\n    stroke-dasharray: 1, 200;\\n    stroke-dashoffset: 0;\\n}\\n50% {\\n    stroke-dasharray: 90, 150;\\n    stroke-dashoffset: -40;\\n}\\nto {\\n    stroke-dasharray: 90, 150;\\n    stroke-dashoffset: -120;\\n}\\n}\\n.keyboard-panel-letter[data-v-78e092e4] {\\n  width: 100vw;\\n  position: center;\\n}\\n.keyboard-bottom[data-v-78e092e4] {\\n  position: center;\\n}\\n.keyboard-bottom li[data-v-78e092e4] {\\n  background-color: #F7F7F7;\\n  margin-left: 4px;\\n  margin-top: 4px;\\n  width: calc((100vw - 28px) / 6);\\n}\\n.keyboard-bottom li[data-v-78e092e4]:nth-child(5) {\\n  width: calc((100vw - 28px) / 6 - 2px);\\n}\\n.keyboard-panel .letter-row[data-v-78e092e4] {\\n  margin-top: 5px;\\n  height: 42px;\\n  width: 100%;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(3) li[data-v-78e092e4]:first-child {\\n  width: calc((300vw - 97px) / 20);\\n  background-color: #F7F7F7;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(3) li[data-v-78e092e4]:last-child {\\n  width: calc((300vw - 97px) / 20);\\n  background-color: #F7F7F7;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(4) li[data-v-78e092e4]:first-child {\\n  width: calc((100vw - 19px) / 4);\\n  font-size: 15px;\\n  background-color: #F7F7F7;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(4) li[data-v-78e092e4]:last-child {\\n  width: calc((100vw - 19px) / 4);\\n  font-size: 15px;\\n  background-color: #F7F7F7;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(4) li[data-v-78e092e4]:nth-child(2) {\\n  width: calc((100vw - 49px) / 10);\\n  font-size: 15px;\\n  background-color: #F7F7F7;\\n}\\n.keyboard-panel-letter .letter-row:nth-child(4) li[data-v-78e092e4]:nth-child(3) {\\n  width: calc(2 * (100vw - 49px) / 5 + 15px);\\n  font-size: 15px;\\n  /* background-color: #F7F7F7 */\\n}\\n.keyboard-panel-letter ul[data-v-78e092e4] {\\n  position: relative;\\n  left: 50%;\\n  transform: translateX(-50%);\\n}\\n.keyboard-panel-default[data-v-78e092e4] {\\n  float: left;\\n  margin: 4px 4px 0 4px;\\n}\\n.keyboard-panel ul[data-v-78e092e4] {\\n  margin: 0;\\n  padding: 0;\\n  float: left;\\n}\\n.keyboard-panel ul li[data-v-78e092e4] {\\n  list-style: none;\\n  height: 42px;\\n  line-height: 42px;\\n  text-align: center;\\n  float: left;\\n  border-radius: 5px;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n  font-size: 20px;\\n  color: #0d0d0d;\\n  position: relative;\\n}\\n.letter-shade[data-v-78e092e4] {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  z-index: 1;\\n}\\n.keyboard-panel-letter ul li[data-v-78e092e4] {\\n  width: calc((100vw - 49px) / 10);\\n  margin-right: 5px;\\n  background-color: #fff;\\n}\\n.keyboard-panel-letter ul li[data-v-78e092e4]:last-child {\\n  margin-right: 0;\\n}\\n.keyboard-panel-default ul li[data-v-78e092e4] {\\n  width: calc((100vw - 29px) / 6);\\n  margin-top: 4px;\\n}\\n.keyboard-default-symbol[data-v-78e092e4] {\\n  width: calc((100vw - 16px) / 3);\\n  margin-right: 4px;\\n  float: left;\\n}\\n.keyboard-default-symbol > ul[data-v-78e092e4] {\\n  background-color: #F7F7F7;\\n  border-radius: 5px;\\n}\\n.keyboard-default-symbol ul li[data-v-78e092e4]:nth-child(2n) {\\n  margin-right: 0;\\n}\\n.keyboard-default-symbol > ul li[data-v-78e092e4]:nth-child(1) {\\n  margin-top: 0;\\n}\\n.keyboard-default-symbol > ul li[data-v-78e092e4]:nth-child(2) {\\n  margin-top: 0;\\n}\\n.keyboard-panel li img[data-v-78e092e4] {\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  max-height: 42px;\\n  position: absolute;\\n  z-index: 0;\\n  left: 50%;\\n}\\n.keyboard-default-symbol-bottom ul li[data-v-78e092e4] {\\n  background-color: #F1F1F1;\\n  font-size: 15px;\\n}\\n.keyboard-default-num[data-v-78e092e4] {\\n  width: calc((100vw - 16px) / 2);\\n  float: left;\\n  margin-right: 4px;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4] {\\n  background-color: #fff;\\n  margin-right: 4px;\\n  width: calc(((100vw - 20px) / 2 - 8px) / 3);\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(1) {\\n  margin-top: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(2) {\\n  margin-top: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(3) {\\n  margin-top: 0;\\n  margin-right: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(6) {\\n  margin-right: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(9) {\\n  margin-right: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(11) {\\n  margin-right: 0;\\n}\\n.keyboard-default-num ul li[data-v-78e092e4]:nth-child(10) {\\n  width: calc((100vw - 28px) / 3 + 3px);\\n}\\n.keyboard-default-right[data-v-78e092e4] {\\n  width: calc((100vw - 16px) / 6 - 2px);\\n  float: right;\\n  background-color: #F7F7F7;\\n  border-radius: 4px;\\n}\\n.keyboard-default-right ul li[data-v-78e092e4] {\\n  background-color: #F7F7F7;\\n}\\n.keyboard-symbol-left > ul[data-v-78e092e4] {\\n  height: 146px;\\n  overflow-y: scroll;\\n  background-color: #F7F7F7;\\n  border-radius: 5px;\\n}\\n.keyboard-panel-symbol ul li[data-v-78e092e4] {\\n  width: calc((100vw - 29px) / 6);\\n  margin-top: 10px;\\n  margin-right: 5px;\\n}\\n.keyboard-symbol-left ul li[data-v-78e092e4]:nth-child(5n) {\\n  margin-right: 0;\\n}\\n.keyboard-symbol-left .keyboard-default-symbol-bottom ul li[data-v-78e092e4]:nth-child(3) {\\n  width: calc((100vw - 9px) / 2);\\n  margin-right: 0;\\n  background-color: #fff;\\n}\\n.keyboard-func img[data-v-78e092e4] {\\n  height: 36px;\\n}\\n.keyboard-func-icon:last-child img[data-v-78e092e4] {\\n  height: 28px;\\n  margin-top: 4px;\\n}\\n\\n\", \"\", {\"version\":3,\"sources\":[\"E:/mygithub/math-keyboard/src/lib/src/lib/keyboard.vue\"],\"names\":[],\"mappings\":\";AA6bA;EACA,mCAAA;CACA;AAEA;EACA,YAAA;EACA,iBAAA;EACA,0BAAA;EACA,mBAAA;EACA,UAAA;CACA;AAEA;EACA,iBAAA;EACA,YAAA;EACA,gBAAA;EACA,oBAAA;EACA,QAAA;EACA,0BAAA;EACA,kBAAA;EACA,qBAAA;CACA;AAEA;EACA,wBAAA;EACA,mBAAA;EACA,aAAA;EACA,uBAAA;CACA;AAEA;EACA,mBAAA;EACA,eAAA;EACA,8BAAA;EACA,SAAA;EACA,4BAAA;CACA;AAEA;EACA,YAAA;EACA,aAAA;CACA;AAEA;EACA,eAAA;EACA,sBAAA;EACA,kBAAA;EACA,YAAA;EACA,mBAAA;EACA,uBAAA;EACA,eAAA;EACA,gBAAA;EACA,mBAAA;EACA,WAAA;EACA,SAAA;EACA,4BAAA;CACA;AAEA;AACA;IACA,yBAAA;IACA,qBAAA;CACA;AACA;IACA,0BAAA;IACA,uBAAA;CACA;AACA;IACA,0BAAA;IACA,wBAAA;CACA;CACA;AAEA;AACA;IACA,yBAAA;IACA,qBAAA;CACA;AACA;IACA,0BAAA;IACA,uBAAA;CACA;AACA;IACA,0BAAA;IACA,wBAAA;CACA;CACA;AAEA;EACA,aAAA;EACA,iBAAA;CACA;AAEA;EACA,iBAAA;CACA;AAGA;EACA,0BAAA;EACA,iBAAA;EACA,gBAAA;EACA,gCAAA;CACA;AAEA;EACA,sCAAA;CACA;AAEA;EACA,gBAAA;EACA,aAAA;EACA,YAAA;CACA;AAEA;EACA,iCAAA;EACA,0BAAA;CACA;AAEA;EACA,iCAAA;EACA,0BAAA;CACA;AAEA;EACA,gCAAA;EACA,gBAAA;EACA,0BAAA;CACA;AAEA;EACA,gCAAA;EACA,gBAAA;EACA,0BAAA;CACA;AAEA;EACA,iCAAA;EACA,gBAAA;EACA,0BAAA;CACA;AAEA;EACA,2CAAA;EACA,gBAAA;EACA,+BAAA;CACA;AAEA;EACA,mBAAA;EACA,UAAA;EACA,4BAAA;CACA;AAEA;EACA,YAAA;EACA,sBAAA;CACA;AAEA;EACA,UAAA;EACA,WAAA;EACA,YAAA;CACA;AAEA;EACA,iBAAA;EACA,aAAA;EACA,kBAAA;EACA,mBAAA;EACA,YAAA;EACA,mBAAA;EACA,uBAAA;EACA,0BAAA;EACA,gBAAA;EACA,eAAA;EACA,mBAAA;CACA;AAEA;EACA,YAAA;EACA,aAAA;EACA,mBAAA;EACA,WAAA;CACA;AAEA;EACA,iCAAA;EACA,kBAAA;EACA,uBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,gCAAA;EACA,gBAAA;CACA;AAEA;EACA,gCAAA;EACA,kBAAA;EACA,YAAA;CACA;AAEA;EACA,0BAAA;EACA,mBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,cAAA;CACA;AAEA;EACA,cAAA;CACA;AAEA;EACA,SAAA;EACA,iCAAA;EACA,iBAAA;EACA,mBAAA;EACA,WAAA;EACA,UAAA;CACA;AAEA;EACA,0BAAA;EACA,gBAAA;CACA;AAEA;EACA,gCAAA;EACA,YAAA;EACA,kBAAA;CACA;AAEA;EACA,uBAAA;EACA,kBAAA;EACA,4CAAA;CACA;AAEA;EACA,cAAA;CACA;AAEA;EACA,cAAA;CACA;AAEA;EACA,cAAA;EACA,gBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,sCAAA;CACA;AAEA;EACA,sCAAA;EACA,aAAA;EACA,0BAAA;EACA,mBAAA;CACA;AAEA;EACA,0BAAA;CACA;AAEA;EACA,cAAA;EACA,mBAAA;EACA,0BAAA;EACA,mBAAA;CACA;AAEA;EACA,gCAAA;EACA,iBAAA;EACA,kBAAA;CACA;AAEA;EACA,gBAAA;CACA;AAEA;EACA,+BAAA;EACA,gBAAA;EACA,uBAAA;CACA;AAEA;EACA,aAAA;CACA;AAEA;EACA,aAAA;EACA,gBAAA;CACA\",\"file\":\"keyboard.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"keyboard\\\" id=\\\"keyboard\\\">\\n    <div class=\\\"keyboard-output\\\">\\n      <span :id=\\\"mathinput\\\"\\n            @touchstart=\\\"cursorDown($event)\\\"\\n            @touchmove=\\\"cursorMove($event)\\\"\\n            @touchup=\\\"cursorUp($event)\\\">\\n      </span>\\n      <div class=\\\"left-right\\\">\\n        <img :src=\\\"img.cursor_left\\\" @click=\\\"cursorLeft($event)\\\"/>\\n        <img :src=\\\"img.cursor_right\\\" @click=\\\"cursorRight($event)\\\" style=\\\"margin-left: 20px\\\"/>\\n      </div>\\n      <a @click=\\\"keyhide()\\\" style=\\\"width: 15%\\\">确定</a>\\n    </div>\\n    <div class=\\\"keyboard-panel\\\"\\n         :style=\\\"{display:keyorwrite === 1 ? 'unset':'none'}\\\">\\n      <div class=\\\"keyboard-panel-default\\\" v-if=\\\"panel === 1\\\">\\n        <div class=\\\"keyboard-default-symbol\\\">\\n          <ul>\\n            <li v-for=\\\"item in keysym\\\" @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n        <div class=\\\"keyboard-default-num\\\">\\n          <ul>\\n            <li v-for=\\\"item in keynum\\\"\\n                @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#fff'}\\\"\\n            >{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n        <div class=\\\"keyboard-default-right\\\">\\n          <ul>\\n            <li @touchstart=\\\"backDown('Backspace')\\\" @touchend=\\\"backUp('Backspace')\\\"\\n                style=\\\"background-color: #F7F7F7;margin-top: 0px\\\"><img :src=\\\"img.back\\\"/></li>\\n            <li v-for=\\\"item in keyboardRight\\\"\\n                @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n      </div>\\n\\n      <div class=\\\"keyboard-panel-letter\\\" v-if=\\\"panel === 3\\\">\\n        <div class=\\\"letter-row\\\" v-for=\\\"items in keyabc[capsletter]\\\">\\n          <ul>\\n            <li v-for=\\\"item in items\\\"\\n                @click=\\\"(item.v !== 'shift' ? (item.v !== 'Backspace' ? insertar(item.v) : '') : caps())\\\"\\n                @touchstart=\\\"item.t = true,backDown(item.v),item.v === 'Backspace' ? item.i = img.dback : ''\\\"\\n                @touchend=\\\"item.t = false,backUp(item.v),item.v === 'Backspace' ? item.i = img.back : ''\\\"\\n                :style=\\\"item.v !== 'shift' ? item.v !== 'Backspace' ? {'background-color':item.t ? '#bababa' : '#fff'} : {'background-color':item.t ? '#fff' : '#F7F7F7'} :{'background-color':item.s ? '#fff' : '#F7F7F7'}\\\"\\n            >\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n      </div>\\n      <div class=\\\"keyboard-bottom\\\">\\n        <ul>\\n          <li @click=\\\"changepanel(panel===1?3:1)\\\" style=\\\"font-size: 14px;\\\">{{panel===1?'abc':'123'}}\\n          </li>\\n          <li v-for=\\\"item in keyBottomSym\\\"\\n              @click=\\\"item.v==='hide'?keyhide():insertar(item.v)\\\"\\n              @touchstart=\\\"item.t = true\\\"\\n              @touchend=\\\"item.t = false\\\"\\n              :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n            <div class=\\\"letter-shade\\\"></div>\\n            <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n          </li>\\n        </ul>\\n      </div>\\n    </div>\\n\\n\\n  </div>\\n</template>\\n\\n<script>\\n    import \\\"mathquill/build/mathquill\\\";\\n    import img from './img.js'\\n    import {setTimeout, clearTimeout} from 'timers';\\n\\n    export default {\\n        name: \\\"math-keyboard\\\",\\n        data() {\\n            return {\\n                img: img,\\n                mathField: null,\\n                mathview: 'mathview' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\\n                mathinput: 'mathinput',\\n                panel: this.keypanel,\\n                capsletter: 'letter',\\n                keyabc: {\\n                    'letter': [\\n                        [\\n                            {k: 'q', v: 'q', t: false},\\n                            {k: 'w', v: 'w', t: false},\\n                            {k: 'e', v: 'e', t: false},\\n                            {k: 'r', v: 'r', t: false},\\n                            {k: 't', v: 't', t: false},\\n                            {k: 'y', v: 'y', t: false},\\n                            {k: 'u', v: 'u', t: false},\\n                            {k: 'i', v: 'i', t: false},\\n                            {k: 'o', v: 'o', t: false},\\n                            {k: 'p', v: 'p', t: false},\\n                        ],\\n                        [\\n                            {k: 'a', v: 'a', t: false},\\n                            {k: 's', v: 's', t: false},\\n                            {k: 'd', v: 'd', t: false},\\n                            {k: 'f', v: 'f', t: false},\\n                            {k: 'g', v: 'g', t: false},\\n                            {k: 'h', v: 'h', t: false},\\n                            {k: 'j', v: 'j', t: false},\\n                            {k: 'k', v: 'k', t: false},\\n                            {k: 'l', v: 'l', t: false},\\n                        ],\\n                        [\\n                            {k: '', v: 'shift', i: img.shift, s: false},\\n                            {k: 'z', v: 'z', t: false},\\n                            {k: 'x', v: 'x', t: false},\\n                            {k: 'c', v: 'c', t: false},\\n                            {k: 'v', v: 'v', t: false},\\n                            {k: 'b', v: 'b', t: false},\\n                            {k: 'n', v: 'n', t: false},\\n                            {k: 'm', v: 'm', t: false},\\n                            {k: '', v: 'Backspace', i: img.back, t: false},\\n                        ]\\n                    ],\\n                    'caps': [\\n                        [\\n                            {k: 'Q', v: 'Q', t: false},\\n                            {k: 'W', v: 'W', t: false},\\n                            {k: 'E', v: 'E', t: false},\\n                            {k: 'R', v: 'R', t: false},\\n                            {k: 'T', v: 'T', t: false},\\n                            {k: 'Y', v: 'Y', t: false},\\n                            {k: 'U', v: 'U', t: false},\\n                            {k: 'I', v: 'I', t: false},\\n                            {k: 'O', v: 'O', t: false},\\n                            {k: 'P', v: 'P', t: false},\\n                        ],\\n                        [\\n                            {k: 'A', v: 'A', t: false},\\n                            {k: 'S', v: 'S', t: false},\\n                            {k: 'D', v: 'D', t: false},\\n                            {k: 'F', v: 'F', t: false},\\n                            {k: 'G', v: 'G', t: false},\\n                            {k: 'H', v: 'H', t: false},\\n                            {k: 'J', v: 'J', t: false},\\n                            {k: 'K', v: 'K', t: false},\\n                            {k: 'L', v: 'L', t: false},\\n                        ],\\n                        [\\n                            {k: '', v: 'shift', i: img.dshift, s: true},\\n                            {k: 'Z', v: 'Z', t: false},\\n                            {k: 'X', v: 'X', t: false},\\n                            {k: 'C', v: 'C', t: false},\\n                            {k: 'V', v: 'V', t: false},\\n                            {k: 'B', v: 'B', t: false},\\n                            {k: 'N', v: 'N', t: false},\\n                            {k: 'M', v: 'M', t: false},\\n                            {k: '', v: 'Backspace', i: img.back, t: false},\\n                        ]\\n                    ]\\n                },\\n                keynum: [\\n                    {k: '1', v: '1', t: false},\\n                    {k: '2', v: '2', t: false},\\n                    {k: '3', v: '3', t: false},\\n                    {k: '4', v: '4', t: false},\\n                    {k: '5', v: '5', t: false},\\n                    {k: '6', v: '6', t: false},\\n                    {k: '7', v: '7', t: false},\\n                    {k: '8', v: '8', t: false},\\n                    {k: '9', v: '9', t: false},\\n                    {k: '0', v: '0', t: false},\\n                    {k: '.', v: '.', t: false},\\n                ],\\n                keysym: [\\n                    {k: '', v: '\\\\\\\\nthroot', i: img.raiz, t: false},\\n                    {k: '', v: '\\\\\\\\sqrt', i: img.raiz2, t: false},\\n                    {k: '', v: '^', i: img.potencia, t: false},\\n                    {k: '', v: '^2', i: img.cuadrado, t: false},\\n                    {k: '', v: '|', i: img.abs, t: false},\\n                    {k: '', v: '/', i: img.fraccion, t: false},\\n                    {k: '', v: '\\\\\\\\pi', i: img._pi, t: false},\\n                    {k: '', v: '或', i: img.or, t: false},\\n                    // {k: '', v: '^3', i: img.tercera},\\n                    // {k: '(', v: '(', i: ''},\\n                    // {k: ')', v: ')', i: ''},\\n                    // {k: '[', v: '[', i: ''},\\n                    // {k: ']', v: ']', i: ''},\\n                    // {k: 'sin', v: '\\\\\\\\sin', i: ''},\\n                    // {k: 'cos', v: '\\\\\\\\cos', i: ''},\\n                    // {k: 'tan', v: '\\\\\\\\tan', i: ''},\\n                    // {k: '≈', v: '\\\\\\\\approx', i: ''},\\n                    // {k: '≠', v: '\\\\\\\\neq', i: ''},\\n                    // {k: '%', v: '%', i: ''},\\n                    // {k: '', v: '-', i: img.subtract},\\n                    // {k: '', v: '+', i: img.plus},\\n                    // {k: '×', v: '\\\\\\\\times', i: ''},\\n                    // {k: '÷', v: '\\\\\\\\div', i: ''},\\n                    // {k: '', v: '±', i: img.union},\\n                    // {k: ',', v: ',', i: ''},\\n                    // {k: ':', v: ':', i: ''},\\n                    // {k: '°', v: '\\\\\\\\degree', i: ''},\\n                    // {k: '且', v: '且', i: ''},\\n                    // {k: '非', v: '非', i: ''},\\n                    // {k: 'x', v: 'x', i: ''},\\n                    // {k: 'y', v: 'y', i: ''},\\n                    // {k: '∑', v: '\\\\\\\\sum', i: ''},\\n                    // {k: '向量', v: '\\\\\\\\overrightarrow', i: ''},\\n                    // {k: '∠', v: '∠', i: ''},\\n                    // {k: '∵', v: '\\\\\\\\because', i: ''},\\n                    // {k: '∴', v: '\\\\\\\\therefore', i: ''},\\n                    // {k: '∈', v: '\\\\\\\\in', i: ''},\\n                    // {k: '∉', v: '\\\\\\\\notin', i: ''},\\n                    // {k: '∩', v: '\\\\\\\\intersection', i: ''},\\n                    // {k: '∪', v: '\\\\\\\\cup', i: ''},\\n                    // {k: '⊂', v: '\\\\\\\\subset', i: ''},\\n                    // {k: '⊃', v: '\\\\\\\\superset', i: ''},\\n                    // {k: '∞', v: '\\\\\\\\infty', i: ''},\\n                    // {k: 'log', v: '\\\\\\\\log', i: ''},\\n                    // {k: '←', v: '\\\\\\\\leftarrow', i: ''},\\n                    // {k: '→', v: '\\\\\\\\rightarrow', i: ''},\\n                    // {k: '⇔', v: '\\\\\\\\iff', i: ''}\\n                ],\\n                keyBottomSym: [\\n                    // {k: '', v: 'abc', i: img.abc},\\n                    {k: '', v: 'hide', i: img.hide, t: false},\\n                    {k: '', v: '<', i: img.less_than, t: false},\\n                    {k: '', v: '>', i: img.more_than, t: false},\\n                    {k: '', v: '\\\\\\\\leq', i: img.less_equals, t: false},\\n                    {k: '', v: '\\\\\\\\geq', i: img.more_equals, t: false},\\n\\n                ],\\n                keyboardRight: [\\n                    {k: '', v: '-', i: img.subtract, t: false},\\n                    {k: '', v: '+', i: img.plus, t: false},\\n                    {k: '', v: '±', i: img.union, t: false}\\n                ],\\n                latex: this.value,\\n                keyshow: this.show,\\n                keyorwrite: 1,\\n                cursorx: 0,\\n                cursory: 0,\\n                timer: null,\\n                interval: null\\n            };\\n        },\\n        props: {\\n            show: Boolean,\\n            value: String,\\n            keypanel: {\\n                type: Number,\\n                default: 1\\n            },\\n            ctrl: {\\n                type: Number,\\n                default: 0\\n            },\\n            output: String,\\n        },\\n        mounted() {\\n            var that = this;\\n            var mathFieldSpan = document.getElementById(this.mathinput);\\n\\n            var MQ = MathQuill.getInterface(2);\\n            var mathField = that.mathField = MQ.MathField(mathFieldSpan, {\\n                spaceBehavesLikeTab: true,\\n                leftRightIntoCmdGoes: 'up',\\n                restrictMismatchedBrackets: true,\\n                sumStartsWithNEquals: true,\\n                supSubsRequireOperand: true,\\n                autoSubscriptNumerals: true,\\n                autoOperatorNames: 'sin COMMA',\\n                handlers: {\\n                    edit: function (mathField) {\\n                        that.$emit('update:value', mathField.latex());\\n                        //显示光标\\n                        const controller = mathField.__controller;\\n                        controller.cursor.show();\\n                        controller.blurred = false;\\n                    }\\n                }\\n            });\\n\\n            that.mathField.latex(that.value);\\n\\n            window.onresize = function () {\\n                var content = $('#mathinput .mq-root-block');\\n                content.scrollLeft(content[0].scrollWidth)\\n            };\\n        },\\n        methods: {\\n            /**\\n             * 插入符号\\n             * @param valor\\n             */\\n            insertar(valor) {\\n                var that = this;\\n                if (valor.includes(\\\"^2\\\") || valor.includes(\\\"^3\\\")) {\\n                    that.mathField.write(valor);\\n                } else if (valor === 'Backspace') {\\n                    that.mathField.keystroke(valor);\\n                } else {\\n                    that.mathField.cmd(valor);\\n                }\\n\\n            },\\n            /**\\n             * 键盘布局切换\\n             * @param val\\n             */\\n            changepanel(val) {\\n                this.panel = val;\\n                this.$emit('update:keypanel', val);\\n                let keyboardDiv = document.getElementById('keyboard');\\n                let height = window.getComputedStyle(keyboardDiv).getPropertyValue(\\\"height\\\");\\n                console.log(height);\\n                try {\\n                    $App.keyboardHeight(height);\\n                } catch (e) {\\n                }\\n            },\\n            /**\\n             * 字母大小写切换\\n             */\\n            caps() {\\n                if (this.capsletter === 'letter') {\\n                    this.capsletter = 'caps'\\n                } else {\\n                    this.capsletter = 'letter'\\n                }\\n            },\\n            /**\\n             * 键盘隐藏\\n             * @param event\\n             */\\n            keyhide(event) {\\n                this.$emit('update:show', false);\\n                this.$emit('update:output', this.value);\\n                $App.hideKeyboard();\\n            },\\n            cursorLeft(event) {\\n                this.mathField.keystroke(\\\"Left\\\");\\n                this.cursorx = event.changedTouches[0].clientX;\\n                console.log(\\\"Left\\\")\\n            },\\n            cursorRight(event) {\\n                this.mathField.keystroke(\\\"Right\\\");\\n                this.cursorx = event.changedTouches[0].clientX;\\n                console.log(\\\"Right\\\")\\n            },\\n            cursorUp(event) {\\n                var _this = this\\n            },\\n            cursorDown(event) {\\n                var _this = this;\\n                _this.cursorx = event.changedTouches[0].clientX;\\n                _this.cursory = event.changedTouches[0].clientY;\\n            },\\n            cursorMove(event) {\\n                var x = this.cursorx - event.changedTouches[0].clientX;\\n                var y = this.cursory - event.changedTouches[0].clientY;\\n\\n                if (x > 10) {\\n                    this.mathField.keystroke(\\\"Left\\\");\\n                    this.cursorx = event.changedTouches[0].clientX;\\n                    console.log(\\\"Left\\\")\\n                }\\n\\n                if (x < -10) {\\n                    this.mathField.keystroke(\\\"Right\\\");\\n                    this.cursorx = event.changedTouches[0].clientX;\\n                    console.log(\\\"Right\\\")\\n                }\\n\\n                if (y > 10) {\\n                    this.mathField.keystroke(\\\"Up\\\");\\n                    this.cursory = event.changedTouches[0].clientY;\\n                    console.log(\\\"Up\\\")\\n                }\\n\\n                if (y < -10) {\\n                    this.mathField.keystroke(\\\"Down\\\");\\n                    this.cursory = event.changedTouches[0].clientY;\\n                    console.log(\\\"Down\\\")\\n                }\\n\\n            },\\n\\n            backDown(val) {\\n                var _this = this;\\n                if (val === 'Backspace') {\\n                    _this.timer = setTimeout(function () {\\n                        _this.interval = setInterval(function () {\\n                            _this.mathField.keystroke('Backspace')\\n                        }, 100)\\n                    }, 500)\\n                }\\n\\n            },\\n            backUp(val) {\\n                if (val === 'Backspace') {\\n                    this.mathField.keystroke('Backspace');\\n                    clearTimeout(this.timer);\\n                    clearInterval(this.interval)\\n                }\\n            }\\n        },\\n        watch: {\\n            value(nval, oval) {\\n                if (!this.show) {\\n                    this.mathField.latex(this.value)\\n                }\\n\\n                var content = $('#mathinput .mq-root-block');\\n                content.scrollLeft(content[0].scrollWidth)\\n            },\\n            ctrl(nval, oval) {\\n                this.$emit('update:ctrl', nval)\\n                // this.keyhide()\\n                // console.log('ctrl'+nval)\\n            },\\n        }\\n    };\\n<\/script>\\n\\n\x3c!-- Add \\\"scoped\\\" attribute to limit CSS to this component only --\x3e\\n<style scoped>\\n  * {\\n    box-sizing: content-box !important;\\n  }\\n\\n  #mathinput {\\n    margin: 3px;\\n    background: #fff;\\n    border: 2px solid #0099FF;\\n    border-radius: 4px;\\n    width: 65%\\n  }\\n\\n  .keyboard {\\n    margin-top: -8px;\\n    width: auto;\\n    position: fixed;\\n    padding-bottom: 4px;\\n    left: 0;\\n    background-color: #F1F1F1;\\n    z-index: 16777271;\\n    transition: all 0.5s;\\n  }\\n\\n  .keyboard-output {\\n    width: calc(100% - 4px);\\n    position: relative;\\n    padding: 2px;\\n    background-color: #fff;\\n  }\\n\\n  .left-right {\\n    position: absolute;\\n    display: block;\\n    margin-left: calc(65% + 15px);\\n    top: 50%;\\n    transform: translateY(-50%);\\n  }\\n\\n  .left-right img {\\n    width: 15px;\\n    height: 15px;\\n  }\\n\\n  .keyboard-output > a {\\n    display: block;\\n    text-decoration: none;\\n    line-height: 40px;\\n    width: 42px;\\n    text-align: center;\\n    background-color: #fff;\\n    color: #2e7bfd;\\n    font-size: 15px;\\n    position: absolute;\\n    right: 2px;\\n    top: 50%;\\n    transform: translateY(-50%);\\n  }\\n\\n  @-webkit-keyframes van-circular {\\n    0% {\\n      stroke-dasharray: 1, 200;\\n      stroke-dashoffset: 0;\\n    }\\n    50% {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -40;\\n    }\\n    to {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -120;\\n    }\\n  }\\n\\n  @keyframes van-circular {\\n    0% {\\n      stroke-dasharray: 1, 200;\\n      stroke-dashoffset: 0;\\n    }\\n    50% {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -40;\\n    }\\n    to {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -120;\\n    }\\n  }\\n\\n  .keyboard-panel-letter {\\n    width: 100vw;\\n    position: center;\\n  }\\n\\n  .keyboard-bottom {\\n    position: center;\\n  }\\n\\n\\n  .keyboard-bottom li {\\n    background-color: #F7F7F7;\\n    margin-left: 4px;\\n    margin-top: 4px;\\n    width: calc((100vw - 28px) / 6);\\n  }\\n\\n  .keyboard-bottom li:nth-child(5) {\\n    width: calc((100vw - 28px) / 6 - 2px);\\n  }\\n\\n  .keyboard-panel .letter-row {\\n    margin-top: 5px;\\n    height: 42px;\\n    width: 100%;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(3) li:first-child {\\n    width: calc((300vw - 97px) / 20);\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(3) li:last-child {\\n    width: calc((300vw - 97px) / 20);\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:first-child {\\n    width: calc((100vw - 19px) / 4);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:last-child {\\n    width: calc((100vw - 19px) / 4);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:nth-child(2) {\\n    width: calc((100vw - 49px) / 10);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:nth-child(3) {\\n    width: calc(2 * (100vw - 49px) / 5 + 15px);\\n    font-size: 15px;\\n    /* background-color: #F7F7F7 */\\n  }\\n\\n  .keyboard-panel-letter ul {\\n    position: relative;\\n    left: 50%;\\n    transform: translateX(-50%);\\n  }\\n\\n  .keyboard-panel-default {\\n    float: left;\\n    margin: 4px 4px 0 4px;\\n  }\\n\\n  .keyboard-panel ul {\\n    margin: 0;\\n    padding: 0;\\n    float: left;\\n  }\\n\\n  .keyboard-panel ul li {\\n    list-style: none;\\n    height: 42px;\\n    line-height: 42px;\\n    text-align: center;\\n    float: left;\\n    border-radius: 5px;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    font-size: 20px;\\n    color: #0d0d0d;\\n    position: relative;\\n  }\\n\\n  .letter-shade {\\n    width: 100%;\\n    height: 100%;\\n    position: absolute;\\n    z-index: 1;\\n  }\\n\\n  .keyboard-panel-letter ul li {\\n    width: calc((100vw - 49px) / 10);\\n    margin-right: 5px;\\n    background-color: #fff;\\n  }\\n\\n  .keyboard-panel-letter ul li:last-child {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-panel-default ul li {\\n    width: calc((100vw - 29px) / 6);\\n    margin-top: 4px;\\n  }\\n\\n  .keyboard-default-symbol {\\n    width: calc((100vw - 16px) / 3);\\n    margin-right: 4px;\\n    float: left;\\n  }\\n\\n  .keyboard-default-symbol > ul {\\n    background-color: #F7F7F7;\\n    border-radius: 5px;\\n  }\\n\\n  .keyboard-default-symbol ul li:nth-child(2n) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-symbol > ul li:nth-child(1) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-symbol > ul li:nth-child(2) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-panel li img {\\n    top: 50%;\\n    transform: translate(-50%, -50%);\\n    max-height: 42px;\\n    position: absolute;\\n    z-index: 0;\\n    left: 50%;\\n  }\\n\\n  .keyboard-default-symbol-bottom ul li {\\n    background-color: #F1F1F1;\\n    font-size: 15px;\\n  }\\n\\n  .keyboard-default-num {\\n    width: calc((100vw - 16px) / 2);\\n    float: left;\\n    margin-right: 4px;\\n  }\\n\\n  .keyboard-default-num ul li {\\n    background-color: #fff;\\n    margin-right: 4px;\\n    width: calc(((100vw - 20px) / 2 - 8px) / 3);\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(1) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(2) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(3) {\\n    margin-top: 0;\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(6) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(9) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(11) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(10) {\\n    width: calc((100vw - 28px) / 3 + 3px);\\n  }\\n\\n  .keyboard-default-right {\\n    width: calc((100vw - 16px) / 6 - 2px);\\n    float: right;\\n    background-color: #F7F7F7;\\n    border-radius: 4px;\\n  }\\n\\n  .keyboard-default-right ul li {\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-symbol-left > ul {\\n    height: 146px;\\n    overflow-y: scroll;\\n    background-color: #F7F7F7;\\n    border-radius: 5px;\\n  }\\n\\n  .keyboard-panel-symbol ul li {\\n    width: calc((100vw - 29px) / 6);\\n    margin-top: 10px;\\n    margin-right: 5px;\\n  }\\n\\n  .keyboard-symbol-left ul li:nth-child(5n) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-symbol-left .keyboard-default-symbol-bottom ul li:nth-child(3) {\\n    width: calc((100vw - 9px) / 2);\\n    margin-right: 0;\\n    background-color: #fff;\\n  }\\n\\n  .keyboard-func img {\\n    height: 36px;\\n  }\\n\\n  .keyboard-func-icon:last-child img {\\n    height: 28px;\\n    margin-top: 4px;\\n  }\\n\\n</style>\\n\\n<style>\\n  .keyboard textarea {\\n    display: none !important;\\n  }\\n\\n  .mathview textarea {\\n    display: none !important;\\n  }\\n\\n\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2tleWJvYXJkLnZ1ZT83NWFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQStDO0FBQ2xGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyx5QkFBeUIsdUNBQXVDLEdBQUcsK0JBQStCLGdCQUFnQixxQkFBcUIsOEJBQThCLHVCQUF1QixpQkFBaUIsOEJBQThCLHFCQUFxQixnQkFBZ0Isb0JBQW9CLHdCQUF3QixZQUFZLDhCQUE4QixzQkFBc0IseUJBQXlCLEdBQUcscUNBQXFDLDRCQUE0Qix1QkFBdUIsaUJBQWlCLDJCQUEyQixHQUFHLGdDQUFnQyx1QkFBdUIsbUJBQW1CLGtDQUFrQyxhQUFhLGdDQUFnQyxHQUFHLG9DQUFvQyxnQkFBZ0IsaUJBQWlCLEdBQUcseUNBQXlDLG1CQUFtQiwwQkFBMEIsc0JBQXNCLGdCQUFnQix1QkFBdUIsMkJBQTJCLG1CQUFtQixvQkFBb0IsdUJBQXVCLGVBQWUsYUFBYSxnQ0FBZ0MsR0FBRyxtREFBbUQsTUFBTSwrQkFBK0IsMkJBQTJCLEdBQUcsT0FBTyxnQ0FBZ0MsNkJBQTZCLEdBQUcsTUFBTSxnQ0FBZ0MsOEJBQThCLEdBQUcsR0FBRywyQ0FBMkMsTUFBTSwrQkFBK0IsMkJBQTJCLEdBQUcsT0FBTyxnQ0FBZ0MsNkJBQTZCLEdBQUcsTUFBTSxnQ0FBZ0MsOEJBQThCLEdBQUcsR0FBRywyQ0FBMkMsaUJBQWlCLHFCQUFxQixHQUFHLHFDQUFxQyxxQkFBcUIsR0FBRyx3Q0FBd0MsOEJBQThCLHFCQUFxQixvQkFBb0Isb0NBQW9DLEdBQUcscURBQXFELDBDQUEwQyxHQUFHLGdEQUFnRCxvQkFBb0IsaUJBQWlCLGdCQUFnQixHQUFHLG1GQUFtRixxQ0FBcUMsOEJBQThCLEdBQUcsa0ZBQWtGLHFDQUFxQyw4QkFBOEIsR0FBRyxtRkFBbUYsb0NBQW9DLG9CQUFvQiw4QkFBOEIsR0FBRyxrRkFBa0Ysb0NBQW9DLG9CQUFvQiw4QkFBOEIsR0FBRyxvRkFBb0YscUNBQXFDLG9CQUFvQiw4QkFBOEIsR0FBRyxvRkFBb0YsK0NBQStDLG9CQUFvQixzQ0FBc0MsOENBQThDLHVCQUF1QixjQUFjLGdDQUFnQyxHQUFHLDRDQUE0QyxnQkFBZ0IsMEJBQTBCLEdBQUcsdUNBQXVDLGNBQWMsZUFBZSxnQkFBZ0IsR0FBRywwQ0FBMEMscUJBQXFCLGlCQUFpQixzQkFBc0IsdUJBQXVCLGdCQUFnQix1QkFBdUIsMkJBQTJCLDhCQUE4QixvQkFBb0IsbUJBQW1CLHVCQUF1QixHQUFHLGtDQUFrQyxnQkFBZ0IsaUJBQWlCLHVCQUF1QixlQUFlLEdBQUcsaURBQWlELHFDQUFxQyxzQkFBc0IsMkJBQTJCLEdBQUcsNERBQTRELG9CQUFvQixHQUFHLGtEQUFrRCxvQ0FBb0Msb0JBQW9CLEdBQUcsNkNBQTZDLG9DQUFvQyxzQkFBc0IsZ0JBQWdCLEdBQUcsa0RBQWtELDhCQUE4Qix1QkFBdUIsR0FBRyxpRUFBaUUsb0JBQW9CLEdBQUcsa0VBQWtFLGtCQUFrQixHQUFHLGtFQUFrRSxrQkFBa0IsR0FBRywyQ0FBMkMsYUFBYSxxQ0FBcUMscUJBQXFCLHVCQUF1QixlQUFlLGNBQWMsR0FBRywwREFBMEQsOEJBQThCLG9CQUFvQixHQUFHLDBDQUEwQyxvQ0FBb0MsZ0JBQWdCLHNCQUFzQixHQUFHLGdEQUFnRCwyQkFBMkIsc0JBQXNCLGdEQUFnRCxHQUFHLDZEQUE2RCxrQkFBa0IsR0FBRyw2REFBNkQsa0JBQWtCLEdBQUcsNkRBQTZELGtCQUFrQixvQkFBb0IsR0FBRyw2REFBNkQsb0JBQW9CLEdBQUcsNkRBQTZELG9CQUFvQixHQUFHLDhEQUE4RCxvQkFBb0IsR0FBRyw4REFBOEQsMENBQTBDLEdBQUcsNENBQTRDLDBDQUEwQyxpQkFBaUIsOEJBQThCLHVCQUF1QixHQUFHLGtEQUFrRCw4QkFBOEIsR0FBRywrQ0FBK0Msa0JBQWtCLHVCQUF1Qiw4QkFBOEIsdUJBQXVCLEdBQUcsaURBQWlELG9DQUFvQyxxQkFBcUIsc0JBQXNCLEdBQUcsOERBQThELG9CQUFvQixHQUFHLDZGQUE2RixtQ0FBbUMsb0JBQW9CLDJCQUEyQixHQUFHLHVDQUF1QyxpQkFBaUIsR0FBRyx1REFBdUQsaUJBQWlCLG9CQUFvQixHQUFHLFlBQVkseUdBQXlHLE1BQU0sV0FBVyxLQUFLLEtBQUssVUFBVSxXQUFXLFdBQVcsV0FBVyxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxVQUFVLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxVQUFVLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLFVBQVUsS0FBSyxLQUFLLFdB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QixLQUFLLHFDQUFxQyxnQ0FBZ0MseUJBQXlCLEtBQUssb0RBQW9ELHNCQUFzQixLQUFLLHFEQUFxRCxvQkFBb0IsS0FBSyxxREFBcUQsb0JBQW9CLEtBQUssOEJBQThCLGVBQWUsdUNBQXVDLHVCQUF1Qix5QkFBeUIsaUJBQWlCLGdCQUFnQixLQUFLLDZDQUE2QyxnQ0FBZ0Msc0JBQXNCLEtBQUssNkJBQTZCLHNDQUFzQyxrQkFBa0Isd0JBQXdCLEtBQUssbUNBQW1DLDZCQUE2Qix3QkFBd0Isa0RBQWtELEtBQUssZ0RBQWdELG9CQUFvQixLQUFLLGdEQUFnRCxvQkFBb0IsS0FBSyxnREFBZ0Qsb0JBQW9CLHNCQUFzQixLQUFLLGdEQUFnRCxzQkFBc0IsS0FBSyxnREFBZ0Qsc0JBQXNCLEtBQUssaURBQWlELHNCQUFzQixLQUFLLGlEQUFpRCw0Q0FBNEMsS0FBSywrQkFBK0IsNENBQTRDLG1CQUFtQixnQ0FBZ0MseUJBQXlCLEtBQUsscUNBQXFDLGdDQUFnQyxLQUFLLGtDQUFrQyxvQkFBb0IseUJBQXlCLGdDQUFnQyx5QkFBeUIsS0FBSyxvQ0FBb0Msc0NBQXNDLHVCQUF1Qix3QkFBd0IsS0FBSyxpREFBaUQsc0JBQXNCLEtBQUssZ0ZBQWdGLHFDQUFxQyxzQkFBc0IsNkJBQTZCLEtBQUssMEJBQTBCLG1CQUFtQixLQUFLLDBDQUEwQyxtQkFBbUIsc0JBQXNCLEtBQUssK0NBQStDLCtCQUErQixLQUFLLDBCQUEwQiwrQkFBK0IsS0FBSyxtQ0FBbUM7O0FBRTFwakMiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuKltkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94ICFpbXBvcnRhbnQ7XFxufVxcbiNtYXRoaW5wdXRbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBtYXJnaW46IDNweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjMDA5OUZGO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgd2lkdGg6IDY1JVxcbn1cXG4ua2V5Ym9hcmRbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgd2lkdGg6IGF1dG87XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBwYWRkaW5nLWJvdHRvbTogNHB4O1xcbiAgbGVmdDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGMUYxRjE7XFxuICB6LWluZGV4OiAxNjc3NzI3MTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzO1xcbn1cXG4ua2V5Ym9hcmQtb3V0cHV0W2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDRweCk7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBwYWRkaW5nOiAycHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbn1cXG4ubGVmdC1yaWdodFtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IGNhbGMoNjUlICsgMTVweCk7XFxuICB0b3A6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLmxlZnQtcmlnaHQgaW1nW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxufVxcbi5rZXlib2FyZC1vdXRwdXQgPiBhW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG4gIHdpZHRoOiA0MnB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGNvbG9yOiAjMmU3YmZkO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDJweDtcXG4gIHRvcDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgdmFuLWNpcmN1bGFyLWRhdGEtdi03OGUwOTJlNCB7XFxuMCUge1xcbiAgICBzdHJva2UtZGFzaGFycmF5OiAxLCAyMDA7XFxuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xcbn1cXG41MCUge1xcbiAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xcbiAgICBzdHJva2UtZGFzaG9mZnNldDogLTQwO1xcbn1cXG50byB7XFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTIwO1xcbn1cXG59XFxuQGtleWZyYW1lcyB2YW4tY2lyY3VsYXItZGF0YS12LTc4ZTA5MmU0IHtcXG4wJSB7XFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEsIDIwMDtcXG4gICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XFxufVxcbjUwJSB7XFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtNDA7XFxufVxcbnRvIHtcXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcXG4gICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xMjA7XFxufVxcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgcG9zaXRpb246IGNlbnRlcjtcXG59XFxuLmtleWJvYXJkLWJvdHRvbVtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIHBvc2l0aW9uOiBjZW50ZXI7XFxufVxcbi5rZXlib2FyZC1ib3R0b20gbGlbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG4gIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDI4cHgpIC8gNik7XFxufVxcbi5rZXlib2FyZC1ib3R0b20gbGlbZGF0YS12LTc4ZTA5MmU0XTpudGgtY2hpbGQoNSkge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjhweCkgLyA2IC0gMnB4KTtcXG59XFxuLmtleWJvYXJkLXBhbmVsIC5sZXR0ZXItcm93W2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgaGVpZ2h0OiA0MnB4O1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDMpIGxpW2RhdGEtdi03OGUwOTJlNF06Zmlyc3QtY2hpbGQge1xcbiAgd2lkdGg6IGNhbGMoKDMwMHZ3IC0gOTdweCkgLyAyMCk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCgzKSBsaVtkYXRhLXYtNzhlMDkyZTRdOmxhc3QtY2hpbGQge1xcbiAgd2lkdGg6IGNhbGMoKDMwMHZ3IC0gOTdweCkgLyAyMCk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaVtkYXRhLXYtNzhlMDkyZTRdOmZpcnN0LWNoaWxkIHtcXG4gIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE5cHgpIC8gNCk7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaVtkYXRhLXYtNzhlMDkyZTRdOmxhc3QtY2hpbGQge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTlweCkgLyA0KTtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxufVxcbi5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDQpIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDIpIHtcXG4gIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDQ5cHgpIC8gMTApO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG59XFxuLmtleWJvYXJkLXBhbmVsLWxldHRlciAubGV0dGVyLXJvdzpudGgtY2hpbGQoNCkgbGlbZGF0YS12LTc4ZTA5MmU0XTpudGgtY2hpbGQoMykge1xcbiAgd2lkdGg6IGNhbGMoMiAqICgxMDB2dyAtIDQ5cHgpIC8gNSArIDE1cHgpO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgLyogYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNyAqL1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIHVsW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtZGVmYXVsdFtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luOiA0cHggNHB4IDAgNHB4O1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwgdWxbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5rZXlib2FyZC1wYW5lbCB1bCBsaVtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBoZWlnaHQ6IDQycHg7XFxuICBsaW5lLWhlaWdodDogNDJweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBjb2xvcjogIzBkMGQwZDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmxldHRlci1zaGFkZVtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTtcXG59XFxuLmtleWJvYXJkLXBhbmVsLWxldHRlciB1bCBsaVtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDQ5cHgpIC8gMTApO1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbi5rZXlib2FyZC1wYW5lbC1kZWZhdWx0IHVsIGxpW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTZweCkgLyAzKTtcXG4gIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCA+IHVsW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDJuKSB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCA+IHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDEpIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCA+IHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDIpIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcbi5rZXlib2FyZC1wYW5lbCBsaSBpbWdbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICB0b3A6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgbWF4LWhlaWdodDogNDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDA7XFxuICBsZWZ0OiA1MCU7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbC1ib3R0b20gdWwgbGlbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjFGMUYxO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbn1cXG4ua2V5Ym9hcmQtZGVmYXVsdC1udW1bZGF0YS12LTc4ZTA5MmU0XSB7XFxuICB3aWR0aDogY2FsYygoMTAwdncgLSAxNnB4KSAvIDIpO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDRweDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgd2lkdGg6IGNhbGMoKCgxMDB2dyAtIDIwcHgpIC8gMiAtIDhweCkgLyAzKTtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDEpIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaVtkYXRhLXYtNzhlMDkyZTRdOm50aC1jaGlsZCgyKSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbn1cXG4ua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGlbZGF0YS12LTc4ZTA5MmU0XTpudGgtY2hpbGQoMykge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDYpIHtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDkpIHtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDExKSB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbi5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaVtkYXRhLXYtNzhlMDkyZTRdOm50aC1jaGlsZCgxMCkge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjhweCkgLyAzICsgM3B4KTtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtcmlnaHRbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICB3aWR0aDogY2FsYygoMTAwdncgLSAxNnB4KSAvIDYgLSAycHgpO1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG59XFxuLmtleWJvYXJkLWRlZmF1bHQtcmlnaHQgdWwgbGlbZGF0YS12LTc4ZTA5MmU0XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbn1cXG4ua2V5Ym9hcmQtc3ltYm9sLWxlZnQgPiB1bFtkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGhlaWdodDogMTQ2cHg7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG4ua2V5Ym9hcmQtcGFuZWwtc3ltYm9sIHVsIGxpW2RhdGEtdi03OGUwOTJlNF0ge1xcbiAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcXG4gIG1hcmdpbi10b3A6IDEwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG59XFxuLmtleWJvYXJkLXN5bWJvbC1sZWZ0IHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDVuKSB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcbi5rZXlib2FyZC1zeW1ib2wtbGVmdCAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wtYm90dG9tIHVsIGxpW2RhdGEtdi03OGUwOTJlNF06bnRoLWNoaWxkKDMpIHtcXG4gIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDlweCkgLyAyKTtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcbi5rZXlib2FyZC1mdW5jIGltZ1tkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGhlaWdodDogMzZweDtcXG59XFxuLmtleWJvYXJkLWZ1bmMtaWNvbjpsYXN0LWNoaWxkIGltZ1tkYXRhLXYtNzhlMDkyZTRdIHtcXG4gIGhlaWdodDogMjhweDtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG59XFxuXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkU6L215Z2l0aHViL21hdGgta2V5Ym9hcmQvc3JjL2xpYi9zcmMvbGliL2tleWJvYXJkLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBNmJBO0VBQ0EsbUNBQUE7Q0FDQTtBQUVBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsMEJBQUE7RUFDQSxtQkFBQTtFQUNBLFVBQUE7Q0FDQTtBQUVBO0VBQ0EsaUJBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxvQkFBQTtFQUNBLFFBQUE7RUFDQSwwQkFBQTtFQUNBLGtCQUFBO0VBQ0EscUJBQUE7Q0FDQTtBQUVBO0VBQ0Esd0JBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtDQUNBO0FBRUE7RUFDQSxtQkFBQTtFQUNBLGVBQUE7RUFDQSw4QkFBQTtFQUNBLFNBQUE7RUFDQSw0QkFBQTtDQUNBO0FBRUE7RUFDQSxZQUFBO0VBQ0EsYUFBQTtDQUNBO0FBRUE7RUFDQSxlQUFBO0VBQ0Esc0JBQUE7RUFDQSxrQkFBQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtFQUNBLHVCQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsbUJBQUE7RUFDQSxXQUFBO0VBQ0EsU0FBQTtFQUNBLDRCQUFBO0NBQ0E7QUFFQTtBQUNBO0lBQ0EseUJBQUE7SUFDQSxxQkFBQTtDQUNBO0FBQ0E7SUFDQSwwQkFBQTtJQUNBLHVCQUFBO0NBQ0E7QUFDQTtJQUNBLDBCQUFBO0lBQ0Esd0JBQUE7Q0FDQTtDQUNBO0FBRUE7QUFDQTtJQUNBLHlCQUFBO0lBQ0EscUJBQUE7Q0FDQTtBQUNBO0lBQ0EsMEJBQUE7SUFDQSx1QkFBQTtDQUNBO0FBQ0E7SUFDQSwwQkFBQTtJQUNBLHdCQUFBO0NBQ0E7Q0FDQTtBQUVBO0VBQ0EsYUFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFFQTtFQUNBLGlCQUFBO0NBQ0E7QUFHQTtFQUNBLDBCQUFBO0VBQ0EsaUJBQUE7RUFDQSxnQkFBQTtFQUNBLGdDQUFBO0NBQ0E7QUFFQTtFQUNBLHNDQUFBO0NBQ0E7QUFFQTtFQUNBLGdCQUFBO0VBQ0EsYUFBQTtFQUNBLFlBQUE7Q0FDQTtBQUVBO0VBQ0EsaUNBQUE7RUFDQSwwQkFBQTtDQUNBO0FBRUE7RUFDQSxpQ0FBQTtFQUNBLDBCQUFBO0NBQ0E7QUFFQTtFQUNBLGdDQUFBO0VBQ0EsZ0JBQUE7RUFDQSwwQkFBQTtDQUNBO0FBRUE7RUFDQSxnQ0FBQTtFQUNBLGdCQUFBO0VBQ0EsMEJBQUE7Q0FDQTtBQUVBO0VBQ0EsaUNBQUE7RUFDQSxnQkFBQTtFQUNBLDBCQUFBO0NBQ0E7QUFFQTtFQUNBLDJDQUFBO0VBQ0EsZ0JBQUE7RUFDQSwrQkFBQTtDQUNBO0FBRUE7RUFDQSxtQkFBQTtFQUNBLFVBQUE7RUFDQSw0QkFBQTtDQUNBO0FBRUE7RUFDQSxZQUFBO0VBQ0Esc0JBQUE7Q0FDQTtBQUVBO0VBQ0EsVUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0NBQ0E7QUFFQTtFQUNBLGlCQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQUFBO0VBQ0EsbUJBQUE7RUFDQSx1QkFBQTtFQUNBLDBCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxlQUFBO0VBQ0EsbUJBQUE7Q0FDQTtBQUVBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFdBQUE7Q0FDQTtBQUVBO0VBQ0EsaUNBQUE7RUFDQSxrQkFBQTtFQUNBLHVCQUFBO0NBQ0E7QUFFQTtFQUNBLGdCQUFBO0NBQ0E7QUFFQTtFQUNBLGdDQUFBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0NBQUE7RUFDQSxrQkFBQTtFQUNBLFlBQUE7Q0FDQTtBQUVBO0VBQ0EsMEJBQUE7RUFDQSxtQkFBQTtDQUNBO0FBRUE7RUFDQSxnQkFBQTtDQUNBO0FBRUE7RUFDQSxjQUFBO0NBQ0E7QUFFQTtFQUNBLGNBQUE7Q0FDQTtBQUVBO0VBQ0EsU0FBQTtFQUNBLGlDQUFBO0VBQ0EsaUJBQUE7RUFDQSxtQkFBQTtFQUNBLFdBQUE7RUFDQSxVQUFBO0NBQ0E7QUFFQTtFQUNBLDBCQUFBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0NBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7Q0FDQTtBQUVBO0VBQ0EsdUJBQUE7RUFDQSxrQkFBQTtFQUNBLDRDQUFBO0NBQ0E7QUFFQTtFQUNBLGNBQUE7Q0FDQTtBQUVBO0VBQ0EsY0FBQTtDQUNBO0FBRUE7RUFDQSxjQUFBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUVBO0VBQ0Esc0NBQUE7Q0FDQTtBQUVBO0VBQ0Esc0NBQUE7RUFDQSxhQUFBO0VBQ0EsMEJBQUE7RUFDQSxtQkFBQTtDQUNBO0FBRUE7RUFDQSwwQkFBQTtDQUNBO0FBRUE7RUFDQSxjQUFBO0VBQ0EsbUJBQUE7RUFDQSwwQkFBQTtFQUNBLG1CQUFBO0NBQ0E7QUFFQTtFQUNBLGdDQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtDQUNBO0FBRUE7RUFDQSxnQkFBQTtDQUNBO0FBRUE7RUFDQSwrQkFBQTtFQUNBLGdCQUFBO0VBQ0EsdUJBQUE7Q0FDQTtBQUVBO0VBQ0EsYUFBQTtDQUNBO0FBRUE7RUFDQSxhQUFBO0VBQ0EsZ0JBQUE7Q0FDQVwiLFwiZmlsZVwiOlwia2V5Ym9hcmQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkXFxcIiBpZD1cXFwia2V5Ym9hcmRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZC1vdXRwdXRcXFwiPlxcbiAgICAgIDxzcGFuIDppZD1cXFwibWF0aGlucHV0XFxcIlxcbiAgICAgICAgICAgIEB0b3VjaHN0YXJ0PVxcXCJjdXJzb3JEb3duKCRldmVudClcXFwiXFxuICAgICAgICAgICAgQHRvdWNobW92ZT1cXFwiY3Vyc29yTW92ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIEB0b3VjaHVwPVxcXCJjdXJzb3JVcCgkZXZlbnQpXFxcIj5cXG4gICAgICA8L3NwYW4+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGVmdC1yaWdodFxcXCI+XFxuICAgICAgICA8aW1nIDpzcmM9XFxcImltZy5jdXJzb3JfbGVmdFxcXCIgQGNsaWNrPVxcXCJjdXJzb3JMZWZ0KCRldmVudClcXFwiLz5cXG4gICAgICAgIDxpbWcgOnNyYz1cXFwiaW1nLmN1cnNvcl9yaWdodFxcXCIgQGNsaWNrPVxcXCJjdXJzb3JSaWdodCgkZXZlbnQpXFxcIiBzdHlsZT1cXFwibWFyZ2luLWxlZnQ6IDIwcHhcXFwiLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8YSBAY2xpY2s9XFxcImtleWhpZGUoKVxcXCIgc3R5bGU9XFxcIndpZHRoOiAxNSVcXFwiPuehruWumjwvYT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkLXBhbmVsXFxcIlxcbiAgICAgICAgIDpzdHlsZT1cXFwie2Rpc3BsYXk6a2V5b3J3cml0ZSA9PT0gMSA/ICd1bnNldCc6J25vbmUnfVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtcGFuZWwtZGVmYXVsdFxcXCIgdi1pZj1cXFwicGFuZWwgPT09IDFcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2xcXFwiPlxcbiAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJpdGVtIGluIGtleXN5bVxcXCIgQGNsaWNrPVxcXCJpbnNlcnRhcihpdGVtLnYpXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiaXRlbS50ID0gdHJ1ZVxcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoZW5kPVxcXCJpdGVtLnQgPSBmYWxzZVxcXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVxcXCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVxcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXR0ZXItc2hhZGVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGltZyA6c3JjPVxcXCJpdGVtLmlcXFwiIHYtaWY9XFxcIml0ZW0uaVxcXCIvPnt7aXRlbS5rfX1cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZC1kZWZhdWx0LW51bVxcXCI+XFxuICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICA8bGkgdi1mb3I9XFxcIml0ZW0gaW4ga2V5bnVtXFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcImluc2VydGFyKGl0ZW0udilcXFwiXFxuICAgICAgICAgICAgICAgIEB0b3VjaHN0YXJ0PVxcXCJpdGVtLnQgPSB0cnVlXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hlbmQ9XFxcIml0ZW0udCA9IGZhbHNlXFxcIlxcbiAgICAgICAgICAgICAgICA6c3R5bGU9XFxcInsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50PycjYmFiYWJhJzonI2ZmZid9XFxcIlxcbiAgICAgICAgICAgID57e2l0ZW0ua319XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtZGVmYXVsdC1yaWdodFxcXCI+XFxuICAgICAgICAgIDx1bD5cXG4gICAgICAgICAgICA8bGkgQHRvdWNoc3RhcnQ9XFxcImJhY2tEb3duKCdCYWNrc3BhY2UnKVxcXCIgQHRvdWNoZW5kPVxcXCJiYWNrVXAoJ0JhY2tzcGFjZScpXFxcIlxcbiAgICAgICAgICAgICAgICBzdHlsZT1cXFwiYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNzttYXJnaW4tdG9wOiAwcHhcXFwiPjxpbWcgOnNyYz1cXFwiaW1nLmJhY2tcXFwiLz48L2xpPlxcbiAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiaXRlbSBpbiBrZXlib2FyZFJpZ2h0XFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcImluc2VydGFyKGl0ZW0udilcXFwiXFxuICAgICAgICAgICAgICAgIEB0b3VjaHN0YXJ0PVxcXCJpdGVtLnQgPSB0cnVlXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hlbmQ9XFxcIml0ZW0udCA9IGZhbHNlXFxcIlxcbiAgICAgICAgICAgICAgICA6c3R5bGU9XFxcInsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50PycjYmFiYWJhJzonI0Y3RjdGNyd9XFxcIj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldHRlci1zaGFkZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8aW1nIDpzcmM9XFxcIml0ZW0uaVxcXCIgdi1pZj1cXFwiaXRlbS5pXFxcIi8+e3tpdGVtLmt9fVxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZC1wYW5lbC1sZXR0ZXJcXFwiIHYtaWY9XFxcInBhbmVsID09PSAzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxldHRlci1yb3dcXFwiIHYtZm9yPVxcXCJpdGVtcyBpbiBrZXlhYmNbY2Fwc2xldHRlcl1cXFwiPlxcbiAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJpdGVtIGluIGl0ZW1zXFxcIlxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcIihpdGVtLnYgIT09ICdzaGlmdCcgPyAoaXRlbS52ICE9PSAnQmFja3NwYWNlJyA/IGluc2VydGFyKGl0ZW0udikgOiAnJykgOiBjYXBzKCkpXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiaXRlbS50ID0gdHJ1ZSxiYWNrRG93bihpdGVtLnYpLGl0ZW0udiA9PT0gJ0JhY2tzcGFjZScgPyBpdGVtLmkgPSBpbWcuZGJhY2sgOiAnJ1xcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoZW5kPVxcXCJpdGVtLnQgPSBmYWxzZSxiYWNrVXAoaXRlbS52KSxpdGVtLnYgPT09ICdCYWNrc3BhY2UnID8gaXRlbS5pID0gaW1nLmJhY2sgOiAnJ1xcXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVxcXCJpdGVtLnYgIT09ICdzaGlmdCcgPyBpdGVtLnYgIT09ICdCYWNrc3BhY2UnID8geydiYWNrZ3JvdW5kLWNvbG9yJzppdGVtLnQgPyAnI2JhYmFiYScgOiAnI2ZmZid9IDogeydiYWNrZ3JvdW5kLWNvbG9yJzppdGVtLnQgPyAnI2ZmZicgOiAnI0Y3RjdGNyd9IDp7J2JhY2tncm91bmQtY29sb3InOml0ZW0ucyA/ICcjZmZmJyA6ICcjRjdGN0Y3J31cXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGV0dGVyLXNoYWRlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxpbWcgOnNyYz1cXFwiaXRlbS5pXFxcIiB2LWlmPVxcXCJpdGVtLmlcXFwiLz57e2l0ZW0ua319XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkLWJvdHRvbVxcXCI+XFxuICAgICAgICA8dWw+XFxuICAgICAgICAgIDxsaSBAY2xpY2s9XFxcImNoYW5nZXBhbmVsKHBhbmVsPT09MT8zOjEpXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOiAxNHB4O1xcXCI+e3twYW5lbD09PTE/J2FiYyc6JzEyMyd9fVxcbiAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICA8bGkgdi1mb3I9XFxcIml0ZW0gaW4ga2V5Qm90dG9tU3ltXFxcIlxcbiAgICAgICAgICAgICAgQGNsaWNrPVxcXCJpdGVtLnY9PT0naGlkZSc/a2V5aGlkZSgpOmluc2VydGFyKGl0ZW0udilcXFwiXFxuICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiaXRlbS50ID0gdHJ1ZVxcXCJcXG4gICAgICAgICAgICAgIEB0b3VjaGVuZD1cXFwiaXRlbS50ID0gZmFsc2VcXFwiXFxuICAgICAgICAgICAgICA6c3R5bGU9XFxcInsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50PycjYmFiYWJhJzonI0Y3RjdGNyd9XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXR0ZXItc2hhZGVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxpbWcgOnNyYz1cXFwiaXRlbS5pXFxcIiB2LWlmPVxcXCJpdGVtLmlcXFwiLz57e2l0ZW0ua319XFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICA8L3VsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG4gICAgaW1wb3J0IFxcXCJtYXRocXVpbGwvYnVpbGQvbWF0aHF1aWxsXFxcIjtcXG4gICAgaW1wb3J0IGltZyBmcm9tICcuL2ltZy5qcydcXG4gICAgaW1wb3J0IHtzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXR9IGZyb20gJ3RpbWVycyc7XFxuXFxuICAgIGV4cG9ydCBkZWZhdWx0IHtcXG4gICAgICAgIG5hbWU6IFxcXCJtYXRoLWtleWJvYXJkXFxcIixcXG4gICAgICAgIGRhdGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIG1hdGhGaWVsZDogbnVsbCxcXG4gICAgICAgICAgICAgICAgbWF0aHZpZXc6ICdtYXRodmlldycgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogKDk5OTk5OSAtIDEwMDAwMCArIDEpICsgMTAwMDAwLCAxMCksXFxuICAgICAgICAgICAgICAgIG1hdGhpbnB1dDogJ21hdGhpbnB1dCcsXFxuICAgICAgICAgICAgICAgIHBhbmVsOiB0aGlzLmtleXBhbmVsLFxcbiAgICAgICAgICAgICAgICBjYXBzbGV0dGVyOiAnbGV0dGVyJyxcXG4gICAgICAgICAgICAgICAga2V5YWJjOiB7XFxuICAgICAgICAgICAgICAgICAgICAnbGV0dGVyJzogW1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdxJywgdjogJ3EnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAndycsIHY6ICd3JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2UnLCB2OiAnZScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdyJywgdjogJ3InLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAndCcsIHY6ICd0JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3knLCB2OiAneScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd1JywgdjogJ3UnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaScsIHY6ICdpJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ28nLCB2OiAnbycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdwJywgdjogJ3AnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnYScsIHY6ICdhJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3MnLCB2OiAncycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdkJywgdjogJ2QnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnZicsIHY6ICdmJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2cnLCB2OiAnZycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdoJywgdjogJ2gnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaicsIHY6ICdqJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2snLCB2OiAnaycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdsJywgdjogJ2wnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ3NoaWZ0JywgaTogaW1nLnNoaWZ0LCBzOiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAneicsIHY6ICd6JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3gnLCB2OiAneCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdjJywgdjogJ2MnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAndicsIHY6ICd2JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2InLCB2OiAnYicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICduJywgdjogJ24nLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbScsIHY6ICdtJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdCYWNrc3BhY2UnLCBpOiBpbWcuYmFjaywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cXG4gICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAnY2Fwcyc6IFtcXG4gICAgICAgICAgICAgICAgICAgICAgICBbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUScsIHY6ICdRJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1cnLCB2OiAnVycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdFJywgdjogJ0UnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUicsIHY6ICdSJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1QnLCB2OiAnVCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdZJywgdjogJ1knLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnVScsIHY6ICdVJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0knLCB2OiAnSScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdPJywgdjogJ08nLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUCcsIHY6ICdQJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0EnLCB2OiAnQScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdTJywgdjogJ1MnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnRCcsIHY6ICdEJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0YnLCB2OiAnRicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdHJywgdjogJ0cnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnSCcsIHY6ICdIJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0onLCB2OiAnSicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdLJywgdjogJ0snLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnTCcsIHY6ICdMJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdzaGlmdCcsIGk6IGltZy5kc2hpZnQsIHM6IHRydWV9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1onLCB2OiAnWicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdYJywgdjogJ1gnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnQycsIHY6ICdDJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1YnLCB2OiAnVicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdCJywgdjogJ0InLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnTicsIHY6ICdOJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ00nLCB2OiAnTScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnQmFja3NwYWNlJywgaTogaW1nLmJhY2ssIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBdXFxuICAgICAgICAgICAgICAgICAgICBdXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGtleW51bTogW1xcbiAgICAgICAgICAgICAgICAgICAge2s6ICcxJywgdjogJzEnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzInLCB2OiAnMicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnMycsIHY6ICczJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc0JywgdjogJzQnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzUnLCB2OiAnNScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnNicsIHY6ICc2JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc3JywgdjogJzcnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzgnLCB2OiAnOCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnOScsIHY6ICc5JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcwJywgdjogJzAnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJy4nLCB2OiAnLicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAga2V5c3ltOiBbXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdcXFxcXFxcXG50aHJvb3QnLCBpOiBpbWcucmFpeiwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXFxcXFxcXFxzcXJ0JywgaTogaW1nLnJhaXoyLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdeJywgaTogaW1nLnBvdGVuY2lhLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdeMicsIGk6IGltZy5jdWFkcmFkbywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnfCcsIGk6IGltZy5hYnMsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJy8nLCBpOiBpbWcuZnJhY2Npb24sIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxcXFxccGknLCBpOiBpbWcuX3BpLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICfmiJYnLCBpOiBpbWcub3IsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJ14zJywgaTogaW1nLnRlcmNlcmF9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcoJywgdjogJygnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJyknLCB2OiAnKScsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnWycsIHY6ICdbJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICddJywgdjogJ10nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ3NpbicsIHY6ICdcXFxcXFxcXHNpbicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnY29zJywgdjogJ1xcXFxcXFxcY29zJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICd0YW4nLCB2OiAnXFxcXFxcXFx0YW4nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KJiCcsIHY6ICdcXFxcXFxcXGFwcHJveCcsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4omgJywgdjogJ1xcXFxcXFxcbmVxJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICclJywgdjogJyUnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICctJywgaTogaW1nLnN1YnRyYWN0fSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJysnLCBpOiBpbWcucGx1c30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ8OXJywgdjogJ1xcXFxcXFxcdGltZXMnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ8O3JywgdjogJ1xcXFxcXFxcZGl2JywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcnLCB2OiAnwrEnLCBpOiBpbWcudW5pb259LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcsJywgdjogJywnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJzonLCB2OiAnOicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnwrAnLCB2OiAnXFxcXFxcXFxkZWdyZWUnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+S4lCcsIHY6ICfkuJQnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+mdnicsIHY6ICfpnZ4nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ3gnLCB2OiAneCcsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAneScsIHY6ICd5JywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiJEnLCB2OiAnXFxcXFxcXFxzdW0nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+WQkemHjycsIHY6ICdcXFxcXFxcXG92ZXJyaWdodGFycm93JywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiKAnLCB2OiAn4oigJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiLUnLCB2OiAnXFxcXFxcXFxiZWNhdXNlJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiLQnLCB2OiAnXFxcXFxcXFx0aGVyZWZvcmUnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KIiCcsIHY6ICdcXFxcXFxcXGluJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiIknLCB2OiAnXFxcXFxcXFxub3RpbicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oipJywgdjogJ1xcXFxcXFxcaW50ZXJzZWN0aW9uJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiKonLCB2OiAnXFxcXFxcXFxjdXAnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KKgicsIHY6ICdcXFxcXFxcXHN1YnNldCcsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oqDJywgdjogJ1xcXFxcXFxcc3VwZXJzZXQnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KInicsIHY6ICdcXFxcXFxcXGluZnR5JywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICdsb2cnLCB2OiAnXFxcXFxcXFxsb2cnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KGkCcsIHY6ICdcXFxcXFxcXGxlZnRhcnJvdycsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oaSJywgdjogJ1xcXFxcXFxccmlnaHRhcnJvdycsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oeUJywgdjogJ1xcXFxcXFxcaWZmJywgaTogJyd9XFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIGtleUJvdHRvbVN5bTogW1xcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcnLCB2OiAnYWJjJywgaTogaW1nLmFiY30sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdoaWRlJywgaTogaW1nLmhpZGUsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJzwnLCBpOiBpbWcubGVzc190aGFuLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICc+JywgaTogaW1nLm1vcmVfdGhhbiwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXFxcXFxcXFxsZXEnLCBpOiBpbWcubGVzc19lcXVhbHMsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxcXFxcZ2VxJywgaTogaW1nLm1vcmVfZXF1YWxzLCB0OiBmYWxzZX0sXFxuXFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIGtleWJvYXJkUmlnaHQ6IFtcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJy0nLCBpOiBpbWcuc3VidHJhY3QsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJysnLCBpOiBpbWcucGx1cywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnwrEnLCBpOiBpbWcudW5pb24sIHQ6IGZhbHNlfVxcbiAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICBsYXRleDogdGhpcy52YWx1ZSxcXG4gICAgICAgICAgICAgICAga2V5c2hvdzogdGhpcy5zaG93LFxcbiAgICAgICAgICAgICAgICBrZXlvcndyaXRlOiAxLFxcbiAgICAgICAgICAgICAgICBjdXJzb3J4OiAwLFxcbiAgICAgICAgICAgICAgICBjdXJzb3J5OiAwLFxcbiAgICAgICAgICAgICAgICB0aW1lcjogbnVsbCxcXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IG51bGxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIHByb3BzOiB7XFxuICAgICAgICAgICAgc2hvdzogQm9vbGVhbixcXG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nLFxcbiAgICAgICAgICAgIGtleXBhbmVsOiB7XFxuICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3RybDoge1xcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDBcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG91dHB1dDogU3RyaW5nLFxcbiAgICAgICAgfSxcXG4gICAgICAgIG1vdW50ZWQoKSB7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgICAgIHZhciBtYXRoRmllbGRTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tYXRoaW5wdXQpO1xcblxcbiAgICAgICAgICAgIHZhciBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XFxuICAgICAgICAgICAgdmFyIG1hdGhGaWVsZCA9IHRoYXQubWF0aEZpZWxkID0gTVEuTWF0aEZpZWxkKG1hdGhGaWVsZFNwYW4sIHtcXG4gICAgICAgICAgICAgICAgc3BhY2VCZWhhdmVzTGlrZVRhYjogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgbGVmdFJpZ2h0SW50b0NtZEdvZXM6ICd1cCcsXFxuICAgICAgICAgICAgICAgIHJlc3RyaWN0TWlzbWF0Y2hlZEJyYWNrZXRzOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBzdW1TdGFydHNXaXRoTkVxdWFsczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgc3VwU3Vic1JlcXVpcmVPcGVyYW5kOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBhdXRvU3Vic2NyaXB0TnVtZXJhbHM6IHRydWUsXFxuICAgICAgICAgICAgICAgIGF1dG9PcGVyYXRvck5hbWVzOiAnc2luIENPTU1BJyxcXG4gICAgICAgICAgICAgICAgaGFuZGxlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIGVkaXQ6IGZ1bmN0aW9uIChtYXRoRmllbGQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LiRlbWl0KCd1cGRhdGU6dmFsdWUnLCBtYXRoRmllbGQubGF0ZXgoKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy/mmL7npLrlhYnmoIdcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbWF0aEZpZWxkLl9fY29udHJvbGxlcjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmN1cnNvci5zaG93KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5ibHVycmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB0aGF0Lm1hdGhGaWVsZC5sYXRleCh0aGF0LnZhbHVlKTtcXG5cXG4gICAgICAgICAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gJCgnI21hdGhpbnB1dCAubXEtcm9vdC1ibG9jaycpO1xcbiAgICAgICAgICAgICAgICBjb250ZW50LnNjcm9sbExlZnQoY29udGVudFswXS5zY3JvbGxXaWR0aClcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1ldGhvZHM6IHtcXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiDmj5LlhaXnrKblj7dcXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsb3JcXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBpbnNlcnRhcih2YWxvcikge1xcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICAgICAgICAgIGlmICh2YWxvci5pbmNsdWRlcyhcXFwiXjJcXFwiKSB8fCB2YWxvci5pbmNsdWRlcyhcXFwiXjNcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tYXRoRmllbGQud3JpdGUodmFsb3IpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbG9yID09PSAnQmFja3NwYWNlJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tYXRoRmllbGQua2V5c3Ryb2tlKHZhbG9yKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubWF0aEZpZWxkLmNtZCh2YWxvcik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIOmUruebmOW4g+WxgOWIh+aNolxcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWxcXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBjaGFuZ2VwYW5lbCh2YWwpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5wYW5lbCA9IHZhbDtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmtleXBhbmVsJywgdmFsKTtcXG4gICAgICAgICAgICAgICAgbGV0IGtleWJvYXJkRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2tleWJvYXJkJyk7XFxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShrZXlib2FyZERpdikuZ2V0UHJvcGVydHlWYWx1ZShcXFwiaGVpZ2h0XFxcIik7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGhlaWdodCk7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAkQXBwLmtleWJvYXJkSGVpZ2h0KGhlaWdodCk7XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICog5a2X5q+N5aSn5bCP5YaZ5YiH5o2iXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgY2FwcygpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2Fwc2xldHRlciA9PT0gJ2xldHRlcicpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fwc2xldHRlciA9ICdjYXBzJ1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXBzbGV0dGVyID0gJ2xldHRlcidcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICog6ZSu55uY6ZqQ6JePXFxuICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50XFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAga2V5aGlkZShldmVudCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2hvdycsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm91dHB1dCcsIHRoaXMudmFsdWUpO1xcbiAgICAgICAgICAgICAgICAkQXBwLmhpZGVLZXlib2FyZCgpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3Vyc29yTGVmdChldmVudCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXFxcIkxlZnRcXFwiKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3J4ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkxlZnRcXFwiKVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3Vyc29yUmlnaHQoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFxcXCJSaWdodFxcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiUmlnaHRcXFwiKVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3Vyc29yVXAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3Vyc29yRG93bihldmVudCkge1xcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJzb3J4ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY3Vyc29yeSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjdXJzb3JNb3ZlKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5jdXJzb3J4IC0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmN1cnNvcnkgLSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeCA+IDEwKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXFxcIkxlZnRcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiTGVmdFxcXCIpXFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMTApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZShcXFwiUmlnaHRcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiUmlnaHRcXFwiKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICh5ID4gMTApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZShcXFwiVXBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiVXBcXFwiKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICh5IDwgLTEwKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXFxcIkRvd25cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiRG93blxcXCIpXFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIGJhY2tEb3duKHZhbCkge1xcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSAnQmFja3NwYWNlJykge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0aEZpZWxkLmtleXN0cm9rZSgnQmFja3NwYWNlJylcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApXFxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApXFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJhY2tVcCh2YWwpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJ0JhY2tzcGFjZScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZSgnQmFja3NwYWNlJyk7XFxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgd2F0Y2g6IHtcXG4gICAgICAgICAgICB2YWx1ZShudmFsLCBvdmFsKSB7XFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93KSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5sYXRleCh0aGlzLnZhbHVlKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gJCgnI21hdGhpbnB1dCAubXEtcm9vdC1ibG9jaycpO1xcbiAgICAgICAgICAgICAgICBjb250ZW50LnNjcm9sbExlZnQoY29udGVudFswXS5zY3JvbGxXaWR0aClcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN0cmwobnZhbCwgb3ZhbCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6Y3RybCcsIG52YWwpXFxuICAgICAgICAgICAgICAgIC8vIHRoaXMua2V5aGlkZSgpXFxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjdHJsJytudmFsKVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICB9XFxuICAgIH07XFxuPC9zY3JpcHQ+XFxuXFxuPCEtLSBBZGQgXFxcInNjb3BlZFxcXCIgYXR0cmlidXRlIHRvIGxpbWl0IENTUyB0byB0aGlzIGNvbXBvbmVudCBvbmx5IC0tPlxcbjxzdHlsZSBzY29wZWQ+XFxuICAqIHtcXG4gICAgYm94LXNpemluZzogY29udGVudC1ib3ggIWltcG9ydGFudDtcXG4gIH1cXG5cXG4gICNtYXRoaW5wdXQge1xcbiAgICBtYXJnaW46IDNweDtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXG4gICAgYm9yZGVyOiAycHggc29saWQgIzAwOTlGRjtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICB3aWR0aDogNjUlXFxuICB9XFxuXFxuICAua2V5Ym9hcmQge1xcbiAgICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjFGMUYxO1xcbiAgICB6LWluZGV4OiAxNjc3NzI3MTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNXM7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtb3V0cHV0IHtcXG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIDRweCk7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLmxlZnQtcmlnaHQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW4tbGVmdDogY2FsYyg2NSUgKyAxNXB4KTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIH1cXG5cXG4gIC5sZWZ0LXJpZ2h0IGltZyB7XFxuICAgIHdpZHRoOiAxNXB4O1xcbiAgICBoZWlnaHQ6IDE1cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtb3V0cHV0ID4gYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbiAgICB3aWR0aDogNDJweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogIzJlN2JmZDtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAycHg7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICB9XFxuXFxuICBALXdlYmtpdC1rZXlmcmFtZXMgdmFuLWNpcmN1bGFyIHtcXG4gICAgMCUge1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEsIDIwMDtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogMDtcXG4gICAgfVxcbiAgICA1MCUge1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC00MDtcXG4gICAgfVxcbiAgICB0byB7XFxuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogLTEyMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgQGtleWZyYW1lcyB2YW4tY2lyY3VsYXIge1xcbiAgICAwJSB7XFxuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMSwgMjAwO1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xcbiAgICB9XFxuICAgIDUwJSB7XFxuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogLTQwO1xcbiAgICB9XFxuICAgIHRvIHtcXG4gICAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTIwO1xcbiAgICB9XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIHtcXG4gICAgd2lkdGg6IDEwMHZ3O1xcbiAgICBwb3NpdGlvbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWJvdHRvbSB7XFxuICAgIHBvc2l0aW9uOiBjZW50ZXI7XFxuICB9XFxuXFxuXFxuICAua2V5Ym9hcmQtYm90dG9tIGxpIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAyOHB4KSAvIDYpO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWJvdHRvbSBsaTpudGgtY2hpbGQoNSkge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAyOHB4KSAvIDYgLSAycHgpO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsIC5sZXR0ZXItcm93IHtcXG4gICAgbWFyZ2luLXRvcDogNXB4O1xcbiAgICBoZWlnaHQ6IDQycHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciAubGV0dGVyLXJvdzpudGgtY2hpbGQoMykgbGk6Zmlyc3QtY2hpbGQge1xcbiAgICB3aWR0aDogY2FsYygoMzAwdncgLSA5N3B4KSAvIDIwKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDMpIGxpOmxhc3QtY2hpbGQge1xcbiAgICB3aWR0aDogY2FsYygoMzAwdncgLSA5N3B4KSAvIDIwKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDQpIGxpOmZpcnN0LWNoaWxkIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTlweCkgLyA0KTtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciAubGV0dGVyLXJvdzpudGgtY2hpbGQoNCkgbGk6bGFzdC1jaGlsZCB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE5cHgpIC8gNCk7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDQpIGxpOm50aC1jaGlsZCgyKSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDQ5cHgpIC8gMTApO1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaTpudGgtY2hpbGQoMykge1xcbiAgICB3aWR0aDogY2FsYygyICogKDEwMHZ3IC0gNDlweCkgLyA1ICsgMTVweCk7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgLyogYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNyAqL1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciB1bCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtZGVmYXVsdCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBtYXJnaW46IDRweCA0cHggMCA0cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwgdWwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsIHVsIGxpIHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgaGVpZ2h0OiA0MnB4O1xcbiAgICBsaW5lLWhlaWdodDogNDJweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxuICAgIGNvbG9yOiAjMGQwZDBkO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuXFxuICAubGV0dGVyLXNoYWRlIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAxO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciB1bCBsaSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDQ5cHgpIC8gMTApO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgdWwgbGk6bGFzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1kZWZhdWx0IHVsIGxpIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTZweCkgLyAzKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sID4gdWwge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wgdWwgbGk6bnRoLWNoaWxkKDJuKSB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCA+IHVsIGxpOm50aC1jaGlsZCgxKSB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wgPiB1bCBsaTpudGgtY2hpbGQoMikge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsIGxpIGltZyB7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gICAgbWF4LWhlaWdodDogNDJweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAwO1xcbiAgICBsZWZ0OiA1MCU7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wtYm90dG9tIHVsIGxpIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YxRjFGMTtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTZweCkgLyAyKTtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICAgIHdpZHRoOiBjYWxjKCgoMTAwdncgLSAyMHB4KSAvIDIgLSA4cHgpIC8gMyk7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDEpIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoMikge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCgzKSB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoNikge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDkpIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCgxMSkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDEwKSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDI4cHgpIC8gMyArIDNweCk7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1yaWdodCB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE2cHgpIC8gNiAtIDJweCk7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtcmlnaHQgdWwgbGkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXN5bWJvbC1sZWZ0ID4gdWwge1xcbiAgICBoZWlnaHQ6IDE0NnB4O1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1zeW1ib2wgdWwgbGkge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAyOXB4KSAvIDYpO1xcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1zeW1ib2wtbGVmdCB1bCBsaTpudGgtY2hpbGQoNW4pIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXN5bWJvbC1sZWZ0IC5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbC1ib3R0b20gdWwgbGk6bnRoLWNoaWxkKDMpIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gOXB4KSAvIDIpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZnVuYyBpbWcge1xcbiAgICBoZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZnVuYy1pY29uOmxhc3QtY2hpbGQgaW1nIHtcXG4gICAgaGVpZ2h0OiAyOHB4O1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7XFxuICB9XFxuXFxuPC9zdHlsZT5cXG5cXG48c3R5bGU+XFxuICAua2V5Ym9hcmQgdGV4dGFyZWEge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAubWF0aHZpZXcgdGV4dGFyZWEge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuXFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(20);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"70f6bffa\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2tleWJvYXJkLnZ1ZT85ODg5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXNRO0FBQzVSLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBNkQ7QUFDL0UsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9rZXlib2FyZC52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNzBmNmJmZmFcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4va2V5Ym9hcmQudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4va2V5Ym9hcmQudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){eval("exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.keyboard textarea {\\n  display: none !important;\\n}\\n.mathview textarea {\\n  display: none !important;\\n}\\n\\n\\n\", \"\", {\"version\":3,\"sources\":[\"E:/mygithub/math-keyboard/src/lib/src/lib/keyboard.vue\"],\"names\":[],\"mappings\":\";AAmwBA;EACA,yBAAA;CACA;AAEA;EACA,yBAAA;CACA\",\"file\":\"keyboard.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"keyboard\\\" id=\\\"keyboard\\\">\\n    <div class=\\\"keyboard-output\\\">\\n      <span :id=\\\"mathinput\\\"\\n            @touchstart=\\\"cursorDown($event)\\\"\\n            @touchmove=\\\"cursorMove($event)\\\"\\n            @touchup=\\\"cursorUp($event)\\\">\\n      </span>\\n      <div class=\\\"left-right\\\">\\n        <img :src=\\\"img.cursor_left\\\" @click=\\\"cursorLeft($event)\\\"/>\\n        <img :src=\\\"img.cursor_right\\\" @click=\\\"cursorRight($event)\\\" style=\\\"margin-left: 20px\\\"/>\\n      </div>\\n      <a @click=\\\"keyhide()\\\" style=\\\"width: 15%\\\">确定</a>\\n    </div>\\n    <div class=\\\"keyboard-panel\\\"\\n         :style=\\\"{display:keyorwrite === 1 ? 'unset':'none'}\\\">\\n      <div class=\\\"keyboard-panel-default\\\" v-if=\\\"panel === 1\\\">\\n        <div class=\\\"keyboard-default-symbol\\\">\\n          <ul>\\n            <li v-for=\\\"item in keysym\\\" @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n        <div class=\\\"keyboard-default-num\\\">\\n          <ul>\\n            <li v-for=\\\"item in keynum\\\"\\n                @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#fff'}\\\"\\n            >{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n        <div class=\\\"keyboard-default-right\\\">\\n          <ul>\\n            <li @touchstart=\\\"backDown('Backspace')\\\" @touchend=\\\"backUp('Backspace')\\\"\\n                style=\\\"background-color: #F7F7F7;margin-top: 0px\\\"><img :src=\\\"img.back\\\"/></li>\\n            <li v-for=\\\"item in keyboardRight\\\"\\n                @click=\\\"insertar(item.v)\\\"\\n                @touchstart=\\\"item.t = true\\\"\\n                @touchend=\\\"item.t = false\\\"\\n                :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n      </div>\\n\\n      <div class=\\\"keyboard-panel-letter\\\" v-if=\\\"panel === 3\\\">\\n        <div class=\\\"letter-row\\\" v-for=\\\"items in keyabc[capsletter]\\\">\\n          <ul>\\n            <li v-for=\\\"item in items\\\"\\n                @click=\\\"(item.v !== 'shift' ? (item.v !== 'Backspace' ? insertar(item.v) : '') : caps())\\\"\\n                @touchstart=\\\"item.t = true,backDown(item.v),item.v === 'Backspace' ? item.i = img.dback : ''\\\"\\n                @touchend=\\\"item.t = false,backUp(item.v),item.v === 'Backspace' ? item.i = img.back : ''\\\"\\n                :style=\\\"item.v !== 'shift' ? item.v !== 'Backspace' ? {'background-color':item.t ? '#bababa' : '#fff'} : {'background-color':item.t ? '#fff' : '#F7F7F7'} :{'background-color':item.s ? '#fff' : '#F7F7F7'}\\\"\\n            >\\n              <div class=\\\"letter-shade\\\"></div>\\n              <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n            </li>\\n          </ul>\\n        </div>\\n      </div>\\n      <div class=\\\"keyboard-bottom\\\">\\n        <ul>\\n          <li @click=\\\"changepanel(panel===1?3:1)\\\" style=\\\"font-size: 14px;\\\">{{panel===1?'abc':'123'}}\\n          </li>\\n          <li v-for=\\\"item in keyBottomSym\\\"\\n              @click=\\\"item.v==='hide'?keyhide():insertar(item.v)\\\"\\n              @touchstart=\\\"item.t = true\\\"\\n              @touchend=\\\"item.t = false\\\"\\n              :style=\\\"{'background-color':item.t?'#bababa':'#F7F7F7'}\\\">\\n            <div class=\\\"letter-shade\\\"></div>\\n            <img :src=\\\"item.i\\\" v-if=\\\"item.i\\\"/>{{item.k}}\\n          </li>\\n        </ul>\\n      </div>\\n    </div>\\n\\n\\n  </div>\\n</template>\\n\\n<script>\\n    import \\\"mathquill/build/mathquill\\\";\\n    import img from './img.js'\\n    import {setTimeout, clearTimeout} from 'timers';\\n\\n    export default {\\n        name: \\\"math-keyboard\\\",\\n        data() {\\n            return {\\n                img: img,\\n                mathField: null,\\n                mathview: 'mathview' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\\n                mathinput: 'mathinput',\\n                panel: this.keypanel,\\n                capsletter: 'letter',\\n                keyabc: {\\n                    'letter': [\\n                        [\\n                            {k: 'q', v: 'q', t: false},\\n                            {k: 'w', v: 'w', t: false},\\n                            {k: 'e', v: 'e', t: false},\\n                            {k: 'r', v: 'r', t: false},\\n                            {k: 't', v: 't', t: false},\\n                            {k: 'y', v: 'y', t: false},\\n                            {k: 'u', v: 'u', t: false},\\n                            {k: 'i', v: 'i', t: false},\\n                            {k: 'o', v: 'o', t: false},\\n                            {k: 'p', v: 'p', t: false},\\n                        ],\\n                        [\\n                            {k: 'a', v: 'a', t: false},\\n                            {k: 's', v: 's', t: false},\\n                            {k: 'd', v: 'd', t: false},\\n                            {k: 'f', v: 'f', t: false},\\n                            {k: 'g', v: 'g', t: false},\\n                            {k: 'h', v: 'h', t: false},\\n                            {k: 'j', v: 'j', t: false},\\n                            {k: 'k', v: 'k', t: false},\\n                            {k: 'l', v: 'l', t: false},\\n                        ],\\n                        [\\n                            {k: '', v: 'shift', i: img.shift, s: false},\\n                            {k: 'z', v: 'z', t: false},\\n                            {k: 'x', v: 'x', t: false},\\n                            {k: 'c', v: 'c', t: false},\\n                            {k: 'v', v: 'v', t: false},\\n                            {k: 'b', v: 'b', t: false},\\n                            {k: 'n', v: 'n', t: false},\\n                            {k: 'm', v: 'm', t: false},\\n                            {k: '', v: 'Backspace', i: img.back, t: false},\\n                        ]\\n                    ],\\n                    'caps': [\\n                        [\\n                            {k: 'Q', v: 'Q', t: false},\\n                            {k: 'W', v: 'W', t: false},\\n                            {k: 'E', v: 'E', t: false},\\n                            {k: 'R', v: 'R', t: false},\\n                            {k: 'T', v: 'T', t: false},\\n                            {k: 'Y', v: 'Y', t: false},\\n                            {k: 'U', v: 'U', t: false},\\n                            {k: 'I', v: 'I', t: false},\\n                            {k: 'O', v: 'O', t: false},\\n                            {k: 'P', v: 'P', t: false},\\n                        ],\\n                        [\\n                            {k: 'A', v: 'A', t: false},\\n                            {k: 'S', v: 'S', t: false},\\n                            {k: 'D', v: 'D', t: false},\\n                            {k: 'F', v: 'F', t: false},\\n                            {k: 'G', v: 'G', t: false},\\n                            {k: 'H', v: 'H', t: false},\\n                            {k: 'J', v: 'J', t: false},\\n                            {k: 'K', v: 'K', t: false},\\n                            {k: 'L', v: 'L', t: false},\\n                        ],\\n                        [\\n                            {k: '', v: 'shift', i: img.dshift, s: true},\\n                            {k: 'Z', v: 'Z', t: false},\\n                            {k: 'X', v: 'X', t: false},\\n                            {k: 'C', v: 'C', t: false},\\n                            {k: 'V', v: 'V', t: false},\\n                            {k: 'B', v: 'B', t: false},\\n                            {k: 'N', v: 'N', t: false},\\n                            {k: 'M', v: 'M', t: false},\\n                            {k: '', v: 'Backspace', i: img.back, t: false},\\n                        ]\\n                    ]\\n                },\\n                keynum: [\\n                    {k: '1', v: '1', t: false},\\n                    {k: '2', v: '2', t: false},\\n                    {k: '3', v: '3', t: false},\\n                    {k: '4', v: '4', t: false},\\n                    {k: '5', v: '5', t: false},\\n                    {k: '6', v: '6', t: false},\\n                    {k: '7', v: '7', t: false},\\n                    {k: '8', v: '8', t: false},\\n                    {k: '9', v: '9', t: false},\\n                    {k: '0', v: '0', t: false},\\n                    {k: '.', v: '.', t: false},\\n                ],\\n                keysym: [\\n                    {k: '', v: '\\\\\\\\nthroot', i: img.raiz, t: false},\\n                    {k: '', v: '\\\\\\\\sqrt', i: img.raiz2, t: false},\\n                    {k: '', v: '^', i: img.potencia, t: false},\\n                    {k: '', v: '^2', i: img.cuadrado, t: false},\\n                    {k: '', v: '|', i: img.abs, t: false},\\n                    {k: '', v: '/', i: img.fraccion, t: false},\\n                    {k: '', v: '\\\\\\\\pi', i: img._pi, t: false},\\n                    {k: '', v: '或', i: img.or, t: false},\\n                    // {k: '', v: '^3', i: img.tercera},\\n                    // {k: '(', v: '(', i: ''},\\n                    // {k: ')', v: ')', i: ''},\\n                    // {k: '[', v: '[', i: ''},\\n                    // {k: ']', v: ']', i: ''},\\n                    // {k: 'sin', v: '\\\\\\\\sin', i: ''},\\n                    // {k: 'cos', v: '\\\\\\\\cos', i: ''},\\n                    // {k: 'tan', v: '\\\\\\\\tan', i: ''},\\n                    // {k: '≈', v: '\\\\\\\\approx', i: ''},\\n                    // {k: '≠', v: '\\\\\\\\neq', i: ''},\\n                    // {k: '%', v: '%', i: ''},\\n                    // {k: '', v: '-', i: img.subtract},\\n                    // {k: '', v: '+', i: img.plus},\\n                    // {k: '×', v: '\\\\\\\\times', i: ''},\\n                    // {k: '÷', v: '\\\\\\\\div', i: ''},\\n                    // {k: '', v: '±', i: img.union},\\n                    // {k: ',', v: ',', i: ''},\\n                    // {k: ':', v: ':', i: ''},\\n                    // {k: '°', v: '\\\\\\\\degree', i: ''},\\n                    // {k: '且', v: '且', i: ''},\\n                    // {k: '非', v: '非', i: ''},\\n                    // {k: 'x', v: 'x', i: ''},\\n                    // {k: 'y', v: 'y', i: ''},\\n                    // {k: '∑', v: '\\\\\\\\sum', i: ''},\\n                    // {k: '向量', v: '\\\\\\\\overrightarrow', i: ''},\\n                    // {k: '∠', v: '∠', i: ''},\\n                    // {k: '∵', v: '\\\\\\\\because', i: ''},\\n                    // {k: '∴', v: '\\\\\\\\therefore', i: ''},\\n                    // {k: '∈', v: '\\\\\\\\in', i: ''},\\n                    // {k: '∉', v: '\\\\\\\\notin', i: ''},\\n                    // {k: '∩', v: '\\\\\\\\intersection', i: ''},\\n                    // {k: '∪', v: '\\\\\\\\cup', i: ''},\\n                    // {k: '⊂', v: '\\\\\\\\subset', i: ''},\\n                    // {k: '⊃', v: '\\\\\\\\superset', i: ''},\\n                    // {k: '∞', v: '\\\\\\\\infty', i: ''},\\n                    // {k: 'log', v: '\\\\\\\\log', i: ''},\\n                    // {k: '←', v: '\\\\\\\\leftarrow', i: ''},\\n                    // {k: '→', v: '\\\\\\\\rightarrow', i: ''},\\n                    // {k: '⇔', v: '\\\\\\\\iff', i: ''}\\n                ],\\n                keyBottomSym: [\\n                    // {k: '', v: 'abc', i: img.abc},\\n                    {k: '', v: 'hide', i: img.hide, t: false},\\n                    {k: '', v: '<', i: img.less_than, t: false},\\n                    {k: '', v: '>', i: img.more_than, t: false},\\n                    {k: '', v: '\\\\\\\\leq', i: img.less_equals, t: false},\\n                    {k: '', v: '\\\\\\\\geq', i: img.more_equals, t: false},\\n\\n                ],\\n                keyboardRight: [\\n                    {k: '', v: '-', i: img.subtract, t: false},\\n                    {k: '', v: '+', i: img.plus, t: false},\\n                    {k: '', v: '±', i: img.union, t: false}\\n                ],\\n                latex: this.value,\\n                keyshow: this.show,\\n                keyorwrite: 1,\\n                cursorx: 0,\\n                cursory: 0,\\n                timer: null,\\n                interval: null\\n            };\\n        },\\n        props: {\\n            show: Boolean,\\n            value: String,\\n            keypanel: {\\n                type: Number,\\n                default: 1\\n            },\\n            ctrl: {\\n                type: Number,\\n                default: 0\\n            },\\n            output: String,\\n        },\\n        mounted() {\\n            var that = this;\\n            var mathFieldSpan = document.getElementById(this.mathinput);\\n\\n            var MQ = MathQuill.getInterface(2);\\n            var mathField = that.mathField = MQ.MathField(mathFieldSpan, {\\n                spaceBehavesLikeTab: true,\\n                leftRightIntoCmdGoes: 'up',\\n                restrictMismatchedBrackets: true,\\n                sumStartsWithNEquals: true,\\n                supSubsRequireOperand: true,\\n                autoSubscriptNumerals: true,\\n                autoOperatorNames: 'sin COMMA',\\n                handlers: {\\n                    edit: function (mathField) {\\n                        that.$emit('update:value', mathField.latex());\\n                        //显示光标\\n                        const controller = mathField.__controller;\\n                        controller.cursor.show();\\n                        controller.blurred = false;\\n                    }\\n                }\\n            });\\n\\n            that.mathField.latex(that.value);\\n\\n            window.onresize = function () {\\n                var content = $('#mathinput .mq-root-block');\\n                content.scrollLeft(content[0].scrollWidth)\\n            };\\n        },\\n        methods: {\\n            /**\\n             * 插入符号\\n             * @param valor\\n             */\\n            insertar(valor) {\\n                var that = this;\\n                if (valor.includes(\\\"^2\\\") || valor.includes(\\\"^3\\\")) {\\n                    that.mathField.write(valor);\\n                } else if (valor === 'Backspace') {\\n                    that.mathField.keystroke(valor);\\n                } else {\\n                    that.mathField.cmd(valor);\\n                }\\n\\n            },\\n            /**\\n             * 键盘布局切换\\n             * @param val\\n             */\\n            changepanel(val) {\\n                this.panel = val;\\n                this.$emit('update:keypanel', val);\\n                let keyboardDiv = document.getElementById('keyboard');\\n                let height = window.getComputedStyle(keyboardDiv).getPropertyValue(\\\"height\\\");\\n                console.log(height);\\n                try {\\n                    $App.keyboardHeight(height);\\n                } catch (e) {\\n                }\\n            },\\n            /**\\n             * 字母大小写切换\\n             */\\n            caps() {\\n                if (this.capsletter === 'letter') {\\n                    this.capsletter = 'caps'\\n                } else {\\n                    this.capsletter = 'letter'\\n                }\\n            },\\n            /**\\n             * 键盘隐藏\\n             * @param event\\n             */\\n            keyhide(event) {\\n                this.$emit('update:show', false);\\n                this.$emit('update:output', this.value);\\n                $App.hideKeyboard();\\n            },\\n            cursorLeft(event) {\\n                this.mathField.keystroke(\\\"Left\\\");\\n                this.cursorx = event.changedTouches[0].clientX;\\n                console.log(\\\"Left\\\")\\n            },\\n            cursorRight(event) {\\n                this.mathField.keystroke(\\\"Right\\\");\\n                this.cursorx = event.changedTouches[0].clientX;\\n                console.log(\\\"Right\\\")\\n            },\\n            cursorUp(event) {\\n                var _this = this\\n            },\\n            cursorDown(event) {\\n                var _this = this;\\n                _this.cursorx = event.changedTouches[0].clientX;\\n                _this.cursory = event.changedTouches[0].clientY;\\n            },\\n            cursorMove(event) {\\n                var x = this.cursorx - event.changedTouches[0].clientX;\\n                var y = this.cursory - event.changedTouches[0].clientY;\\n\\n                if (x > 10) {\\n                    this.mathField.keystroke(\\\"Left\\\");\\n                    this.cursorx = event.changedTouches[0].clientX;\\n                    console.log(\\\"Left\\\")\\n                }\\n\\n                if (x < -10) {\\n                    this.mathField.keystroke(\\\"Right\\\");\\n                    this.cursorx = event.changedTouches[0].clientX;\\n                    console.log(\\\"Right\\\")\\n                }\\n\\n                if (y > 10) {\\n                    this.mathField.keystroke(\\\"Up\\\");\\n                    this.cursory = event.changedTouches[0].clientY;\\n                    console.log(\\\"Up\\\")\\n                }\\n\\n                if (y < -10) {\\n                    this.mathField.keystroke(\\\"Down\\\");\\n                    this.cursory = event.changedTouches[0].clientY;\\n                    console.log(\\\"Down\\\")\\n                }\\n\\n            },\\n\\n            backDown(val) {\\n                var _this = this;\\n                if (val === 'Backspace') {\\n                    _this.timer = setTimeout(function () {\\n                        _this.interval = setInterval(function () {\\n                            _this.mathField.keystroke('Backspace')\\n                        }, 100)\\n                    }, 500)\\n                }\\n\\n            },\\n            backUp(val) {\\n                if (val === 'Backspace') {\\n                    this.mathField.keystroke('Backspace');\\n                    clearTimeout(this.timer);\\n                    clearInterval(this.interval)\\n                }\\n            }\\n        },\\n        watch: {\\n            value(nval, oval) {\\n                if (!this.show) {\\n                    this.mathField.latex(this.value)\\n                }\\n\\n                var content = $('#mathinput .mq-root-block');\\n                content.scrollLeft(content[0].scrollWidth)\\n            },\\n            ctrl(nval, oval) {\\n                this.$emit('update:ctrl', nval)\\n                // this.keyhide()\\n                // console.log('ctrl'+nval)\\n            },\\n        }\\n    };\\n<\/script>\\n\\n\x3c!-- Add \\\"scoped\\\" attribute to limit CSS to this component only --\x3e\\n<style scoped>\\n  * {\\n    box-sizing: content-box !important;\\n  }\\n\\n  #mathinput {\\n    margin: 3px;\\n    background: #fff;\\n    border: 2px solid #0099FF;\\n    border-radius: 4px;\\n    width: 65%\\n  }\\n\\n  .keyboard {\\n    margin-top: -8px;\\n    width: auto;\\n    position: fixed;\\n    padding-bottom: 4px;\\n    left: 0;\\n    background-color: #F1F1F1;\\n    z-index: 16777271;\\n    transition: all 0.5s;\\n  }\\n\\n  .keyboard-output {\\n    width: calc(100% - 4px);\\n    position: relative;\\n    padding: 2px;\\n    background-color: #fff;\\n  }\\n\\n  .left-right {\\n    position: absolute;\\n    display: block;\\n    margin-left: calc(65% + 15px);\\n    top: 50%;\\n    transform: translateY(-50%);\\n  }\\n\\n  .left-right img {\\n    width: 15px;\\n    height: 15px;\\n  }\\n\\n  .keyboard-output > a {\\n    display: block;\\n    text-decoration: none;\\n    line-height: 40px;\\n    width: 42px;\\n    text-align: center;\\n    background-color: #fff;\\n    color: #2e7bfd;\\n    font-size: 15px;\\n    position: absolute;\\n    right: 2px;\\n    top: 50%;\\n    transform: translateY(-50%);\\n  }\\n\\n  @-webkit-keyframes van-circular {\\n    0% {\\n      stroke-dasharray: 1, 200;\\n      stroke-dashoffset: 0;\\n    }\\n    50% {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -40;\\n    }\\n    to {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -120;\\n    }\\n  }\\n\\n  @keyframes van-circular {\\n    0% {\\n      stroke-dasharray: 1, 200;\\n      stroke-dashoffset: 0;\\n    }\\n    50% {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -40;\\n    }\\n    to {\\n      stroke-dasharray: 90, 150;\\n      stroke-dashoffset: -120;\\n    }\\n  }\\n\\n  .keyboard-panel-letter {\\n    width: 100vw;\\n    position: center;\\n  }\\n\\n  .keyboard-bottom {\\n    position: center;\\n  }\\n\\n\\n  .keyboard-bottom li {\\n    background-color: #F7F7F7;\\n    margin-left: 4px;\\n    margin-top: 4px;\\n    width: calc((100vw - 28px) / 6);\\n  }\\n\\n  .keyboard-bottom li:nth-child(5) {\\n    width: calc((100vw - 28px) / 6 - 2px);\\n  }\\n\\n  .keyboard-panel .letter-row {\\n    margin-top: 5px;\\n    height: 42px;\\n    width: 100%;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(3) li:first-child {\\n    width: calc((300vw - 97px) / 20);\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(3) li:last-child {\\n    width: calc((300vw - 97px) / 20);\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:first-child {\\n    width: calc((100vw - 19px) / 4);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:last-child {\\n    width: calc((100vw - 19px) / 4);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:nth-child(2) {\\n    width: calc((100vw - 49px) / 10);\\n    font-size: 15px;\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-panel-letter .letter-row:nth-child(4) li:nth-child(3) {\\n    width: calc(2 * (100vw - 49px) / 5 + 15px);\\n    font-size: 15px;\\n    /* background-color: #F7F7F7 */\\n  }\\n\\n  .keyboard-panel-letter ul {\\n    position: relative;\\n    left: 50%;\\n    transform: translateX(-50%);\\n  }\\n\\n  .keyboard-panel-default {\\n    float: left;\\n    margin: 4px 4px 0 4px;\\n  }\\n\\n  .keyboard-panel ul {\\n    margin: 0;\\n    padding: 0;\\n    float: left;\\n  }\\n\\n  .keyboard-panel ul li {\\n    list-style: none;\\n    height: 42px;\\n    line-height: 42px;\\n    text-align: center;\\n    float: left;\\n    border-radius: 5px;\\n    -moz-user-select: none;\\n    -webkit-user-select: none;\\n    font-size: 20px;\\n    color: #0d0d0d;\\n    position: relative;\\n  }\\n\\n  .letter-shade {\\n    width: 100%;\\n    height: 100%;\\n    position: absolute;\\n    z-index: 1;\\n  }\\n\\n  .keyboard-panel-letter ul li {\\n    width: calc((100vw - 49px) / 10);\\n    margin-right: 5px;\\n    background-color: #fff;\\n  }\\n\\n  .keyboard-panel-letter ul li:last-child {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-panel-default ul li {\\n    width: calc((100vw - 29px) / 6);\\n    margin-top: 4px;\\n  }\\n\\n  .keyboard-default-symbol {\\n    width: calc((100vw - 16px) / 3);\\n    margin-right: 4px;\\n    float: left;\\n  }\\n\\n  .keyboard-default-symbol > ul {\\n    background-color: #F7F7F7;\\n    border-radius: 5px;\\n  }\\n\\n  .keyboard-default-symbol ul li:nth-child(2n) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-symbol > ul li:nth-child(1) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-symbol > ul li:nth-child(2) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-panel li img {\\n    top: 50%;\\n    transform: translate(-50%, -50%);\\n    max-height: 42px;\\n    position: absolute;\\n    z-index: 0;\\n    left: 50%;\\n  }\\n\\n  .keyboard-default-symbol-bottom ul li {\\n    background-color: #F1F1F1;\\n    font-size: 15px;\\n  }\\n\\n  .keyboard-default-num {\\n    width: calc((100vw - 16px) / 2);\\n    float: left;\\n    margin-right: 4px;\\n  }\\n\\n  .keyboard-default-num ul li {\\n    background-color: #fff;\\n    margin-right: 4px;\\n    width: calc(((100vw - 20px) / 2 - 8px) / 3);\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(1) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(2) {\\n    margin-top: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(3) {\\n    margin-top: 0;\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(6) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(9) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(11) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-default-num ul li:nth-child(10) {\\n    width: calc((100vw - 28px) / 3 + 3px);\\n  }\\n\\n  .keyboard-default-right {\\n    width: calc((100vw - 16px) / 6 - 2px);\\n    float: right;\\n    background-color: #F7F7F7;\\n    border-radius: 4px;\\n  }\\n\\n  .keyboard-default-right ul li {\\n    background-color: #F7F7F7;\\n  }\\n\\n  .keyboard-symbol-left > ul {\\n    height: 146px;\\n    overflow-y: scroll;\\n    background-color: #F7F7F7;\\n    border-radius: 5px;\\n  }\\n\\n  .keyboard-panel-symbol ul li {\\n    width: calc((100vw - 29px) / 6);\\n    margin-top: 10px;\\n    margin-right: 5px;\\n  }\\n\\n  .keyboard-symbol-left ul li:nth-child(5n) {\\n    margin-right: 0;\\n  }\\n\\n  .keyboard-symbol-left .keyboard-default-symbol-bottom ul li:nth-child(3) {\\n    width: calc((100vw - 9px) / 2);\\n    margin-right: 0;\\n    background-color: #fff;\\n  }\\n\\n  .keyboard-func img {\\n    height: 36px;\\n  }\\n\\n  .keyboard-func-icon:last-child img {\\n    height: 28px;\\n    margin-top: 4px;\\n  }\\n\\n</style>\\n\\n<style>\\n  .keyboard textarea {\\n    display: none !important;\\n  }\\n\\n  .mathview textarea {\\n    display: none !important;\\n  }\\n\\n\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2tleWJvYXJkLnZ1ZT81Njg3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQStDO0FBQ2xGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUyx5QkFBeUIsNkJBQTZCLEdBQUcsc0JBQXNCLDZCQUE2QixHQUFHLGNBQWMseUdBQXlHLE9BQU8sV0FBVyxLQUFLLEtBQUssV0FBVyw4cEJBQThwQiwwQ0FBMEMsc1VBQXNVLDhDQUE4Qyw2R0FBNkcsUUFBUSxrVUFBa1UsMkNBQTJDLG1CQUFtQixRQUFRLGlRQUFpUSxzUUFBc1EsOENBQThDLDZHQUE2RyxRQUFRLDhwQkFBOHBCLCtDQUErQyxJQUFJLCtDQUErQyxHQUFHLCtDQUErQywySEFBMkgsUUFBUSxxTUFBcU0sS0FBSyx1QkFBdUIsdVBBQXVQLDhDQUE4Qyx5R0FBeUcsUUFBUSw0SUFBNEksOENBQThDLHlCQUF5QixlQUFlLHdCQUF3QixvREFBb0Qsc0JBQXNCLHFUQUFxVCwyRkFBMkYseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLHVGQUF1Rix5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLHVGQUF1RiwwQ0FBMEMsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MseUJBQXlCLGdDQUFnQyx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0MsNkNBQTZDLDZJQUE2SSx5QkFBeUIsZ0NBQWdDLHlCQUF5QixnQ0FBZ0Ms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S0FBSyxnREFBZ0Qsc0JBQXNCLEtBQUssaURBQWlELHNCQUFzQixLQUFLLGlEQUFpRCw0Q0FBNEMsS0FBSywrQkFBK0IsNENBQTRDLG1CQUFtQixnQ0FBZ0MseUJBQXlCLEtBQUsscUNBQXFDLGdDQUFnQyxLQUFLLGtDQUFrQyxvQkFBb0IseUJBQXlCLGdDQUFnQyx5QkFBeUIsS0FBSyxvQ0FBb0Msc0NBQXNDLHVCQUF1Qix3QkFBd0IsS0FBSyxpREFBaUQsc0JBQXNCLEtBQUssZ0ZBQWdGLHFDQUFxQyxzQkFBc0IsNkJBQTZCLEtBQUssMEJBQTBCLG1CQUFtQixLQUFLLDBDQUEwQyxtQkFBbUIsc0JBQXNCLEtBQUssK0NBQStDLCtCQUErQixLQUFLLDBCQUEwQiwrQkFBK0IsS0FBSyxtQ0FBbUM7O0FBRXZreUIiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmtleWJvYXJkIHRleHRhcmVhIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLm1hdGh2aWV3IHRleHRhcmVhIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkU6L215Z2l0aHViL21hdGgta2V5Ym9hcmQvc3JjL2xpYi9zcmMvbGliL2tleWJvYXJkLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBbXdCQTtFQUNBLHlCQUFBO0NBQ0E7QUFFQTtFQUNBLHlCQUFBO0NBQ0FcIixcImZpbGVcIjpcImtleWJvYXJkLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZFxcXCIgaWQ9XFxcImtleWJvYXJkXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtb3V0cHV0XFxcIj5cXG4gICAgICA8c3BhbiA6aWQ9XFxcIm1hdGhpbnB1dFxcXCJcXG4gICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiY3Vyc29yRG93bigkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIEB0b3VjaG1vdmU9XFxcImN1cnNvck1vdmUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICBAdG91Y2h1cD1cXFwiY3Vyc29yVXAoJGV2ZW50KVxcXCI+XFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxlZnQtcmlnaHRcXFwiPlxcbiAgICAgICAgPGltZyA6c3JjPVxcXCJpbWcuY3Vyc29yX2xlZnRcXFwiIEBjbGljaz1cXFwiY3Vyc29yTGVmdCgkZXZlbnQpXFxcIi8+XFxuICAgICAgICA8aW1nIDpzcmM9XFxcImltZy5jdXJzb3JfcmlnaHRcXFwiIEBjbGljaz1cXFwiY3Vyc29yUmlnaHQoJGV2ZW50KVxcXCIgc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OiAyMHB4XFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGEgQGNsaWNrPVxcXCJrZXloaWRlKClcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMTUlXFxcIj7noa7lrpo8L2E+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZC1wYW5lbFxcXCJcXG4gICAgICAgICA6c3R5bGU9XFxcIntkaXNwbGF5OmtleW9yd3JpdGUgPT09IDEgPyAndW5zZXQnOidub25lJ31cXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkLXBhbmVsLWRlZmF1bHRcXFwiIHYtaWY9XFxcInBhbmVsID09PSAxXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkLWRlZmF1bHQtc3ltYm9sXFxcIj5cXG4gICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiaXRlbSBpbiBrZXlzeW1cXFwiIEBjbGljaz1cXFwiaW5zZXJ0YXIoaXRlbS52KVxcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoc3RhcnQ9XFxcIml0ZW0udCA9IHRydWVcXFwiXFxuICAgICAgICAgICAgICAgIEB0b3VjaGVuZD1cXFwiaXRlbS50ID0gZmFsc2VcXFwiXFxuICAgICAgICAgICAgICAgIDpzdHlsZT1cXFwieydiYWNrZ3JvdW5kLWNvbG9yJzppdGVtLnQ/JyNiYWJhYmEnOicjRjdGN0Y3J31cXFwiPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGV0dGVyLXNoYWRlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxpbWcgOnNyYz1cXFwiaXRlbS5pXFxcIiB2LWlmPVxcXCJpdGVtLmlcXFwiLz57e2l0ZW0ua319XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtZGVmYXVsdC1udW1cXFwiPlxcbiAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCJpdGVtIGluIGtleW51bVxcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJpbnNlcnRhcihpdGVtLnYpXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiaXRlbS50ID0gdHJ1ZVxcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoZW5kPVxcXCJpdGVtLnQgPSBmYWxzZVxcXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVxcXCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNmZmYnfVxcXCJcXG4gICAgICAgICAgICA+e3tpdGVtLmt9fVxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImtleWJvYXJkLWRlZmF1bHQtcmlnaHRcXFwiPlxcbiAgICAgICAgICA8dWw+XFxuICAgICAgICAgICAgPGxpIEB0b3VjaHN0YXJ0PVxcXCJiYWNrRG93bignQmFja3NwYWNlJylcXFwiIEB0b3VjaGVuZD1cXFwiYmFja1VwKCdCYWNrc3BhY2UnKVxcXCJcXG4gICAgICAgICAgICAgICAgc3R5bGU9XFxcImJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7bWFyZ2luLXRvcDogMHB4XFxcIj48aW1nIDpzcmM9XFxcImltZy5iYWNrXFxcIi8+PC9saT5cXG4gICAgICAgICAgICA8bGkgdi1mb3I9XFxcIml0ZW0gaW4ga2V5Ym9hcmRSaWdodFxcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCJpbnNlcnRhcihpdGVtLnYpXFxcIlxcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cXFwiaXRlbS50ID0gdHJ1ZVxcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoZW5kPVxcXCJpdGVtLnQgPSBmYWxzZVxcXCJcXG4gICAgICAgICAgICAgICAgOnN0eWxlPVxcXCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVxcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXR0ZXItc2hhZGVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGltZyA6c3JjPVxcXCJpdGVtLmlcXFwiIHYtaWY9XFxcIml0ZW0uaVxcXCIvPnt7aXRlbS5rfX1cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwia2V5Ym9hcmQtcGFuZWwtbGV0dGVyXFxcIiB2LWlmPVxcXCJwYW5lbCA9PT0gM1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXR0ZXItcm93XFxcIiB2LWZvcj1cXFwiaXRlbXMgaW4ga2V5YWJjW2NhcHNsZXR0ZXJdXFxcIj5cXG4gICAgICAgICAgPHVsPlxcbiAgICAgICAgICAgIDxsaSB2LWZvcj1cXFwiaXRlbSBpbiBpdGVtc1xcXCJcXG4gICAgICAgICAgICAgICAgQGNsaWNrPVxcXCIoaXRlbS52ICE9PSAnc2hpZnQnID8gKGl0ZW0udiAhPT0gJ0JhY2tzcGFjZScgPyBpbnNlcnRhcihpdGVtLnYpIDogJycpIDogY2FwcygpKVxcXCJcXG4gICAgICAgICAgICAgICAgQHRvdWNoc3RhcnQ9XFxcIml0ZW0udCA9IHRydWUsYmFja0Rvd24oaXRlbS52KSxpdGVtLnYgPT09ICdCYWNrc3BhY2UnID8gaXRlbS5pID0gaW1nLmRiYWNrIDogJydcXFwiXFxuICAgICAgICAgICAgICAgIEB0b3VjaGVuZD1cXFwiaXRlbS50ID0gZmFsc2UsYmFja1VwKGl0ZW0udiksaXRlbS52ID09PSAnQmFja3NwYWNlJyA/IGl0ZW0uaSA9IGltZy5iYWNrIDogJydcXFwiXFxuICAgICAgICAgICAgICAgIDpzdHlsZT1cXFwiaXRlbS52ICE9PSAnc2hpZnQnID8gaXRlbS52ICE9PSAnQmFja3NwYWNlJyA/IHsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50ID8gJyNiYWJhYmEnIDogJyNmZmYnfSA6IHsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50ID8gJyNmZmYnIDogJyNGN0Y3RjcnfSA6eydiYWNrZ3JvdW5kLWNvbG9yJzppdGVtLnMgPyAnI2ZmZicgOiAnI0Y3RjdGNyd9XFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldHRlci1zaGFkZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8aW1nIDpzcmM9XFxcIml0ZW0uaVxcXCIgdi1pZj1cXFwiaXRlbS5pXFxcIi8+e3tpdGVtLmt9fVxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJrZXlib2FyZC1ib3R0b21cXFwiPlxcbiAgICAgICAgPHVsPlxcbiAgICAgICAgICA8bGkgQGNsaWNrPVxcXCJjaGFuZ2VwYW5lbChwYW5lbD09PTE/MzoxKVxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZTogMTRweDtcXFwiPnt7cGFuZWw9PT0xPydhYmMnOicxMjMnfX1cXG4gICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPGxpIHYtZm9yPVxcXCJpdGVtIGluIGtleUJvdHRvbVN5bVxcXCJcXG4gICAgICAgICAgICAgIEBjbGljaz1cXFwiaXRlbS52PT09J2hpZGUnP2tleWhpZGUoKTppbnNlcnRhcihpdGVtLnYpXFxcIlxcbiAgICAgICAgICAgICAgQHRvdWNoc3RhcnQ9XFxcIml0ZW0udCA9IHRydWVcXFwiXFxuICAgICAgICAgICAgICBAdG91Y2hlbmQ9XFxcIml0ZW0udCA9IGZhbHNlXFxcIlxcbiAgICAgICAgICAgICAgOnN0eWxlPVxcXCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGV0dGVyLXNoYWRlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8aW1nIDpzcmM9XFxcIml0ZW0uaVxcXCIgdi1pZj1cXFwiaXRlbS5pXFxcIi8+e3tpdGVtLmt9fVxcbiAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuXFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuICAgIGltcG9ydCBcXFwibWF0aHF1aWxsL2J1aWxkL21hdGhxdWlsbFxcXCI7XFxuICAgIGltcG9ydCBpbWcgZnJvbSAnLi9pbWcuanMnXFxuICAgIGltcG9ydCB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSBmcm9tICd0aW1lcnMnO1xcblxcbiAgICBleHBvcnQgZGVmYXVsdCB7XFxuICAgICAgICBuYW1lOiBcXFwibWF0aC1rZXlib2FyZFxcXCIsXFxuICAgICAgICBkYXRhKCkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBtYXRoRmllbGQ6IG51bGwsXFxuICAgICAgICAgICAgICAgIG1hdGh2aWV3OiAnbWF0aHZpZXcnICsgcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqICg5OTk5OTkgLSAxMDAwMDAgKyAxKSArIDEwMDAwMCwgMTApLFxcbiAgICAgICAgICAgICAgICBtYXRoaW5wdXQ6ICdtYXRoaW5wdXQnLFxcbiAgICAgICAgICAgICAgICBwYW5lbDogdGhpcy5rZXlwYW5lbCxcXG4gICAgICAgICAgICAgICAgY2Fwc2xldHRlcjogJ2xldHRlcicsXFxuICAgICAgICAgICAgICAgIGtleWFiYzoge1xcbiAgICAgICAgICAgICAgICAgICAgJ2xldHRlcic6IFtcXG4gICAgICAgICAgICAgICAgICAgICAgICBbXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAncScsIHY6ICdxJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3cnLCB2OiAndycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdlJywgdjogJ2UnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAncicsIHY6ICdyJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3QnLCB2OiAndCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd5JywgdjogJ3knLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAndScsIHY6ICd1JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2knLCB2OiAnaScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdvJywgdjogJ28nLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAncCcsIHY6ICdwJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2EnLCB2OiAnYScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdzJywgdjogJ3MnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnZCcsIHY6ICdkJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2YnLCB2OiAnZicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdnJywgdjogJ2cnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaCcsIHY6ICdoJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ2onLCB2OiAnaicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdrJywgdjogJ2snLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbCcsIHY6ICdsJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdzaGlmdCcsIGk6IGltZy5zaGlmdCwgczogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3onLCB2OiAneicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd4JywgdjogJ3gnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnYycsIHY6ICdjJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ3YnLCB2OiAndicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdiJywgdjogJ2InLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbicsIHY6ICduJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ20nLCB2OiAnbScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnQmFja3NwYWNlJywgaTogaW1nLmJhY2ssIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBdXFxuICAgICAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICAgICAgJ2NhcHMnOiBbXFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1EnLCB2OiAnUScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdXJywgdjogJ1cnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnRScsIHY6ICdFJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1InLCB2OiAnUicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdUJywgdjogJ1QnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnWScsIHY6ICdZJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1UnLCB2OiAnVScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdJJywgdjogJ0knLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnTycsIHY6ICdPJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1AnLCB2OiAnUCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdBJywgdjogJ0EnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUycsIHY6ICdTJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0QnLCB2OiAnRCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdGJywgdjogJ0YnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnRycsIHY6ICdHJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0gnLCB2OiAnSCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdKJywgdjogJ0onLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnSycsIHY6ICdLJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0wnLCB2OiAnTCcsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnc2hpZnQnLCBpOiBpbWcuZHNoaWZ0LCBzOiB0cnVlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdaJywgdjogJ1onLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnWCcsIHY6ICdYJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0MnLCB2OiAnQycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdWJywgdjogJ1YnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnQicsIHY6ICdCJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ04nLCB2OiAnTicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdNJywgdjogJ00nLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ0JhY2tzcGFjZScsIGk6IGltZy5iYWNrLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxcbiAgICAgICAgICAgICAgICAgICAgXVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBrZXludW06IFtcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnMScsIHY6ICcxJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcyJywgdjogJzInLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzMnLCB2OiAnMycsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnNCcsIHY6ICc0JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc1JywgdjogJzUnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzYnLCB2OiAnNicsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnNycsIHY6ICc3JywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc4JywgdjogJzgnLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJzknLCB2OiAnOScsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnMCcsIHY6ICcwJywgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcuJywgdjogJy4nLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIGtleXN5bTogW1xcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXFxcXFxcXFxudGhyb290JywgaTogaW1nLnJhaXosIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxcXFxcc3FydCcsIGk6IGltZy5yYWl6MiwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXicsIGk6IGltZy5wb3RlbmNpYSwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXjInLCBpOiBpbWcuY3VhZHJhZG8sIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ3wnLCBpOiBpbWcuYWJzLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICcvJywgaTogaW1nLmZyYWNjaW9uLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdcXFxcXFxcXHBpJywgaTogaW1nLl9waSwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAn5oiWJywgaTogaW1nLm9yLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICdeMycsIGk6IGltZy50ZXJjZXJhfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnKCcsIHY6ICcoJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcpJywgdjogJyknLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ1snLCB2OiAnWycsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnXScsIHY6ICddJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICdzaW4nLCB2OiAnXFxcXFxcXFxzaW4nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ2NvcycsIHY6ICdcXFxcXFxcXGNvcycsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAndGFuJywgdjogJ1xcXFxcXFxcdGFuJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiYgnLCB2OiAnXFxcXFxcXFxhcHByb3gnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KJoCcsIHY6ICdcXFxcXFxcXG5lcScsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJScsIHY6ICclJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcnLCB2OiAnLScsIGk6IGltZy5zdWJ0cmFjdH0sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICcrJywgaTogaW1nLnBsdXN9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfDlycsIHY6ICdcXFxcXFxcXHRpbWVzJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfDtycsIHY6ICdcXFxcXFxcXGRpdicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJ8KxJywgaTogaW1nLnVuaW9ufSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnLCcsIHY6ICcsJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICc6JywgdjogJzonLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ8KwJywgdjogJ1xcXFxcXFxcZGVncmVlJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfkuJQnLCB2OiAn5LiUJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfpnZ4nLCB2OiAn6Z2eJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICd4JywgdjogJ3gnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ3knLCB2OiAneScsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oiRJywgdjogJ1xcXFxcXFxcc3VtJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICflkJHph48nLCB2OiAnXFxcXFxcXFxvdmVycmlnaHRhcnJvdycsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oigJywgdjogJ+KIoCcsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oi1JywgdjogJ1xcXFxcXFxcYmVjYXVzZScsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oi0JywgdjogJ1xcXFxcXFxcdGhlcmVmb3JlJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiIgnLCB2OiAnXFxcXFxcXFxpbicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oiJJywgdjogJ1xcXFxcXFxcbm90aW4nLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KIqScsIHY6ICdcXFxcXFxcXGludGVyc2VjdGlvbicsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oiqJywgdjogJ1xcXFxcXFxcY3VwJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiioInLCB2OiAnXFxcXFxcXFxzdWJzZXQnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KKgycsIHY6ICdcXFxcXFxcXHN1cGVyc2V0JywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiJ4nLCB2OiAnXFxcXFxcXFxpbmZ0eScsIGk6ICcnfSxcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnbG9nJywgdjogJ1xcXFxcXFxcbG9nJywgaTogJyd9LFxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfihpAnLCB2OiAnXFxcXFxcXFxsZWZ0YXJyb3cnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KGkicsIHY6ICdcXFxcXFxcXHJpZ2h0YXJyb3cnLCBpOiAnJ30sXFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KHlCcsIHY6ICdcXFxcXFxcXGlmZicsIGk6ICcnfVxcbiAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICBrZXlCb3R0b21TeW06IFtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJ2FiYycsIGk6IGltZy5hYmN9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnaGlkZScsIGk6IGltZy5oaWRlLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICc8JywgaTogaW1nLmxlc3NfdGhhbiwgdDogZmFsc2V9LFxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnPicsIGk6IGltZy5tb3JlX3RoYW4sIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxcXFxcbGVxJywgaTogaW1nLmxlc3NfZXF1YWxzLCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdcXFxcXFxcXGdlcScsIGk6IGltZy5tb3JlX2VxdWFscywgdDogZmFsc2V9LFxcblxcbiAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFJpZ2h0OiBbXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICctJywgaTogaW1nLnN1YnRyYWN0LCB0OiBmYWxzZX0sXFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICcrJywgaTogaW1nLnBsdXMsIHQ6IGZhbHNlfSxcXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ8KxJywgaTogaW1nLnVuaW9uLCB0OiBmYWxzZX1cXG4gICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgbGF0ZXg6IHRoaXMudmFsdWUsXFxuICAgICAgICAgICAgICAgIGtleXNob3c6IHRoaXMuc2hvdyxcXG4gICAgICAgICAgICAgICAga2V5b3J3cml0ZTogMSxcXG4gICAgICAgICAgICAgICAgY3Vyc29yeDogMCxcXG4gICAgICAgICAgICAgICAgY3Vyc29yeTogMCxcXG4gICAgICAgICAgICAgICAgdGltZXI6IG51bGwsXFxuICAgICAgICAgICAgICAgIGludGVydmFsOiBudWxsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBwcm9wczoge1xcbiAgICAgICAgICAgIHNob3c6IEJvb2xlYW4sXFxuICAgICAgICAgICAgdmFsdWU6IFN0cmluZyxcXG4gICAgICAgICAgICBrZXlwYW5lbDoge1xcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDFcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN0cmw6IHtcXG4gICAgICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBvdXRwdXQ6IFN0cmluZyxcXG4gICAgICAgIH0sXFxuICAgICAgICBtb3VudGVkKCkge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICAgICB2YXIgbWF0aEZpZWxkU3BhbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWF0aGlucHV0KTtcXG5cXG4gICAgICAgICAgICB2YXIgTVEgPSBNYXRoUXVpbGwuZ2V0SW50ZXJmYWNlKDIpO1xcbiAgICAgICAgICAgIHZhciBtYXRoRmllbGQgPSB0aGF0Lm1hdGhGaWVsZCA9IE1RLk1hdGhGaWVsZChtYXRoRmllbGRTcGFuLCB7XFxuICAgICAgICAgICAgICAgIHNwYWNlQmVoYXZlc0xpa2VUYWI6IHRydWUsXFxuICAgICAgICAgICAgICAgIGxlZnRSaWdodEludG9DbWRHb2VzOiAndXAnLFxcbiAgICAgICAgICAgICAgICByZXN0cmljdE1pc21hdGNoZWRCcmFja2V0czogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgc3VtU3RhcnRzV2l0aE5FcXVhbHM6IHRydWUsXFxuICAgICAgICAgICAgICAgIHN1cFN1YnNSZXF1aXJlT3BlcmFuZDogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgYXV0b1N1YnNjcmlwdE51bWVyYWxzOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBhdXRvT3BlcmF0b3JOYW1lczogJ3NpbiBDT01NQScsXFxuICAgICAgICAgICAgICAgIGhhbmRsZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBlZGl0OiBmdW5jdGlvbiAobWF0aEZpZWxkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC4kZW1pdCgndXBkYXRlOnZhbHVlJywgbWF0aEZpZWxkLmxhdGV4KCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5pi+56S65YWJ5qCHXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG1hdGhGaWVsZC5fX2NvbnRyb2xsZXI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jdXJzb3Iuc2hvdygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYmx1cnJlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgdGhhdC5tYXRoRmllbGQubGF0ZXgodGhhdC52YWx1ZSk7XFxuXFxuICAgICAgICAgICAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9ICQoJyNtYXRoaW5wdXQgLm1xLXJvb3QtYmxvY2snKTtcXG4gICAgICAgICAgICAgICAgY29udGVudC5zY3JvbGxMZWZ0KGNvbnRlbnRbMF0uc2Nyb2xsV2lkdGgpXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBtZXRob2RzOiB7XFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICog5o+S5YWl56ym5Y+3XFxuICAgICAgICAgICAgICogQHBhcmFtIHZhbG9yXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgaW5zZXJ0YXIodmFsb3IpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgICAgICAgICBpZiAodmFsb3IuaW5jbHVkZXMoXFxcIl4yXFxcIikgfHwgdmFsb3IuaW5jbHVkZXMoXFxcIl4zXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubWF0aEZpZWxkLndyaXRlKHZhbG9yKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxvciA9PT0gJ0JhY2tzcGFjZScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubWF0aEZpZWxkLmtleXN0cm9rZSh2YWxvcik7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1hdGhGaWVsZC5jbWQodmFsb3IpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiDplK7nm5jluIPlsYDliIfmjaJcXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgY2hhbmdlcGFuZWwodmFsKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFuZWwgPSB2YWw7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTprZXlwYW5lbCcsIHZhbCk7XFxuICAgICAgICAgICAgICAgIGxldCBrZXlib2FyZERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdrZXlib2FyZCcpO1xcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoa2V5Ym9hcmREaXYpLmdldFByb3BlcnR5VmFsdWUoXFxcImhlaWdodFxcXCIpO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhoZWlnaHQpO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgJEFwcC5rZXlib2FyZEhlaWdodChoZWlnaHQpO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIOWtl+avjeWkp+Wwj+WGmeWIh+aNolxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGNhcHMoKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHNsZXR0ZXIgPT09ICdsZXR0ZXInKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHNsZXR0ZXIgPSAnY2FwcydcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fwc2xldHRlciA9ICdsZXR0ZXInXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIOmUruebmOmakOiXj1xcbiAgICAgICAgICAgICAqIEBwYXJhbSBldmVudFxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGtleWhpZGUoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnNob3cnLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpvdXRwdXQnLCB0aGlzLnZhbHVlKTtcXG4gICAgICAgICAgICAgICAgJEFwcC5oaWRlS2V5Ym9hcmQoKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN1cnNvckxlZnQoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFxcXCJMZWZ0XFxcIik7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJMZWZ0XFxcIilcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN1cnNvclJpZ2h0KGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZShcXFwiUmlnaHRcXFwiKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3J4ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIlJpZ2h0XFxcIilcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN1cnNvclVwKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXNcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGN1cnNvckRvd24oZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgICAgICAgX3RoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnNvcnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY3Vyc29yTW92ZShldmVudCkge1xcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuY3Vyc29yeCAtIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5jdXJzb3J5IC0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHggPiAxMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFxcXCJMZWZ0XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkxlZnRcXFwiKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4IDwgLTEwKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXFxcIlJpZ2h0XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIlJpZ2h0XFxcIilcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoeSA+IDEwKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXFxcIlVwXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIlVwXFxcIilcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoeSA8IC0xMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFxcXCJEb3duXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkRvd25cXFwiKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICBiYWNrRG93bih2YWwpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJ0JhY2tzcGFjZScpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoJ0JhY2tzcGFjZScpXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKVxcbiAgICAgICAgICAgICAgICAgICAgfSwgNTAwKVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBiYWNrVXAodmFsKSB7XFxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICdCYWNrc3BhY2UnKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoJ0JhY2tzcGFjZScpO1xcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHdhdGNoOiB7XFxuICAgICAgICAgICAgdmFsdWUobnZhbCwgb3ZhbCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdykge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQubGF0ZXgodGhpcy52YWx1ZSlcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9ICQoJyNtYXRoaW5wdXQgLm1xLXJvb3QtYmxvY2snKTtcXG4gICAgICAgICAgICAgICAgY29udGVudC5zY3JvbGxMZWZ0KGNvbnRlbnRbMF0uc2Nyb2xsV2lkdGgpXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjdHJsKG52YWwsIG92YWwpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmN0cmwnLCBudmFsKVxcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmtleWhpZGUoKVxcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3RybCcrbnZhbClcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfVxcbiAgICB9O1xcbjwvc2NyaXB0PlxcblxcbjwhLS0gQWRkIFxcXCJzY29wZWRcXFwiIGF0dHJpYnV0ZSB0byBsaW1pdCBDU1MgdG8gdGhpcyBjb21wb25lbnQgb25seSAtLT5cXG48c3R5bGUgc2NvcGVkPlxcbiAgKiB7XFxuICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94ICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAjbWF0aGlucHV0IHtcXG4gICAgbWFyZ2luOiAzcHg7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkICMwMDk5RkY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gICAgd2lkdGg6IDY1JVxcbiAgfVxcblxcbiAgLmtleWJvYXJkIHtcXG4gICAgbWFyZ2luLXRvcDogLThweDtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgcGFkZGluZy1ib3R0b206IDRweDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YxRjFGMTtcXG4gICAgei1pbmRleDogMTY3NzcyNzE7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLW91dHB1dCB7XFxuICAgIHdpZHRoOiBjYWxjKDEwMCUgLSA0cHgpO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHBhZGRpbmc6IDJweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5sZWZ0LXJpZ2h0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgbWFyZ2luLWxlZnQ6IGNhbGMoNjUlICsgMTVweCk7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICB9XFxuXFxuICAubGVmdC1yaWdodCBpbWcge1xcbiAgICB3aWR0aDogMTVweDtcXG4gICAgaGVpZ2h0OiAxNXB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLW91dHB1dCA+IGEge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBsaW5lLWhlaWdodDogNDBweDtcXG4gICAgd2lkdGg6IDQycHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgY29sb3I6ICMyZTdiZmQ7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICByaWdodDogMnB4O1xcbiAgICB0b3A6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgfVxcblxcbiAgQC13ZWJraXQta2V5ZnJhbWVzIHZhbi1jaXJjdWxhciB7XFxuICAgIDAlIHtcXG4gICAgICBzdHJva2UtZGFzaGFycmF5OiAxLCAyMDA7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XFxuICAgIH1cXG4gICAgNTAlIHtcXG4gICAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtNDA7XFxuICAgIH1cXG4gICAgdG8ge1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xMjA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBrZXlmcmFtZXMgdmFuLWNpcmN1bGFyIHtcXG4gICAgMCUge1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEsIDIwMDtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogMDtcXG4gICAgfVxcbiAgICA1MCUge1xcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC00MDtcXG4gICAgfVxcbiAgICB0byB7XFxuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogLTEyMDtcXG4gICAgfVxcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciB7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gICAgcG9zaXRpb246IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1ib3R0b20ge1xcbiAgICBwb3NpdGlvbjogY2VudGVyO1xcbiAgfVxcblxcblxcbiAgLmtleWJvYXJkLWJvdHRvbSBsaSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi10b3A6IDRweDtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjhweCkgLyA2KTtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1ib3R0b20gbGk6bnRoLWNoaWxkKDUpIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjhweCkgLyA2IC0gMnB4KTtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbCAubGV0dGVyLXJvdyB7XFxuICAgIG1hcmdpbi10b3A6IDVweDtcXG4gICAgaGVpZ2h0OiA0MnB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDMpIGxpOmZpcnN0LWNoaWxkIHtcXG4gICAgd2lkdGg6IGNhbGMoKDMwMHZ3IC0gOTdweCkgLyAyMCk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCgzKSBsaTpsYXN0LWNoaWxkIHtcXG4gICAgd2lkdGg6IGNhbGMoKDMwMHZ3IC0gOTdweCkgLyAyMCk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaTpmaXJzdC1jaGlsZCB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE5cHgpIC8gNCk7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDQpIGxpOmxhc3QtY2hpbGQge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAxOXB4KSAvIDQpO1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaTpudGgtY2hpbGQoMikge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSA0OXB4KSAvIDEwKTtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciAubGV0dGVyLXJvdzpudGgtY2hpbGQoNCkgbGk6bnRoLWNoaWxkKDMpIHtcXG4gICAgd2lkdGg6IGNhbGMoMiAqICgxMDB2dyAtIDQ5cHgpIC8gNSArIDE1cHgpO1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIC8qIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3RjcgKi9cXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgdWwge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsLWRlZmF1bHQge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgbWFyZ2luOiA0cHggNHB4IDAgNHB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLXBhbmVsIHVsIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbCB1bCBsaSB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgIGhlaWdodDogNDJweDtcXG4gICAgbGluZS1oZWlnaHQ6IDQycHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICBjb2xvcjogIzBkMGQwZDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcblxcbiAgLmxldHRlci1zaGFkZSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMTtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgdWwgbGkge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSA0OXB4KSAvIDEwKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIHVsIGxpOmxhc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtZGVmYXVsdCB1bCBsaSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDI5cHgpIC8gNik7XFxuICAgIG1hcmdpbi10b3A6IDRweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE2cHgpIC8gMyk7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgICBmbG9hdDogbGVmdDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LXN5bWJvbCA+IHVsIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sIHVsIGxpOm50aC1jaGlsZCgybikge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wgPiB1bCBsaTpudGgtY2hpbGQoMSkge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sID4gdWwgbGk6bnRoLWNoaWxkKDIpIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1wYW5lbCBsaSBpbWcge1xcbiAgICB0b3A6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgIG1heC1oZWlnaHQ6IDQycHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgei1pbmRleDogMDtcXG4gICAgbGVmdDogNTAlO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sLWJvdHRvbSB1bCBsaSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMUYxRjE7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE2cHgpIC8gMik7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgICB3aWR0aDogY2FsYygoKDEwMHZ3IC0gMjBweCkgLyAyIC0gOHB4KSAvIDMpO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCgxKSB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDIpIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoMykge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDYpIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCg5KSB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoMTEpIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCgxMCkge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAyOHB4KSAvIDMgKyAzcHgpO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWRlZmF1bHQtcmlnaHQge1xcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAxNnB4KSAvIDYgLSAycHgpO1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1kZWZhdWx0LXJpZ2h0IHVsIGxpIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1zeW1ib2wtbGVmdCA+IHVsIHtcXG4gICAgaGVpZ2h0OiAxNDZweDtcXG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtcGFuZWwtc3ltYm9sIHVsIGxpIHtcXG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcXG4gICAgbWFyZ2luLXRvcDogMTBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICB9XFxuXFxuICAua2V5Ym9hcmQtc3ltYm9sLWxlZnQgdWwgbGk6bnRoLWNoaWxkKDVuKSB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5rZXlib2FyZC1zeW1ib2wtbGVmdCAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wtYm90dG9tIHVsIGxpOm50aC1jaGlsZCgzKSB7XFxuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDlweCkgLyAyKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWZ1bmMgaW1nIHtcXG4gICAgaGVpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLmtleWJvYXJkLWZ1bmMtaWNvbjpsYXN0LWNoaWxkIGltZyB7XFxuICAgIGhlaWdodDogMjhweDtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgfVxcblxcbjwvc3R5bGU+XFxuXFxuPHN0eWxlPlxcbiAgLmtleWJvYXJkIHRleHRhcmVhIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgfVxcblxcbiAgLm1hdGh2aWV3IHRleHRhcmVhIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgfVxcblxcblxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/(.png?896ea0d05bfb11083017d7fca4facf7d";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nLygucG5nPzM4MjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy8oLnBuZz84OTZlYTBkMDViZmIxMTA4MzAxN2Q3ZmNhNGZhY2Y3ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/+.svg?4e942b85af5fd371a755f998fe7c1fc7";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nLysuc3ZnPzg0MDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy8rLnN2Zz80ZTk0MmI4NWFmNWZkMzcxYTc1NWY5OThmZTdjMWZjN1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/-.svg?751c916c295d257c0d1103a29823eb8a";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nLy0uc3ZnPzcyYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy8tLnN2Zz83NTFjOTE2YzI5NWQyNTdjMGQxMTAzYTI5ODIzZWI4YVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/less_than.svg?bdd16c381e0e992c4bf60796c4300f5e";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2xlc3NfdGhhbi5zdmc/ZGM5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2xlc3NfdGhhbi5zdmc/YmRkMTZjMzgxZTBlOTkyYzRiZjYwNzk2YzQzMDBmNWVcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/more_than.svg?edbb73ca1efc28aaf334447dfc4b66d3";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL21vcmVfdGhhbi5zdmc/NTllMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL21vcmVfdGhhbi5zdmc/ZWRiYjczY2ExZWZjMjhhYWYzMzQ0NDdkZmM0YjY2ZDNcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/).png?59cc94989b942a0c3a4399bba0a97b50";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nLykucG5nP2JmYWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy8pLnBuZz81OWNjOTQ5ODliOTQyYTBjM2E0Mzk5YmJhMGE5N2I1MFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/[.png?c96b4a02722860d83ec5f2f1906ad333";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL1sucG5nP2EwYzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9bLnBuZz9jOTZiNGEwMjcyMjg2MGQ4M2VjNWYyZjE5MDZhZDMzM1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/].png?c53641ec7b4e9915a55094a352a7f13f";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL10ucG5nPzA2ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9dLnBuZz9jNTM2NDFlYzdiNGU5OTE1YTU1MDk0YTM1MmE3ZjEzZlwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/abs.svg?5d5fd75ba5c7c3b0762a218210c6c7a2";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2Ficy5zdmc/ZjU1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2Ficy5zdmc/NWQ1ZmQ3NWJhNWM3YzNiMDc2MmEyMTgyMTBjNmM3YTJcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/abc.svg?99be1fc5d285c93210b7d74dd2240d55";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2FiYy5zdmc/OTQyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2FiYy5zdmc/OTliZTFmYzVkMjg1YzkzMjEwYjdkNzRkZDIyNDBkNTVcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/hide.svg?1d1ca89fbcafd58046c50ccb8706ba4d";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2hpZGUuc3ZnPzY5ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9oaWRlLnN2Zz8xZDFjYTg5ZmJjYWZkNTgwNDZjNTBjY2I4NzA2YmE0ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/back.svg?750c888e0eec2b44f33f116cf0455f59";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2JhY2suc3ZnP2ZjYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9iYWNrLnN2Zz83NTBjODg4ZTBlZWMyYjQ0ZjMzZjExNmNmMDQ1NWY1OVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/dback.png?eb909b3756c6999ae8e6a3b18f2d8b99";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2RiYWNrLnBuZz9kMGVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvZGJhY2sucG5nP2ViOTA5YjM3NTZjNjk5OWFlOGU2YTNiMThmMmQ4Yjk5XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/cuadrado.svg?a816b71f9bbad5da90adbd19aec6a4be";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2N1YWRyYWRvLnN2Zz9kNWQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvY3VhZHJhZG8uc3ZnP2E4MTZiNzFmOWJiYWQ1ZGE5MGFkYmQxOWFlYzZhNGJlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/dshift.png?8de0b3ed64000048969cea945a85cbef";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2RzaGlmdC5wbmc/Y2Q4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2RzaGlmdC5wbmc/OGRlMGIzZWQ2NDAwMDA0ODk2OWNlYTk0NWE4NWNiZWZcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/fraccion.svg?676645f0a35ffe59a6989cc04540e4a8";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2ZyYWNjaW9uLnN2Zz9iYzg5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvZnJhY2Npb24uc3ZnPzY3NjY0NWYwYTM1ZmZlNTlhNjk4OWNjMDQ1NDBlNGE4XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/potencia.svg?197ea1338a338fd270dd2b5f8dd1558c";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3BvdGVuY2lhLnN2Zz84OTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvcG90ZW5jaWEuc3ZnPzE5N2VhMTMzOGEzMzhmZDI3MGRkMmI1ZjhkZDE1NThjXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/raiz.svg?d3e2b97f8c5566d78586a438f94bdd4e";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3JhaXouc3ZnPzYxMGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9yYWl6LnN2Zz9kM2UyYjk3ZjhjNTU2NmQ3ODU4NmE0MzhmOTRiZGQ0ZVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/raiz2.svg?d8d7f331cf9fc6e699f9218d1c9f7139";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3JhaXoyLnN2Zz9kY2Q5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvcmFpejIuc3ZnP2Q4ZDdmMzMxY2Y5ZmM2ZTY5OWY5MjE4ZDFjOWY3MTM5XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/shift.svg?a59c1f1419616686fe0cb6098e8772ee";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3NoaWZ0LnN2Zz85MjM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvc2hpZnQuc3ZnP2E1OWMxZjE0MTk2MTY2ODZmZTBjYjYwOThlODc3MmVlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/tercera.png?b69c1e8cc6478cd9a33b26b9578cd799";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3RlcmNlcmEucG5nPzBlYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy90ZXJjZXJhLnBuZz9iNjljMWU4Y2M2NDc4Y2Q5YTMzYjI2Yjk1NzhjZDc5OVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/less_equals.svg?c37f585a26d12b5ba2ec1761c170f202";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2xlc3NfZXF1YWxzLnN2Zz81YTAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvbGVzc19lcXVhbHMuc3ZnP2MzN2Y1ODVhMjZkMTJiNWJhMmVjMTc2MWMxNzBmMjAyXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/more_equals.svg?4e9dc72ae008eafd1d56acd59222ba04";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL21vcmVfZXF1YWxzLnN2Zz80ZDI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvbW9yZV9lcXVhbHMuc3ZnPzRlOWRjNzJhZTAwOGVhZmQxZDU2YWNkNTkyMjJiYTA0XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/pi.svg?e1c9e8665fa66fe4e1b5b3390e1f8922";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3BpLnN2Zz8xODE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvcGkuc3ZnP2UxYzllODY2NWZhNjZmZTRlMWI1YjMzOTBlMWY4OTIyXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/or.svg?1ba0f366d82cad8133d07db078fe4966";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL29yLnN2Zz9kZDJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvb3Iuc3ZnPzFiYTBmMzY2ZDgyY2FkODEzM2QwN2RiMDc4ZmU0OTY2XCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/union.svg?ec3754fc7124043c88643adfe71b00bb";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3VuaW9uLnN2Zz83NzQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvdW5pb24uc3ZnP2VjMzc1NGZjNzEyNDA0M2M4ODY0M2FkZmU3MWIwMGJiXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/penicon.png?f005c09df874284e3a99ac78d3c86925";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL3Blbmljb24ucG5nPzgwYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltZy9wZW5pY29uLnBuZz9mMDA1YzA5ZGY4NzQyODRlM2E5OWFjNzhkM2M4NjkyNVwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/cursor_left.svg?0f476a158d9666e779d967ee408f351f";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2N1cnNvcl9sZWZ0LnN2Zz8zMDJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixxQkFBdUIiLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbWcvY3Vyc29yX2xlZnQuc3ZnPzBmNDc2YTE1OGQ5NjY2ZTc3OWQ5NjdlZTQwOGYzNTFmXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/cursor_right.svg?4365f58e9a1a52051a1a2e2e4dde4db0";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvaW1nL2N1cnNvcl9yaWdodC5zdmc/NzIxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2N1cnNvcl9yaWdodC5zdmc/NDM2NWY1OGU5YTFhNTIwNTFhMWEyZTJlNGRkZTRkYjBcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(51)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(53);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"7b43275e\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlbmRlci52dWU/MDE2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUE4UjtBQUNwVCw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQTZEO0FBQy9FLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0xYWZmYTY1M1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlbmRlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiN2I0MzI3NWVcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0xYWZmYTY1M1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlbmRlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFhZmZhNjUzXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcmVuZGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, "\\n.mathview[data-v-1affa653] {\\n  border: none;\\n  border-bottom: 1px solid gray;\\n  min-width: 45px;\\n  min-height: 22px;\\n}\\n.math-render[data-v-1affa653] {\\n  position: relative;\\n  float: left;\\n}\\n.math-render img[data-v-1affa653] {\\n  position: absolute;\\n  left: 10px;\\n  top: 0;\\n  height: 24px;\\n}\\n", "", {"version":3,"sources":["E:/mygithub/math-keyboard/src/lib/src/lib/render.vue"],"names":[],"mappings":";AAkDA;EACA,aAAA;EACA,8BAAA;EACA,gBAAA;EACA,iBAAA;CACA;AAEA;EACA,mBAAA;EACA,YAAA;CACA;AAEA;EACA,mBAAA;EACA,WAAA;EACA,OAAA;EACA,aAAA;CACA","file":"render.vue","sourcesContent":["<template >\\n  <div class=\\"math-render\\">\\n    <span :id=\\"mathview\\" class=\\"mathview\\"></span>\\n    <img :src=\\"img.penicon\\" v-if=\\"imgshow && !value\\"/>\\n  </div>\\n</template>\\n\\n<script>\\n    import \\"mathquill/build/mathquill\\";\\n    import img from \'./img.js\'\\n\\n    export default {\\n        name: \\"math-render\\",\\n        data() {\\n            return {\\n                img: img,\\n                mathview: \'mathview\' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\\n                viewField: null\\n            }\\n        },\\n        props: {\\n            value: String,\\n            imgshow: {\\n                type: Boolean,\\n                default: true\\n            }\\n        },\\n        mounted() {\\n            var that = this;\\n            var mathview = document.getElementById(this.mathview);\\n\\n            var MQ = MathQuill.getInterface(2);\\n\\n            var viewField = that.viewField = MQ.MathField(mathview);\\n\\n            viewField.latex(that.value)\\n        },\\n        watch: {\\n            value: function (val) {\\n                this.viewField.latex(val);\\n                try {\\n                    $App.outputLatex(\'$\' + val + \'$\')\\n                } catch (e) {\\n                }\\n            }\\n        }\\n    };\\n<\/script>\\n\\n<style scoped>\\n  .mathview {\\n    border: none;\\n    border-bottom: 1px solid gray;\\n    min-width: 45px;\\n    min-height: 22px;\\n  }\\n\\n  .math-render {\\n    position: relative;\\n    float: left;\\n  }\\n\\n  .math-render img {\\n    position: absolute;\\n    left: 10px;\\n    top: 0;\\n    height: 24px;\\n  }\\n</style>\\n\\n<style>\\n  .mathview textarea {\\n    display: none !important;\\n  }\\n\\n  .mathview .mq-cursor {\\n    display: none !important;\\n  }\\n</style>\\n"],"sourceRoot":""}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlbmRlci52dWU/OTVlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsaUNBQWlDLGlCQUFpQixrQ0FBa0Msb0JBQW9CLHFCQUFxQixHQUFHLGlDQUFpQyx1QkFBdUIsZ0JBQWdCLEdBQUcscUNBQXFDLHVCQUF1QixlQUFlLFdBQVcsaUJBQWlCLEdBQUcsVUFBVSx1R0FBdUcsTUFBTSxVQUFVLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsVUFBVSxVQUFVLFVBQVUsd1JBQXdSLHdEQUF3RCxrREFBa0Qsc0JBQXNCLGlMQUFpTCxXQUFXLG1CQUFtQixvREFBb0QsOEVBQThFLFdBQVcsc0JBQXNCLDhCQUE4QixvRUFBb0UsbURBQW1ELHdFQUF3RSxzREFBc0QsbUJBQW1CLHFDQUFxQyw0Q0FBNEMsdUJBQXVCLDBFQUEwRSxZQUFZLG1CQUFtQixlQUFlLFdBQVcsUUFBUSw0Q0FBNEMsbUJBQW1CLG9DQUFvQyxzQkFBc0IsdUJBQXVCLEtBQUssb0JBQW9CLHlCQUF5QixrQkFBa0IsS0FBSyx3QkFBd0IseUJBQXlCLGlCQUFpQixhQUFhLG1CQUFtQixLQUFLLDZDQUE2QywrQkFBK0IsS0FBSyw0QkFBNEIsK0JBQStCLEtBQUssK0JBQStCOztBQUVuMUUiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLm1hdGh2aWV3W2RhdGEtdi0xYWZmYTY1M10ge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGdyYXk7XFxuICBtaW4td2lkdGg6IDQ1cHg7XFxuICBtaW4taGVpZ2h0OiAyMnB4O1xcbn1cXG4ubWF0aC1yZW5kZXJbZGF0YS12LTFhZmZhNjUzXSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuLm1hdGgtcmVuZGVyIGltZ1tkYXRhLXYtMWFmZmE2NTNdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDEwcHg7XFxuICB0b3A6IDA7XFxuICBoZWlnaHQ6IDI0cHg7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJFOi9teWdpdGh1Yi9tYXRoLWtleWJvYXJkL3NyYy9saWIvc3JjL2xpYi9yZW5kZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFrREE7RUFDQSxhQUFBO0VBQ0EsOEJBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFFQTtFQUNBLG1CQUFBO0VBQ0EsWUFBQTtDQUNBO0FBRUE7RUFDQSxtQkFBQTtFQUNBLFdBQUE7RUFDQSxPQUFBO0VBQ0EsYUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJyZW5kZXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZSA+XFxuICA8ZGl2IGNsYXNzPVxcXCJtYXRoLXJlbmRlclxcXCI+XFxuICAgIDxzcGFuIDppZD1cXFwibWF0aHZpZXdcXFwiIGNsYXNzPVxcXCJtYXRodmlld1xcXCI+PC9zcGFuPlxcbiAgICA8aW1nIDpzcmM9XFxcImltZy5wZW5pY29uXFxcIiB2LWlmPVxcXCJpbWdzaG93ICYmICF2YWx1ZVxcXCIvPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbiAgICBpbXBvcnQgXFxcIm1hdGhxdWlsbC9idWlsZC9tYXRocXVpbGxcXFwiO1xcbiAgICBpbXBvcnQgaW1nIGZyb20gJy4vaW1nLmpzJ1xcblxcbiAgICBleHBvcnQgZGVmYXVsdCB7XFxuICAgICAgICBuYW1lOiBcXFwibWF0aC1yZW5kZXJcXFwiLFxcbiAgICAgICAgZGF0YSgpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBpbWc6IGltZyxcXG4gICAgICAgICAgICAgICAgbWF0aHZpZXc6ICdtYXRodmlldycgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogKDk5OTk5OSAtIDEwMDAwMCArIDEpICsgMTAwMDAwLCAxMCksXFxuICAgICAgICAgICAgICAgIHZpZXdGaWVsZDogbnVsbFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBwcm9wczoge1xcbiAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcsXFxuICAgICAgICAgICAgaW1nc2hvdzoge1xcbiAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIG1vdW50ZWQoKSB7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgICAgIHZhciBtYXRodmlldyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWF0aHZpZXcpO1xcblxcbiAgICAgICAgICAgIHZhciBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XFxuXFxuICAgICAgICAgICAgdmFyIHZpZXdGaWVsZCA9IHRoYXQudmlld0ZpZWxkID0gTVEuTWF0aEZpZWxkKG1hdGh2aWV3KTtcXG5cXG4gICAgICAgICAgICB2aWV3RmllbGQubGF0ZXgodGhhdC52YWx1ZSlcXG4gICAgICAgIH0sXFxuICAgICAgICB3YXRjaDoge1xcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudmlld0ZpZWxkLmxhdGV4KHZhbCk7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAkQXBwLm91dHB1dExhdGV4KCckJyArIHZhbCArICckJylcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbjwvc2NyaXB0PlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuICAubWF0aHZpZXcge1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBncmF5O1xcbiAgICBtaW4td2lkdGg6IDQ1cHg7XFxuICAgIG1pbi1oZWlnaHQ6IDIycHg7XFxuICB9XFxuXFxuICAubWF0aC1yZW5kZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLm1hdGgtcmVuZGVyIGltZyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMTBweDtcXG4gICAgdG9wOiAwO1xcbiAgICBoZWlnaHQ6IDI0cHg7XFxuICB9XFxuPC9zdHlsZT5cXG5cXG48c3R5bGU+XFxuICAubWF0aHZpZXcgdGV4dGFyZWEge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAubWF0aHZpZXcgLm1xLWN1cnNvciB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gIH1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(55);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(1).default\nvar update = add(\"873bcb4c\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlbmRlci52dWU/NDlkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFvUTtBQUMxUiw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQTZEO0FBQy9FLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4vcmVuZGVyLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI4NzNiY2I0Y1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9yZW5kZXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xIS4vcmVuZGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(true);\n// imports\n\n\n// module\nexports.push([module.i, "\\n.mathview textarea {\\n  display: none !important;\\n}\\n.mathview .mq-cursor {\\n  display: none !important;\\n}\\n", "", {"version":3,"sources":["E:/mygithub/math-keyboard/src/lib/src/lib/render.vue"],"names":[],"mappings":";AAuEA;EACA,yBAAA;CACA;AAEA;EACA,yBAAA;CACA","file":"render.vue","sourcesContent":["<template >\\n  <div class=\\"math-render\\">\\n    <span :id=\\"mathview\\" class=\\"mathview\\"></span>\\n    <img :src=\\"img.penicon\\" v-if=\\"imgshow && !value\\"/>\\n  </div>\\n</template>\\n\\n<script>\\n    import \\"mathquill/build/mathquill\\";\\n    import img from \'./img.js\'\\n\\n    export default {\\n        name: \\"math-render\\",\\n        data() {\\n            return {\\n                img: img,\\n                mathview: \'mathview\' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\\n                viewField: null\\n            }\\n        },\\n        props: {\\n            value: String,\\n            imgshow: {\\n                type: Boolean,\\n                default: true\\n            }\\n        },\\n        mounted() {\\n            var that = this;\\n            var mathview = document.getElementById(this.mathview);\\n\\n            var MQ = MathQuill.getInterface(2);\\n\\n            var viewField = that.viewField = MQ.MathField(mathview);\\n\\n            viewField.latex(that.value)\\n        },\\n        watch: {\\n            value: function (val) {\\n                this.viewField.latex(val);\\n                try {\\n                    $App.outputLatex(\'$\' + val + \'$\')\\n                } catch (e) {\\n                }\\n            }\\n        }\\n    };\\n<\/script>\\n\\n<style scoped>\\n  .mathview {\\n    border: none;\\n    border-bottom: 1px solid gray;\\n    min-width: 45px;\\n    min-height: 22px;\\n  }\\n\\n  .math-render {\\n    position: relative;\\n    float: left;\\n  }\\n\\n  .math-render img {\\n    position: absolute;\\n    left: 10px;\\n    top: 0;\\n    height: 24px;\\n  }\\n</style>\\n\\n<style>\\n  .mathview textarea {\\n    display: none !important;\\n  }\\n\\n  .mathview .mq-cursor {\\n    display: none !important;\\n  }\\n</style>\\n"],"sourceRoot":""}]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlbmRlci52dWU/OGQyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMseUJBQXlCLDZCQUE2QixHQUFHLHdCQUF3Qiw2QkFBNkIsR0FBRyxVQUFVLHVHQUF1RyxNQUFNLFdBQVcsS0FBSyxLQUFLLFdBQVcsd1JBQXdSLHdEQUF3RCxrREFBa0Qsc0JBQXNCLGlMQUFpTCxXQUFXLG1CQUFtQixvREFBb0QsOEVBQThFLFdBQVcsc0JBQXNCLDhCQUE4QixvRUFBb0UsbURBQW1ELHdFQUF3RSxzREFBc0QsbUJBQW1CLHFDQUFxQyw0Q0FBNEMsdUJBQXVCLDBFQUEwRSxZQUFZLG1CQUFtQixlQUFlLFdBQVcsUUFBUSw0Q0FBNEMsbUJBQW1CLG9DQUFvQyxzQkFBc0IsdUJBQXVCLEtBQUssb0JBQW9CLHlCQUF5QixrQkFBa0IsS0FBSyx3QkFBd0IseUJBQXlCLGlCQUFpQixhQUFhLG1CQUFtQixLQUFLLDZDQUE2QywrQkFBK0IsS0FBSyw0QkFBNEIsK0JBQStCLEtBQUssK0JBQStCOztBQUVsakUiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLm1hdGh2aWV3IHRleHRhcmVhIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLm1hdGh2aWV3IC5tcS1jdXJzb3Ige1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiRTovbXlnaXRodWIvbWF0aC1rZXlib2FyZC9zcmMvbGliL3NyYy9saWIvcmVuZGVyLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBdUVBO0VBQ0EseUJBQUE7Q0FDQTtBQUVBO0VBQ0EseUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwicmVuZGVyLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgPlxcbiAgPGRpdiBjbGFzcz1cXFwibWF0aC1yZW5kZXJcXFwiPlxcbiAgICA8c3BhbiA6aWQ9XFxcIm1hdGh2aWV3XFxcIiBjbGFzcz1cXFwibWF0aHZpZXdcXFwiPjwvc3Bhbj5cXG4gICAgPGltZyA6c3JjPVxcXCJpbWcucGVuaWNvblxcXCIgdi1pZj1cXFwiaW1nc2hvdyAmJiAhdmFsdWVcXFwiLz5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG4gICAgaW1wb3J0IFxcXCJtYXRocXVpbGwvYnVpbGQvbWF0aHF1aWxsXFxcIjtcXG4gICAgaW1wb3J0IGltZyBmcm9tICcuL2ltZy5qcydcXG5cXG4gICAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICAgICAgbmFtZTogXFxcIm1hdGgtcmVuZGVyXFxcIixcXG4gICAgICAgIGRhdGEoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIG1hdGh2aWV3OiAnbWF0aHZpZXcnICsgcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqICg5OTk5OTkgLSAxMDAwMDAgKyAxKSArIDEwMDAwMCwgMTApLFxcbiAgICAgICAgICAgICAgICB2aWV3RmllbGQ6IG51bGxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgcHJvcHM6IHtcXG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nLFxcbiAgICAgICAgICAgIGltZ3Nob3c6IHtcXG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBtb3VudGVkKCkge1xcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICAgICB2YXIgbWF0aHZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1hdGh2aWV3KTtcXG5cXG4gICAgICAgICAgICB2YXIgTVEgPSBNYXRoUXVpbGwuZ2V0SW50ZXJmYWNlKDIpO1xcblxcbiAgICAgICAgICAgIHZhciB2aWV3RmllbGQgPSB0aGF0LnZpZXdGaWVsZCA9IE1RLk1hdGhGaWVsZChtYXRodmlldyk7XFxuXFxuICAgICAgICAgICAgdmlld0ZpZWxkLmxhdGV4KHRoYXQudmFsdWUpXFxuICAgICAgICB9LFxcbiAgICAgICAgd2F0Y2g6IHtcXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdGaWVsZC5sYXRleCh2YWwpO1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgJEFwcC5vdXRwdXRMYXRleCgnJCcgKyB2YWwgKyAnJCcpXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG48L3NjcmlwdD5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbiAgLm1hdGh2aWV3IHtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgZ3JheTtcXG4gICAgbWluLXdpZHRoOiA0NXB4O1xcbiAgICBtaW4taGVpZ2h0OiAyMnB4O1xcbiAgfVxcblxcbiAgLm1hdGgtcmVuZGVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gIH1cXG5cXG4gIC5tYXRoLXJlbmRlciBpbWcge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHRvcDogMDtcXG4gICAgaGVpZ2h0OiAyNHB4O1xcbiAgfVxcbjwvc3R5bGU+XFxuXFxuPHN0eWxlPlxcbiAgLm1hdGh2aWV3IHRleHRhcmVhIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgfVxcblxcbiAgLm1hdGh2aWV3IC5tcS1jdXJzb3Ige1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICB9XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm.js\nvar vue_esm = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/App.vue\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var App = ({\n  data: function data() {\n    return {\n      show: true,\n      value: '',\n      output: ''\n    };\n  },\n\n  methods: {\n    a: function a() {\n      this.value = '2^6';\n    }\n  },\n  watch: {\n    ctrl: function ctrl(nval, oval) {\n      console.log('ctrl' + nval);\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-04c2046b\",\"hasScoped\":false,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\nvar App_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { attrs: { id: \"app\" } },\n    [\n      _c(\n        \"div\",\n        { staticStyle: { display: \"none\" } },\n        [\n          _c(\"math-render\", {\n            attrs: { value: _vm.value, imgshow: !_vm.show },\n            on: {\n              \"update:value\": function($event) {\n                _vm.value = $event\n              }\n            }\n          }),\n          _vm._v(\" \"),\n          _c(\"code\", { on: { click: _vm.a } }, [\n            _vm._v(\"latex: \" + _vm._s(_vm.value))\n          ])\n        ],\n        1\n      ),\n      _vm._v(\" \"),\n      _c(\"math-keyboard\", {\n        attrs: {\n          show: _vm.show,\n          keypanel: 1,\n          value: _vm.value,\n          output: _vm.output\n        },\n        on: {\n          \"update:show\": function($event) {\n            _vm.show = $event\n          },\n          \"update:value\": function($event) {\n            _vm.value = $event\n          },\n          \"update:output\": function($event) {\n            _vm.output = $event\n          }\n        }\n      })\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nApp_render._withStripped = true\n\nif (false) {}\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/component-normalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  scriptExports = scriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof scriptExports.default\n  if (type === 'object' || type === 'function') {\n    scriptExports = scriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/App.vue\nvar disposed = false\nfunction injectStyle (context) {\n  if (disposed) return\n  __webpack_require__(6)\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\n\nvar Component = normalizeComponent(\n  App,\n  App_render,\n  staticRenderFns,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src\\\\App.vue\"\n\n/* hot reload */\nif (false) {}\n\n/* harmony default export */ var src_App = (Component.exports);\n\n// EXTERNAL MODULE: ./node_modules/mathquill/build/mathquill.css\nvar mathquill = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./node_modules/mathquill/build/mathquill.js\nvar build_mathquill = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./src/lib/img.js\n/* harmony default export */ var img = ({\n  zkh: __webpack_require__(21),\n  plus: __webpack_require__(22),\n  subtract: __webpack_require__(23),\n  less_than: __webpack_require__(24),\n  more_than: __webpack_require__(25),\n  ykh: __webpack_require__(26),\n  zfkh: __webpack_require__(27),\n  yfkh: __webpack_require__(28),\n  abs: __webpack_require__(29),\n  abc: __webpack_require__(30),\n  hide: __webpack_require__(31),\n  back: __webpack_require__(32),\n  dback: __webpack_require__(33),\n  cuadrado: __webpack_require__(34),\n  dshift: __webpack_require__(35),\n  fraccion: __webpack_require__(36),\n  potencia: __webpack_require__(37),\n  raiz: __webpack_require__(38),\n  raiz2: __webpack_require__(39),\n  shift: __webpack_require__(40),\n  tercera: __webpack_require__(41),\n  less_equals: __webpack_require__(42),\n  more_equals: __webpack_require__(43),\n  _pi: __webpack_require__(44),\n  or: __webpack_require__(45),\n  union: __webpack_require__(46),\n  penicon: __webpack_require__(47),\n  cursor_left: __webpack_require__(48),\n  cursor_right: __webpack_require__(49)\n});\n// EXTERNAL MODULE: ./node_modules/timers-browserify/main.js\nvar main = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/lib/keyboard.vue\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var keyboard = ({\n    name: \"math-keyboard\",\n    data: function data() {\n        return {\n            img: img,\n            mathField: null,\n            mathview: 'mathview' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\n            mathinput: 'mathinput',\n            panel: this.keypanel,\n            capsletter: 'letter',\n            keyabc: {\n                'letter': [[{ k: 'q', v: 'q', t: false }, { k: 'w', v: 'w', t: false }, { k: 'e', v: 'e', t: false }, { k: 'r', v: 'r', t: false }, { k: 't', v: 't', t: false }, { k: 'y', v: 'y', t: false }, { k: 'u', v: 'u', t: false }, { k: 'i', v: 'i', t: false }, { k: 'o', v: 'o', t: false }, { k: 'p', v: 'p', t: false }], [{ k: 'a', v: 'a', t: false }, { k: 's', v: 's', t: false }, { k: 'd', v: 'd', t: false }, { k: 'f', v: 'f', t: false }, { k: 'g', v: 'g', t: false }, { k: 'h', v: 'h', t: false }, { k: 'j', v: 'j', t: false }, { k: 'k', v: 'k', t: false }, { k: 'l', v: 'l', t: false }], [{ k: '', v: 'shift', i: img.shift, s: false }, { k: 'z', v: 'z', t: false }, { k: 'x', v: 'x', t: false }, { k: 'c', v: 'c', t: false }, { k: 'v', v: 'v', t: false }, { k: 'b', v: 'b', t: false }, { k: 'n', v: 'n', t: false }, { k: 'm', v: 'm', t: false }, { k: '', v: 'Backspace', i: img.back, t: false }]],\n                'caps': [[{ k: 'Q', v: 'Q', t: false }, { k: 'W', v: 'W', t: false }, { k: 'E', v: 'E', t: false }, { k: 'R', v: 'R', t: false }, { k: 'T', v: 'T', t: false }, { k: 'Y', v: 'Y', t: false }, { k: 'U', v: 'U', t: false }, { k: 'I', v: 'I', t: false }, { k: 'O', v: 'O', t: false }, { k: 'P', v: 'P', t: false }], [{ k: 'A', v: 'A', t: false }, { k: 'S', v: 'S', t: false }, { k: 'D', v: 'D', t: false }, { k: 'F', v: 'F', t: false }, { k: 'G', v: 'G', t: false }, { k: 'H', v: 'H', t: false }, { k: 'J', v: 'J', t: false }, { k: 'K', v: 'K', t: false }, { k: 'L', v: 'L', t: false }], [{ k: '', v: 'shift', i: img.dshift, s: true }, { k: 'Z', v: 'Z', t: false }, { k: 'X', v: 'X', t: false }, { k: 'C', v: 'C', t: false }, { k: 'V', v: 'V', t: false }, { k: 'B', v: 'B', t: false }, { k: 'N', v: 'N', t: false }, { k: 'M', v: 'M', t: false }, { k: '', v: 'Backspace', i: img.back, t: false }]]\n            },\n            keynum: [{ k: '1', v: '1', t: false }, { k: '2', v: '2', t: false }, { k: '3', v: '3', t: false }, { k: '4', v: '4', t: false }, { k: '5', v: '5', t: false }, { k: '6', v: '6', t: false }, { k: '7', v: '7', t: false }, { k: '8', v: '8', t: false }, { k: '9', v: '9', t: false }, { k: '0', v: '0', t: false }, { k: '.', v: '.', t: false }],\n            keysym: [{ k: '', v: '\\\\nthroot', i: img.raiz, t: false }, { k: '', v: '\\\\sqrt', i: img.raiz2, t: false }, { k: '', v: '^', i: img.potencia, t: false }, { k: '', v: '^2', i: img.cuadrado, t: false }, { k: '', v: '|', i: img.abs, t: false }, { k: '', v: '/', i: img.fraccion, t: false }, { k: '', v: '\\\\pi', i: img._pi, t: false }, { k: '', v: '或', i: img.or, t: false }],\n            keyBottomSym: [\n            // {k: '', v: 'abc', i: img.abc},\n            { k: '', v: 'hide', i: img.hide, t: false }, { k: '', v: '<', i: img.less_than, t: false }, { k: '', v: '>', i: img.more_than, t: false }, { k: '', v: '\\\\leq', i: img.less_equals, t: false }, { k: '', v: '\\\\geq', i: img.more_equals, t: false }],\n            keyboardRight: [{ k: '', v: '-', i: img.subtract, t: false }, { k: '', v: '+', i: img.plus, t: false }, { k: '', v: '±', i: img.union, t: false }],\n            latex: this.value,\n            keyshow: this.show,\n            keyorwrite: 1,\n            cursorx: 0,\n            cursory: 0,\n            timer: null,\n            interval: null\n        };\n    },\n\n    props: {\n        show: Boolean,\n        value: String,\n        keypanel: {\n            type: Number,\n            default: 1\n        },\n        ctrl: {\n            type: Number,\n            default: 0\n        },\n        output: String\n    },\n    mounted: function mounted() {\n        var that = this;\n        var mathFieldSpan = document.getElementById(this.mathinput);\n\n        var MQ = MathQuill.getInterface(2);\n        var mathField = that.mathField = MQ.MathField(mathFieldSpan, {\n            spaceBehavesLikeTab: true,\n            leftRightIntoCmdGoes: 'up',\n            restrictMismatchedBrackets: true,\n            sumStartsWithNEquals: true,\n            supSubsRequireOperand: true,\n            autoSubscriptNumerals: true,\n            autoOperatorNames: 'sin COMMA',\n            handlers: {\n                edit: function edit(mathField) {\n                    that.$emit('update:value', mathField.latex());\n                    //显示光标\n                    var controller = mathField.__controller;\n                    controller.cursor.show();\n                    controller.blurred = false;\n                }\n            }\n        });\n\n        that.mathField.latex(that.value);\n\n        window.onresize = function () {\n            var content = $('#mathinput .mq-root-block');\n            content.scrollLeft(content[0].scrollWidth);\n        };\n    },\n\n    methods: {\n        /**\n         * 插入符号\n         * @param valor\n         */\n        insertar: function insertar(valor) {\n            var that = this;\n            if (valor.includes(\"^2\") || valor.includes(\"^3\")) {\n                that.mathField.write(valor);\n            } else if (valor === 'Backspace') {\n                that.mathField.keystroke(valor);\n            } else {\n                that.mathField.cmd(valor);\n            }\n        },\n\n        /**\n         * 键盘布局切换\n         * @param val\n         */\n        changepanel: function changepanel(val) {\n            this.panel = val;\n            this.$emit('update:keypanel', val);\n            var keyboardDiv = document.getElementById('keyboard');\n            var height = window.getComputedStyle(keyboardDiv).getPropertyValue(\"height\");\n            console.log(height);\n            try {\n                $App.keyboardHeight(height);\n            } catch (e) {}\n        },\n\n        /**\n         * 字母大小写切换\n         */\n        caps: function caps() {\n            if (this.capsletter === 'letter') {\n                this.capsletter = 'caps';\n            } else {\n                this.capsletter = 'letter';\n            }\n        },\n\n        /**\n         * 键盘隐藏\n         * @param event\n         */\n        keyhide: function keyhide(event) {\n            this.$emit('update:show', false);\n            this.$emit('update:output', this.value);\n            $App.hideKeyboard();\n        },\n        cursorLeft: function cursorLeft(event) {\n            this.mathField.keystroke(\"Left\");\n            this.cursorx = event.changedTouches[0].clientX;\n            console.log(\"Left\");\n        },\n        cursorRight: function cursorRight(event) {\n            this.mathField.keystroke(\"Right\");\n            this.cursorx = event.changedTouches[0].clientX;\n            console.log(\"Right\");\n        },\n        cursorUp: function cursorUp(event) {\n            var _this = this;\n        },\n        cursorDown: function cursorDown(event) {\n            var _this = this;\n            _this.cursorx = event.changedTouches[0].clientX;\n            _this.cursory = event.changedTouches[0].clientY;\n        },\n        cursorMove: function cursorMove(event) {\n            var x = this.cursorx - event.changedTouches[0].clientX;\n            var y = this.cursory - event.changedTouches[0].clientY;\n\n            if (x > 10) {\n                this.mathField.keystroke(\"Left\");\n                this.cursorx = event.changedTouches[0].clientX;\n                console.log(\"Left\");\n            }\n\n            if (x < -10) {\n                this.mathField.keystroke(\"Right\");\n                this.cursorx = event.changedTouches[0].clientX;\n                console.log(\"Right\");\n            }\n\n            if (y > 10) {\n                this.mathField.keystroke(\"Up\");\n                this.cursory = event.changedTouches[0].clientY;\n                console.log(\"Up\");\n            }\n\n            if (y < -10) {\n                this.mathField.keystroke(\"Down\");\n                this.cursory = event.changedTouches[0].clientY;\n                console.log(\"Down\");\n            }\n        },\n        backDown: function backDown(val) {\n            var _this = this;\n            if (val === 'Backspace') {\n                _this.timer = Object(main[\"setTimeout\"])(function () {\n                    _this.interval = setInterval(function () {\n                        _this.mathField.keystroke('Backspace');\n                    }, 100);\n                }, 500);\n            }\n        },\n        backUp: function backUp(val) {\n            if (val === 'Backspace') {\n                this.mathField.keystroke('Backspace');\n                Object(main[\"clearTimeout\"])(this.timer);\n                clearInterval(this.interval);\n            }\n        }\n    },\n    watch: {\n        value: function value(nval, oval) {\n            if (!this.show) {\n                this.mathField.latex(this.value);\n            }\n\n            var content = $('#mathinput .mq-root-block');\n            content.scrollLeft(content[0].scrollWidth);\n        },\n        ctrl: function ctrl(nval, oval) {\n            this.$emit('update:ctrl', nval);\n            // this.keyhide()\n            // console.log('ctrl'+nval)\n        }\n    }\n});\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-78e092e4\",\"hasScoped\":true,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/lib/keyboard.vue\nvar keyboard_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"keyboard\", attrs: { id: \"keyboard\" } }, [\n    _c(\"div\", { staticClass: \"keyboard-output\" }, [\n      _c(\"span\", {\n        attrs: { id: _vm.mathinput },\n        on: {\n          touchstart: function($event) {\n            return _vm.cursorDown($event)\n          },\n          touchmove: function($event) {\n            return _vm.cursorMove($event)\n          },\n          touchup: function($event) {\n            return _vm.cursorUp($event)\n          }\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"left-right\" }, [\n        _c(\"img\", {\n          attrs: { src: _vm.img.cursor_left },\n          on: {\n            click: function($event) {\n              return _vm.cursorLeft($event)\n            }\n          }\n        }),\n        _vm._v(\" \"),\n        _c(\"img\", {\n          staticStyle: { \"margin-left\": \"20px\" },\n          attrs: { src: _vm.img.cursor_right },\n          on: {\n            click: function($event) {\n              return _vm.cursorRight($event)\n            }\n          }\n        })\n      ]),\n      _vm._v(\" \"),\n      _c(\n        \"a\",\n        {\n          staticStyle: { width: \"15%\" },\n          on: {\n            click: function($event) {\n              return _vm.keyhide()\n            }\n          }\n        },\n        [_vm._v(\"确定\")]\n      )\n    ]),\n    _vm._v(\" \"),\n    _c(\n      \"div\",\n      {\n        staticClass: \"keyboard-panel\",\n        style: { display: _vm.keyorwrite === 1 ? \"unset\" : \"none\" }\n      },\n      [\n        _vm.panel === 1\n          ? _c(\"div\", { staticClass: \"keyboard-panel-default\" }, [\n              _c(\"div\", { staticClass: \"keyboard-default-symbol\" }, [\n                _c(\n                  \"ul\",\n                  _vm._l(_vm.keysym, function(item) {\n                    return _c(\n                      \"li\",\n                      {\n                        style: {\n                          \"background-color\": item.t ? \"#bababa\" : \"#F7F7F7\"\n                        },\n                        on: {\n                          click: function($event) {\n                            return _vm.insertar(item.v)\n                          },\n                          touchstart: function($event) {\n                            item.t = true\n                          },\n                          touchend: function($event) {\n                            item.t = false\n                          }\n                        }\n                      },\n                      [\n                        _c(\"div\", { staticClass: \"letter-shade\" }),\n                        _vm._v(\" \"),\n                        item.i\n                          ? _c(\"img\", { attrs: { src: item.i } })\n                          : _vm._e(),\n                        _vm._v(_vm._s(item.k) + \"\\n          \")\n                      ]\n                    )\n                  }),\n                  0\n                )\n              ]),\n              _vm._v(\" \"),\n              _c(\"div\", { staticClass: \"keyboard-default-num\" }, [\n                _c(\n                  \"ul\",\n                  _vm._l(_vm.keynum, function(item) {\n                    return _c(\n                      \"li\",\n                      {\n                        style: {\n                          \"background-color\": item.t ? \"#bababa\" : \"#fff\"\n                        },\n                        on: {\n                          click: function($event) {\n                            return _vm.insertar(item.v)\n                          },\n                          touchstart: function($event) {\n                            item.t = true\n                          },\n                          touchend: function($event) {\n                            item.t = false\n                          }\n                        }\n                      },\n                      [_vm._v(_vm._s(item.k) + \"\\n          \")]\n                    )\n                  }),\n                  0\n                )\n              ]),\n              _vm._v(\" \"),\n              _c(\"div\", { staticClass: \"keyboard-default-right\" }, [\n                _c(\n                  \"ul\",\n                  [\n                    _c(\n                      \"li\",\n                      {\n                        staticStyle: {\n                          \"background-color\": \"#F7F7F7\",\n                          \"margin-top\": \"0px\"\n                        },\n                        on: {\n                          touchstart: function($event) {\n                            return _vm.backDown(\"Backspace\")\n                          },\n                          touchend: function($event) {\n                            return _vm.backUp(\"Backspace\")\n                          }\n                        }\n                      },\n                      [_c(\"img\", { attrs: { src: _vm.img.back } })]\n                    ),\n                    _vm._v(\" \"),\n                    _vm._l(_vm.keyboardRight, function(item) {\n                      return _c(\n                        \"li\",\n                        {\n                          style: {\n                            \"background-color\": item.t ? \"#bababa\" : \"#F7F7F7\"\n                          },\n                          on: {\n                            click: function($event) {\n                              return _vm.insertar(item.v)\n                            },\n                            touchstart: function($event) {\n                              item.t = true\n                            },\n                            touchend: function($event) {\n                              item.t = false\n                            }\n                          }\n                        },\n                        [\n                          _c(\"div\", { staticClass: \"letter-shade\" }),\n                          _vm._v(\" \"),\n                          item.i\n                            ? _c(\"img\", { attrs: { src: item.i } })\n                            : _vm._e(),\n                          _vm._v(_vm._s(item.k) + \"\\n          \")\n                        ]\n                      )\n                    })\n                  ],\n                  2\n                )\n              ])\n            ])\n          : _vm._e(),\n        _vm._v(\" \"),\n        _vm.panel === 3\n          ? _c(\n              \"div\",\n              { staticClass: \"keyboard-panel-letter\" },\n              _vm._l(_vm.keyabc[_vm.capsletter], function(items) {\n                return _c(\"div\", { staticClass: \"letter-row\" }, [\n                  _c(\n                    \"ul\",\n                    _vm._l(items, function(item) {\n                      return _c(\n                        \"li\",\n                        {\n                          style:\n                            item.v !== \"shift\"\n                              ? item.v !== \"Backspace\"\n                                ? {\n                                    \"background-color\": item.t\n                                      ? \"#bababa\"\n                                      : \"#fff\"\n                                  }\n                                : {\n                                    \"background-color\": item.t\n                                      ? \"#fff\"\n                                      : \"#F7F7F7\"\n                                  }\n                              : {\n                                  \"background-color\": item.s\n                                    ? \"#fff\"\n                                    : \"#F7F7F7\"\n                                },\n                          on: {\n                            click: function($event) {\n                              item.v !== \"shift\"\n                                ? item.v !== \"Backspace\"\n                                  ? _vm.insertar(item.v)\n                                  : \"\"\n                                : _vm.caps()\n                            },\n                            touchstart: function($event) {\n                              ;(item.t = true),\n                                _vm.backDown(item.v),\n                                item.v === \"Backspace\"\n                                  ? (item.i = _vm.img.dback)\n                                  : \"\"\n                            },\n                            touchend: function($event) {\n                              ;(item.t = false),\n                                _vm.backUp(item.v),\n                                item.v === \"Backspace\"\n                                  ? (item.i = _vm.img.back)\n                                  : \"\"\n                            }\n                          }\n                        },\n                        [\n                          _c(\"div\", { staticClass: \"letter-shade\" }),\n                          _vm._v(\" \"),\n                          item.i\n                            ? _c(\"img\", { attrs: { src: item.i } })\n                            : _vm._e(),\n                          _vm._v(_vm._s(item.k) + \"\\n          \")\n                        ]\n                      )\n                    }),\n                    0\n                  )\n                ])\n              }),\n              0\n            )\n          : _vm._e(),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"keyboard-bottom\" }, [\n          _c(\n            \"ul\",\n            [\n              _c(\n                \"li\",\n                {\n                  staticStyle: { \"font-size\": \"14px\" },\n                  on: {\n                    click: function($event) {\n                      return _vm.changepanel(_vm.panel === 1 ? 3 : 1)\n                    }\n                  }\n                },\n                [_vm._v(_vm._s(_vm.panel === 1 ? \"abc\" : \"123\") + \"\\n        \")]\n              ),\n              _vm._v(\" \"),\n              _vm._l(_vm.keyBottomSym, function(item) {\n                return _c(\n                  \"li\",\n                  {\n                    style: {\n                      \"background-color\": item.t ? \"#bababa\" : \"#F7F7F7\"\n                    },\n                    on: {\n                      click: function($event) {\n                        item.v === \"hide\" ? _vm.keyhide() : _vm.insertar(item.v)\n                      },\n                      touchstart: function($event) {\n                        item.t = true\n                      },\n                      touchend: function($event) {\n                        item.t = false\n                      }\n                    }\n                  },\n                  [\n                    _c(\"div\", { staticClass: \"letter-shade\" }),\n                    _vm._v(\" \"),\n                    item.i ? _c(\"img\", { attrs: { src: item.i } }) : _vm._e(),\n                    _vm._v(_vm._s(item.k) + \"\\n        \")\n                  ]\n                )\n              })\n            ],\n            2\n          )\n        ])\n      ]\n    )\n  ])\n}\nvar keyboard_staticRenderFns = []\nkeyboard_render._withStripped = true\n\nif (false) {}\n// CONCATENATED MODULE: ./src/lib/keyboard.vue\nvar keyboard_disposed = false\nfunction keyboard_injectStyle (context) {\n  if (keyboard_disposed) return\n  __webpack_require__(17)\n  __webpack_require__(19)\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar keyboard_vue_template_functional_ = false\n/* styles */\nvar keyboard_vue_styles_ = keyboard_injectStyle\n/* scopeId */\nvar keyboard_vue_scopeId_ = \"data-v-78e092e4\"\n/* moduleIdentifier (server only) */\nvar keyboard_vue_module_identifier_ = null\n\nvar keyboard_Component = normalizeComponent(\n  keyboard,\n  keyboard_render,\n  keyboard_staticRenderFns,\n  keyboard_vue_template_functional_,\n  keyboard_vue_styles_,\n  keyboard_vue_scopeId_,\n  keyboard_vue_module_identifier_\n)\nkeyboard_Component.options.__file = \"src\\\\lib\\\\keyboard.vue\"\n\n/* hot reload */\nif (false) {}\n\n/* harmony default export */ var lib_keyboard = (keyboard_Component.exports);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/lib/render.vue\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ var lib_render = ({\n    name: \"math-render\",\n    data: function data() {\n        return {\n            img: img,\n            mathview: 'mathview' + parseInt(Math.random() * (999999 - 100000 + 1) + 100000, 10),\n            viewField: null\n        };\n    },\n\n    props: {\n        value: String,\n        imgshow: {\n            type: Boolean,\n            default: true\n        }\n    },\n    mounted: function mounted() {\n        var that = this;\n        var mathview = document.getElementById(this.mathview);\n\n        var MQ = MathQuill.getInterface(2);\n\n        var viewField = that.viewField = MQ.MathField(mathview);\n\n        viewField.latex(that.value);\n    },\n\n    watch: {\n        value: function value(val) {\n            this.viewField.latex(val);\n            try {\n                $App.outputLatex('$' + val + '$');\n            } catch (e) {}\n        }\n    }\n});\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-1affa653\",\"hasScoped\":true,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/lib/render.vue\nvar render_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"math-render\" }, [\n    _c(\"span\", { staticClass: \"mathview\", attrs: { id: _vm.mathview } }),\n    _vm._v(\" \"),\n    _vm.imgshow && !_vm.value\n      ? _c(\"img\", { attrs: { src: _vm.img.penicon } })\n      : _vm._e()\n  ])\n}\nvar render_staticRenderFns = []\nrender_render._withStripped = true\n\nif (false) {}\n// CONCATENATED MODULE: ./src/lib/render.vue\nvar render_disposed = false\nfunction render_injectStyle (context) {\n  if (render_disposed) return\n  __webpack_require__(52)\n  __webpack_require__(54)\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar render_vue_template_functional_ = false\n/* styles */\nvar render_vue_styles_ = render_injectStyle\n/* scopeId */\nvar render_vue_scopeId_ = \"data-v-1affa653\"\n/* moduleIdentifier (server only) */\nvar render_vue_module_identifier_ = null\n\nvar render_Component = normalizeComponent(\n  lib_render,\n  render_render,\n  render_staticRenderFns,\n  render_vue_template_functional_,\n  render_vue_styles_,\n  render_vue_scopeId_,\n  render_vue_module_identifier_\n)\nrender_Component.options.__file = \"src\\\\lib\\\\render.vue\"\n\n/* hot reload */\nif (false) {}\n\n/* harmony default export */ var src_lib_render = (render_Component.exports);\n\n// CONCATENATED MODULE: ./src/lib/index.js\n\n // 导入组件\n\nvar mathkeyboard = {\n    install: function install(Vue, options) {\n        Vue.component(lib_keyboard.name, lib_keyboard); // vuePayKeyboard.name 组件的name属性\n        Vue.component(src_lib_render.name, src_lib_render);\n        // 类似通过 this.$xxx 方式调用插件的 其实只是挂载到原型上而已\n        // Vue.prototype.$xxx  // 最终可以在任何地方通过 this.$xxx 调用\n        // 虽然没有明确规定用$开头  但是大家都默认遵守这个规定\n    }\n};\n\nif (typeof window !== 'undefined' && window.Vue) {\n    window.Vue.use(mathkeyboard);\n}\n\n/* harmony default export */ var lib = (mathkeyboard); // 导出..\n// CONCATENATED MODULE: ./src/main.js\n\n\n\nvue_esm[\"a\" /* default */].use(lib);\n\nnew vue_esm[\"a\" /* default */]({\n  el: '#app',\n  render: function render(h) {\n    return h(src_App);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0FwcC52dWU/YzY1ZCIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9kMTBiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzPzI0NTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/YmJiYiIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2ltZy5qcz83YmNiIiwid2VicGFjazovLy9zcmMvbGliL2tleWJvYXJkLnZ1ZT84ODcyIiwid2VicGFjazovLy8uL3NyYy9saWIva2V5Ym9hcmQudnVlPzFiNGIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9rZXlib2FyZC52dWU/NjlmZCIsIndlYnBhY2s6Ly8vc3JjL2xpYi9yZW5kZXIudnVlPzU1MmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZW5kZXIudnVlPzgwNzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yZW5kZXIudnVlPzljMjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9pbmRleC5qcz9kNzVhIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwibmFtZXMiOlsiemtoIiwicmVxdWlyZSIsInBsdXMiLCJzdWJ0cmFjdCIsImxlc3NfdGhhbiIsIm1vcmVfdGhhbiIsInlraCIsInpma2giLCJ5ZmtoIiwiYWJzIiwiYWJjIiwiaGlkZSIsImJhY2siLCJkYmFjayIsImN1YWRyYWRvIiwiZHNoaWZ0IiwiZnJhY2Npb24iLCJwb3RlbmNpYSIsInJhaXoiLCJyYWl6MiIsInNoaWZ0IiwidGVyY2VyYSIsImxlc3NfZXF1YWxzIiwibW9yZV9lcXVhbHMiLCJfcGkiLCJvciIsInVuaW9uIiwicGVuaWNvbiIsImN1cnNvcl9sZWZ0IiwiY3Vyc29yX3JpZ2h0IiwibWF0aGtleWJvYXJkIiwiaW5zdGFsbCIsIlZ1ZSIsIm9wdGlvbnMiLCJjb21wb25lbnQiLCJNYXRoS2V5Ym9hcmQiLCJuYW1lIiwiTWF0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S0FBVSxFQUFFLEVBYVg7O0FBRVUsbUVBQVMsUUFBUTs7O0FDL0NoQztDQUMwQztBQUMxQztBQUNBLElBQU02QixlQUFlO0FBQ2pCQyxXQURpQixtQkFDUkMsR0FEUSxFQUNIQyxPQURHLEVBQ007QUFDbkJELFlBQUlFLFNBQUosQ0FBY0MsWUFBWUEsQ0FBQ0MsSUFBM0IsRUFBaUNELFlBQWpDLEVBRG1CLENBQzZCO0FBQ2hESCxZQUFJRSxTQUFKLENBQWNHLGNBQVVBLENBQUNELElBQXpCLEVBQStCQyxjQUEvQjtBQUNEO0FBQ0E7QUFDQTtBQUNGO0FBUGdCLENBQXJCOztBQVVBLElBQUksT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT04sR0FBNUMsRUFBaUQ7QUFDN0NNLFdBQU9OLEdBQVAsQ0FBV08sR0FBWCxDQUFlVCxZQUFmO0FBQ0g7O0FBRWNBLG9EQUFmLEUsQ0FBNEIsTzs7QUNqQjVCO0FBQ0E7QUFDQTtBQUNBRSwwQkFBR0EsQ0FBQ08sR0FBSixDQUFRSixHQUFSOztBQUVBLElBQUlILDBCQUFKLENBQVE7QUFDTlEsTUFBSSxNQURFO0FBRU5DLFVBQVE7QUFBQSxXQUFLQyxFQUFFQyxPQUFGLENBQUw7QUFBQTtBQUZGLENBQVIiLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJhcHBcIj5cbjwhLS0gICAgPGRpdiB2LW9uOmNsaWNrPVwic2hvdyA9ICFzaG93XCI+LS0+XG4gICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj5cbiAgICAgIDxtYXRoLXJlbmRlciA6dmFsdWUuc3luYz1cInZhbHVlXCIgOmltZ3Nob3c9JyFzaG93Jz48L21hdGgtcmVuZGVyPlxuICAgICAgPGNvZGUgQGNsaWNrPVwiYVwiPmxhdGV4OiB7e3ZhbHVlfX08L2NvZGU+XG4gICAgPC9kaXY+XG4gICAgPG1hdGgta2V5Ym9hcmRcbiAgICAgICAgOnNob3cuc3luYz1cInNob3dcIlxuICAgICAgICB2LWJpbmQ6a2V5cGFuZWw9JzEnXG4gICAgICAgIDp2YWx1ZS5zeW5jPVwidmFsdWVcIlxuICAgICAgICA6b3V0cHV0LnN5bmM9XCJvdXRwdXRcIlxuICAgID48L21hdGgta2V5Ym9hcmQ+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YSgpe1xuICAgIHJldHVybntcbiAgICAgIHNob3c6dHJ1ZSxcbiAgICAgIHZhbHVlOicnLFxuICAgICAgb3V0cHV0OicnXG4gICAgfVxuICB9LFxuICBtZXRob2RzOntcbiAgICBhKCl7XG4gICAgICB0aGlzLnZhbHVlID0gJzJeNidcbiAgICB9XG4gIH0sXG4gIHdhdGNoOntcbiAgICBjdHJsKG52YWwsb3ZhbCl7XG4gICAgICBjb25zb2xlLmxvZygnY3RybCcrbnZhbClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4jYXBwIHtcbiAgZm9udC1mYW1pbHk6ICdBdmVuaXInLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcbn1cbjwvc3R5bGU+XG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBhdHRyczogeyBpZDogXCJhcHBcIiB9IH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHsgc3RhdGljU3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJtYXRoLXJlbmRlclwiLCB7XG4gICAgICAgICAgICBhdHRyczogeyB2YWx1ZTogX3ZtLnZhbHVlLCBpbWdzaG93OiAhX3ZtLnNob3cgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIFwidXBkYXRlOnZhbHVlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIF92bS52YWx1ZSA9ICRldmVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImNvZGVcIiwgeyBvbjogeyBjbGljazogX3ZtLmEgfSB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoXCJsYXRleDogXCIgKyBfdm0uX3MoX3ZtLnZhbHVlKSlcbiAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwibWF0aC1rZXlib2FyZFwiLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgc2hvdzogX3ZtLnNob3csXG4gICAgICAgICAga2V5cGFuZWw6IDEsXG4gICAgICAgICAgdmFsdWU6IF92bS52YWx1ZSxcbiAgICAgICAgICBvdXRwdXQ6IF92bS5vdXRwdXRcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcInVwZGF0ZTpzaG93XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLnNob3cgPSAkZXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlOnZhbHVlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLnZhbHVlID0gJGV2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVwZGF0ZTpvdXRwdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBfdm0ub3V0cHV0ID0gJGV2ZW50XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wNGMyMDQ2YlwiLCB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9KVxuICB9XG59IiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgc2NyaXB0RXhwb3J0cyA9IHNjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNjcmlwdEV4cG9ydHMgPSBzY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKGNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9BcHAudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9BcHAudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQge3JlbmRlciBhcyBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zIGFzIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX199IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTA0YzIwNDZiXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0FwcC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbmltcG9ydCBub3JtYWxpemVDb21wb25lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnQtbm9ybWFsaXplclwiXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfcmVuZGVyX18sXG4gIF9fdnVlX3N0YXRpY19yZW5kZXJfZm5zX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmNcXFxcQXBwLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0wNGMyMDQ2YlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTA0YzIwNDZiXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgemtoOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nLygucG5nJyksXG4gIHBsdXM6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvKy5zdmcnKSxcbiAgc3VidHJhY3Q6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvLS5zdmcnKSxcbiAgbGVzc190aGFuOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL2xlc3NfdGhhbi5zdmcnKSxcbiAgbW9yZV90aGFuOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL21vcmVfdGhhbi5zdmcnKSxcbiAgeWtoOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nLykucG5nJyksXG4gIHpma2g6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvWy5wbmcnKSxcbiAgeWZraDogcmVxdWlyZSgnLi4vLi4vc3RhdGljL2ltZy9dLnBuZycpLFxuICBhYnM6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvYWJzLnN2ZycpLFxuICBhYmM6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvYWJjLnN2ZycpLFxuICBoaWRlOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL2hpZGUuc3ZnJyksXG4gIGJhY2s6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvYmFjay5zdmcnKSxcbiAgZGJhY2s6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvZGJhY2sucG5nJyksXG4gIGN1YWRyYWRvOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL2N1YWRyYWRvLnN2ZycpLFxuICBkc2hpZnQ6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvZHNoaWZ0LnBuZycpLFxuICBmcmFjY2lvbjogcmVxdWlyZSgnLi4vLi4vc3RhdGljL2ltZy9mcmFjY2lvbi5zdmcnKSxcbiAgcG90ZW5jaWE6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvcG90ZW5jaWEuc3ZnJyksXG4gIHJhaXo6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvcmFpei5zdmcnKSxcbiAgcmFpejI6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvcmFpejIuc3ZnJyksXG4gIHNoaWZ0OiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL3NoaWZ0LnN2ZycpLFxuICB0ZXJjZXJhOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL3RlcmNlcmEucG5nJyksXG4gIGxlc3NfZXF1YWxzOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL2xlc3NfZXF1YWxzLnN2ZycpLFxuICBtb3JlX2VxdWFsczogcmVxdWlyZSgnLi4vLi4vc3RhdGljL2ltZy9tb3JlX2VxdWFscy5zdmcnKSxcbiAgX3BpOiByZXF1aXJlKCcuLi8uLi9zdGF0aWMvaW1nL3BpLnN2ZycpLFxuICBvcjogcmVxdWlyZSgnLi4vLi4vc3RhdGljL2ltZy9vci5zdmcnKSxcbiAgdW5pb246IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvdW5pb24uc3ZnJyksXG4gIHBlbmljb246IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvcGVuaWNvbi5wbmcnKSxcbiAgY3Vyc29yX2xlZnQ6IHJlcXVpcmUoJy4uLy4uL3N0YXRpYy9pbWcvY3Vyc29yX2xlZnQuc3ZnJyksXG4gIGN1cnNvcl9yaWdodDogcmVxdWlyZSgnLi4vLi4vc3RhdGljL2ltZy9jdXJzb3JfcmlnaHQuc3ZnJylcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImtleWJvYXJkXCIgaWQ9XCJrZXlib2FyZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJrZXlib2FyZC1vdXRwdXRcIj5cbiAgICAgIDxzcGFuIDppZD1cIm1hdGhpbnB1dFwiXG4gICAgICAgICAgICBAdG91Y2hzdGFydD1cImN1cnNvckRvd24oJGV2ZW50KVwiXG4gICAgICAgICAgICBAdG91Y2htb3ZlPVwiY3Vyc29yTW92ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIEB0b3VjaHVwPVwiY3Vyc29yVXAoJGV2ZW50KVwiPlxuICAgICAgPC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cImxlZnQtcmlnaHRcIj5cbiAgICAgICAgPGltZyA6c3JjPVwiaW1nLmN1cnNvcl9sZWZ0XCIgQGNsaWNrPVwiY3Vyc29yTGVmdCgkZXZlbnQpXCIvPlxuICAgICAgICA8aW1nIDpzcmM9XCJpbWcuY3Vyc29yX3JpZ2h0XCIgQGNsaWNrPVwiY3Vyc29yUmlnaHQoJGV2ZW50KVwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDIwcHhcIi8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxhIEBjbGljaz1cImtleWhpZGUoKVwiIHN0eWxlPVwid2lkdGg6IDE1JVwiPuehruWumjwvYT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwia2V5Ym9hcmQtcGFuZWxcIlxuICAgICAgICAgOnN0eWxlPVwie2Rpc3BsYXk6a2V5b3J3cml0ZSA9PT0gMSA/ICd1bnNldCc6J25vbmUnfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImtleWJvYXJkLXBhbmVsLWRlZmF1bHRcIiB2LWlmPVwicGFuZWwgPT09IDFcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImtleWJvYXJkLWRlZmF1bHQtc3ltYm9sXCI+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBrZXlzeW1cIiBAY2xpY2s9XCJpbnNlcnRhcihpdGVtLnYpXCJcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cIml0ZW0udCA9IHRydWVcIlxuICAgICAgICAgICAgICAgIEB0b3VjaGVuZD1cIml0ZW0udCA9IGZhbHNlXCJcbiAgICAgICAgICAgICAgICA6c3R5bGU9XCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV0dGVyLXNoYWRlXCI+PC9kaXY+XG4gICAgICAgICAgICAgIDxpbWcgOnNyYz1cIml0ZW0uaVwiIHYtaWY9XCJpdGVtLmlcIi8+e3tpdGVtLmt9fVxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImtleWJvYXJkLWRlZmF1bHQtbnVtXCI+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBrZXludW1cIlxuICAgICAgICAgICAgICAgIEBjbGljaz1cImluc2VydGFyKGl0ZW0udilcIlxuICAgICAgICAgICAgICAgIEB0b3VjaHN0YXJ0PVwiaXRlbS50ID0gdHJ1ZVwiXG4gICAgICAgICAgICAgICAgQHRvdWNoZW5kPVwiaXRlbS50ID0gZmFsc2VcIlxuICAgICAgICAgICAgICAgIDpzdHlsZT1cInsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50PycjYmFiYWJhJzonI2ZmZid9XCJcbiAgICAgICAgICAgID57e2l0ZW0ua319XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwia2V5Ym9hcmQtZGVmYXVsdC1yaWdodFwiPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSBAdG91Y2hzdGFydD1cImJhY2tEb3duKCdCYWNrc3BhY2UnKVwiIEB0b3VjaGVuZD1cImJhY2tVcCgnQmFja3NwYWNlJylcIlxuICAgICAgICAgICAgICAgIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNzttYXJnaW4tdG9wOiAwcHhcIj48aW1nIDpzcmM9XCJpbWcuYmFja1wiLz48L2xpPlxuICAgICAgICAgICAgPGxpIHYtZm9yPVwiaXRlbSBpbiBrZXlib2FyZFJpZ2h0XCJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCJpbnNlcnRhcihpdGVtLnYpXCJcbiAgICAgICAgICAgICAgICBAdG91Y2hzdGFydD1cIml0ZW0udCA9IHRydWVcIlxuICAgICAgICAgICAgICAgIEB0b3VjaGVuZD1cIml0ZW0udCA9IGZhbHNlXCJcbiAgICAgICAgICAgICAgICA6c3R5bGU9XCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV0dGVyLXNoYWRlXCI+PC9kaXY+XG4gICAgICAgICAgICAgIDxpbWcgOnNyYz1cIml0ZW0uaVwiIHYtaWY9XCJpdGVtLmlcIi8+e3tpdGVtLmt9fVxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwia2V5Ym9hcmQtcGFuZWwtbGV0dGVyXCIgdi1pZj1cInBhbmVsID09PSAzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZXR0ZXItcm93XCIgdi1mb3I9XCJpdGVtcyBpbiBrZXlhYmNbY2Fwc2xldHRlcl1cIj5cbiAgICAgICAgICA8dWw+XG4gICAgICAgICAgICA8bGkgdi1mb3I9XCJpdGVtIGluIGl0ZW1zXCJcbiAgICAgICAgICAgICAgICBAY2xpY2s9XCIoaXRlbS52ICE9PSAnc2hpZnQnID8gKGl0ZW0udiAhPT0gJ0JhY2tzcGFjZScgPyBpbnNlcnRhcihpdGVtLnYpIDogJycpIDogY2FwcygpKVwiXG4gICAgICAgICAgICAgICAgQHRvdWNoc3RhcnQ9XCJpdGVtLnQgPSB0cnVlLGJhY2tEb3duKGl0ZW0udiksaXRlbS52ID09PSAnQmFja3NwYWNlJyA/IGl0ZW0uaSA9IGltZy5kYmFjayA6ICcnXCJcbiAgICAgICAgICAgICAgICBAdG91Y2hlbmQ9XCJpdGVtLnQgPSBmYWxzZSxiYWNrVXAoaXRlbS52KSxpdGVtLnYgPT09ICdCYWNrc3BhY2UnID8gaXRlbS5pID0gaW1nLmJhY2sgOiAnJ1wiXG4gICAgICAgICAgICAgICAgOnN0eWxlPVwiaXRlbS52ICE9PSAnc2hpZnQnID8gaXRlbS52ICE9PSAnQmFja3NwYWNlJyA/IHsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50ID8gJyNiYWJhYmEnIDogJyNmZmYnfSA6IHsnYmFja2dyb3VuZC1jb2xvcic6aXRlbS50ID8gJyNmZmYnIDogJyNGN0Y3RjcnfSA6eydiYWNrZ3JvdW5kLWNvbG9yJzppdGVtLnMgPyAnI2ZmZicgOiAnI0Y3RjdGNyd9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxldHRlci1zaGFkZVwiPjwvZGl2PlxuICAgICAgICAgICAgICA8aW1nIDpzcmM9XCJpdGVtLmlcIiB2LWlmPVwiaXRlbS5pXCIvPnt7aXRlbS5rfX1cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJrZXlib2FyZC1ib3R0b21cIj5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIDxsaSBAY2xpY2s9XCJjaGFuZ2VwYW5lbChwYW5lbD09PTE/MzoxKVwiIHN0eWxlPVwiZm9udC1zaXplOiAxNHB4O1wiPnt7cGFuZWw9PT0xPydhYmMnOicxMjMnfX1cbiAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDxsaSB2LWZvcj1cIml0ZW0gaW4ga2V5Qm90dG9tU3ltXCJcbiAgICAgICAgICAgICAgQGNsaWNrPVwiaXRlbS52PT09J2hpZGUnP2tleWhpZGUoKTppbnNlcnRhcihpdGVtLnYpXCJcbiAgICAgICAgICAgICAgQHRvdWNoc3RhcnQ9XCJpdGVtLnQgPSB0cnVlXCJcbiAgICAgICAgICAgICAgQHRvdWNoZW5kPVwiaXRlbS50ID0gZmFsc2VcIlxuICAgICAgICAgICAgICA6c3R5bGU9XCJ7J2JhY2tncm91bmQtY29sb3InOml0ZW0udD8nI2JhYmFiYSc6JyNGN0Y3RjcnfVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxldHRlci1zaGFkZVwiPjwvZGl2PlxuICAgICAgICAgICAgPGltZyA6c3JjPVwiaXRlbS5pXCIgdi1pZj1cIml0ZW0uaVwiLz57e2l0ZW0ua319XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAgIGltcG9ydCBcIm1hdGhxdWlsbC9idWlsZC9tYXRocXVpbGxcIjtcbiAgICBpbXBvcnQgaW1nIGZyb20gJy4vaW1nLmpzJ1xuICAgIGltcG9ydCB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSBmcm9tICd0aW1lcnMnO1xuXG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBuYW1lOiBcIm1hdGgta2V5Ym9hcmRcIixcbiAgICAgICAgZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICAgICAgbWF0aEZpZWxkOiBudWxsLFxuICAgICAgICAgICAgICAgIG1hdGh2aWV3OiAnbWF0aHZpZXcnICsgcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqICg5OTk5OTkgLSAxMDAwMDAgKyAxKSArIDEwMDAwMCwgMTApLFxuICAgICAgICAgICAgICAgIG1hdGhpbnB1dDogJ21hdGhpbnB1dCcsXG4gICAgICAgICAgICAgICAgcGFuZWw6IHRoaXMua2V5cGFuZWwsXG4gICAgICAgICAgICAgICAgY2Fwc2xldHRlcjogJ2xldHRlcicsXG4gICAgICAgICAgICAgICAga2V5YWJjOiB7XG4gICAgICAgICAgICAgICAgICAgICdsZXR0ZXInOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdxJywgdjogJ3EnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd3JywgdjogJ3cnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdlJywgdjogJ2UnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdyJywgdjogJ3InLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd0JywgdjogJ3QnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd5JywgdjogJ3knLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICd1JywgdjogJ3UnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdpJywgdjogJ2knLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdvJywgdjogJ28nLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICdwJywgdjogJ3AnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnYScsIHY6ICdhJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAncycsIHY6ICdzJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnZCcsIHY6ICdkJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnZicsIHY6ICdmJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnZycsIHY6ICdnJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaCcsIHY6ICdoJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaicsIHY6ICdqJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnaycsIHY6ICdrJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbCcsIHY6ICdsJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdzaGlmdCcsIGk6IGltZy5zaGlmdCwgczogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAneicsIHY6ICd6JywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAneCcsIHY6ICd4JywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnYycsIHY6ICdjJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAndicsIHY6ICd2JywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnYicsIHY6ICdiJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbicsIHY6ICduJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnbScsIHY6ICdtJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ0JhY2tzcGFjZScsIGk6IGltZy5iYWNrLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdjYXBzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUScsIHY6ICdRJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnVycsIHY6ICdXJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnRScsIHY6ICdFJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUicsIHY6ICdSJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnVCcsIHY6ICdUJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnWScsIHY6ICdZJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnVScsIHY6ICdVJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnSScsIHY6ICdJJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnTycsIHY6ICdPJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtrOiAnUCcsIHY6ICdQJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0EnLCB2OiAnQScsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1MnLCB2OiAnUycsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0QnLCB2OiAnRCcsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0YnLCB2OiAnRicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0cnLCB2OiAnRycsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0gnLCB2OiAnSCcsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0onLCB2OiAnSicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0snLCB2OiAnSycsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0wnLCB2OiAnTCcsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnc2hpZnQnLCBpOiBpbWcuZHNoaWZ0LCBzOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1onLCB2OiAnWicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1gnLCB2OiAnWCcsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0MnLCB2OiAnQycsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ1YnLCB2OiAnVicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ0InLCB2OiAnQicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ04nLCB2OiAnTicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJ00nLCB2OiAnTScsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdCYWNrc3BhY2UnLCBpOiBpbWcuYmFjaywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXludW06IFtcbiAgICAgICAgICAgICAgICAgICAge2s6ICcxJywgdjogJzEnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnMicsIHY6ICcyJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJzMnLCB2OiAnMycsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc0JywgdjogJzQnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnNScsIHY6ICc1JywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJzYnLCB2OiAnNicsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICc3JywgdjogJzcnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnOCcsIHY6ICc4JywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJzknLCB2OiAnOScsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcwJywgdjogJzAnLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnLicsIHY6ICcuJywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAga2V5c3ltOiBbXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxudGhyb290JywgaTogaW1nLnJhaXosIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXFxcXHNxcnQnLCBpOiBpbWcucmFpejIsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXicsIGk6IGltZy5wb3RlbmNpYSwgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICdeMicsIGk6IGltZy5jdWFkcmFkbywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICd8JywgaTogaW1nLmFicywgdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7azogJycsIHY6ICcvJywgaTogaW1nLmZyYWNjaW9uLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxwaScsIGk6IGltZy5fcGksIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAn5oiWJywgaTogaW1nLm9yLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJ14zJywgaTogaW1nLnRlcmNlcmF9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJygnLCB2OiAnKCcsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICcpJywgdjogJyknLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnWycsIHY6ICdbJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ10nLCB2OiAnXScsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICdzaW4nLCB2OiAnXFxcXHNpbicsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICdjb3MnLCB2OiAnXFxcXGNvcycsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICd0YW4nLCB2OiAnXFxcXHRhbicsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiYgnLCB2OiAnXFxcXGFwcHJveCcsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiaAnLCB2OiAnXFxcXG5lcScsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICclJywgdjogJyUnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnJywgdjogJy0nLCBpOiBpbWcuc3VidHJhY3R9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICcrJywgaTogaW1nLnBsdXN9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ8OXJywgdjogJ1xcXFx0aW1lcycsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfDtycsIHY6ICdcXFxcZGl2JywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICfCsScsIGk6IGltZy51bmlvbn0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAnLCcsIHY6ICcsJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJzonLCB2OiAnOicsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfCsCcsIHY6ICdcXFxcZGVncmVlJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+S4lCcsIHY6ICfkuJQnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn6Z2eJywgdjogJ+mdnicsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICd4JywgdjogJ3gnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAneScsIHY6ICd5JywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KIkScsIHY6ICdcXFxcc3VtJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+WQkemHjycsIHY6ICdcXFxcb3ZlcnJpZ2h0YXJyb3cnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oigJywgdjogJ+KIoCcsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiLUnLCB2OiAnXFxcXGJlY2F1c2UnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oi0JywgdjogJ1xcXFx0aGVyZWZvcmUnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oiIJywgdjogJ1xcXFxpbicsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfiiIknLCB2OiAnXFxcXG5vdGluJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KIqScsIHY6ICdcXFxcaW50ZXJzZWN0aW9uJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KIqicsIHY6ICdcXFxcY3VwJywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KKgicsIHY6ICdcXFxcc3Vic2V0JywgaTogJyd9LFxuICAgICAgICAgICAgICAgICAgICAvLyB7azogJ+KKgycsIHY6ICdcXFxcc3VwZXJzZXQnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oieJywgdjogJ1xcXFxpbmZ0eScsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICdsb2cnLCB2OiAnXFxcXGxvZycsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfihpAnLCB2OiAnXFxcXGxlZnRhcnJvdycsIGk6ICcnfSxcbiAgICAgICAgICAgICAgICAgICAgLy8ge2s6ICfihpInLCB2OiAnXFxcXHJpZ2h0YXJyb3cnLCBpOiAnJ30sXG4gICAgICAgICAgICAgICAgICAgIC8vIHtrOiAn4oeUJywgdjogJ1xcXFxpZmYnLCBpOiAnJ31cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGtleUJvdHRvbVN5bTogW1xuICAgICAgICAgICAgICAgICAgICAvLyB7azogJycsIHY6ICdhYmMnLCBpOiBpbWcuYWJjfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnaGlkZScsIGk6IGltZy5oaWRlLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJzwnLCBpOiBpbWcubGVzc190aGFuLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJz4nLCBpOiBpbWcubW9yZV90aGFuLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ1xcXFxsZXEnLCBpOiBpbWcubGVzc19lcXVhbHMsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnXFxcXGdlcScsIGk6IGltZy5tb3JlX2VxdWFscywgdDogZmFsc2V9LFxuXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFJpZ2h0OiBbXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJy0nLCBpOiBpbWcuc3VidHJhY3QsIHQ6IGZhbHNlfSxcbiAgICAgICAgICAgICAgICAgICAge2s6ICcnLCB2OiAnKycsIGk6IGltZy5wbHVzLCB0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgIHtrOiAnJywgdjogJ8KxJywgaTogaW1nLnVuaW9uLCB0OiBmYWxzZX1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGxhdGV4OiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtleXNob3c6IHRoaXMuc2hvdyxcbiAgICAgICAgICAgICAgICBrZXlvcndyaXRlOiAxLFxuICAgICAgICAgICAgICAgIGN1cnNvcng6IDAsXG4gICAgICAgICAgICAgICAgY3Vyc29yeTogMCxcbiAgICAgICAgICAgICAgICB0aW1lcjogbnVsbCxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHNob3c6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nLFxuICAgICAgICAgICAga2V5cGFuZWw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0cmw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dHB1dDogU3RyaW5nLFxuICAgICAgICB9LFxuICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG1hdGhGaWVsZFNwYW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1hdGhpbnB1dCk7XG5cbiAgICAgICAgICAgIHZhciBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XG4gICAgICAgICAgICB2YXIgbWF0aEZpZWxkID0gdGhhdC5tYXRoRmllbGQgPSBNUS5NYXRoRmllbGQobWF0aEZpZWxkU3Bhbiwge1xuICAgICAgICAgICAgICAgIHNwYWNlQmVoYXZlc0xpa2VUYWI6IHRydWUsXG4gICAgICAgICAgICAgICAgbGVmdFJpZ2h0SW50b0NtZEdvZXM6ICd1cCcsXG4gICAgICAgICAgICAgICAgcmVzdHJpY3RNaXNtYXRjaGVkQnJhY2tldHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VtU3RhcnRzV2l0aE5FcXVhbHM6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VwU3Vic1JlcXVpcmVPcGVyYW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1dG9TdWJzY3JpcHROdW1lcmFsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdXRvT3BlcmF0b3JOYW1lczogJ3NpbiBDT01NQScsXG4gICAgICAgICAgICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdDogZnVuY3Rpb24gKG1hdGhGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC4kZW1pdCgndXBkYXRlOnZhbHVlJywgbWF0aEZpZWxkLmxhdGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy/mmL7npLrlhYnmoIdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBtYXRoRmllbGQuX19jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jdXJzb3Iuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5ibHVycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5tYXRoRmllbGQubGF0ZXgodGhhdC52YWx1ZSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9ICQoJyNtYXRoaW5wdXQgLm1xLXJvb3QtYmxvY2snKTtcbiAgICAgICAgICAgICAgICBjb250ZW50LnNjcm9sbExlZnQoY29udGVudFswXS5zY3JvbGxXaWR0aClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5o+S5YWl56ym5Y+3XG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5zZXJ0YXIodmFsb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHZhbG9yLmluY2x1ZGVzKFwiXjJcIikgfHwgdmFsb3IuaW5jbHVkZXMoXCJeM1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1hdGhGaWVsZC53cml0ZSh2YWxvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxvciA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5tYXRoRmllbGQua2V5c3Ryb2tlKHZhbG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm1hdGhGaWVsZC5jbWQodmFsb3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6ZSu55uY5biD5bGA5YiH5o2iXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXBhbmVsKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFuZWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOmtleXBhbmVsJywgdmFsKTtcbiAgICAgICAgICAgICAgICBsZXQga2V5Ym9hcmREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna2V5Ym9hcmQnKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoa2V5Ym9hcmREaXYpLmdldFByb3BlcnR5VmFsdWUoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAkQXBwLmtleWJvYXJkSGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOWtl+avjeWkp+Wwj+WGmeWIh+aNolxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXBzKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHNsZXR0ZXIgPT09ICdsZXR0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fwc2xldHRlciA9ICdjYXBzJ1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fwc2xldHRlciA9ICdsZXR0ZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog6ZSu55uY6ZqQ6JePXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAga2V5aGlkZShldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpzaG93JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpvdXRwdXQnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAkQXBwLmhpZGVLZXlib2FyZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnNvckxlZnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXCJMZWZ0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMZWZ0XCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Vyc29yUmlnaHQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5rZXlzdHJva2UoXCJSaWdodFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmlnaHRcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJzb3JVcChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJzb3JEb3duKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJzb3J4ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJzb3J5ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXJzb3JNb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmN1cnNvcnggLSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5jdXJzb3J5IC0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgICAgICAgICAgICAgIGlmICh4ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFwiTGVmdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3J4ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMZWZ0XCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHggPCAtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFwiUmlnaHRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yeCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmlnaHRcIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeSA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZShcIlVwXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvcnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHkgPCAtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKFwiRG93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3J5ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJEb3duXCIpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBiYWNrRG93bih2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXRoRmllbGQua2V5c3Ryb2tlKCdCYWNrc3BhY2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja1VwKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aEZpZWxkLmtleXN0cm9rZSgnQmFja3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2F0Y2g6IHtcbiAgICAgICAgICAgIHZhbHVlKG52YWwsIG92YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGhGaWVsZC5sYXRleCh0aGlzLnZhbHVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gJCgnI21hdGhpbnB1dCAubXEtcm9vdC1ibG9jaycpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuc2Nyb2xsTGVmdChjb250ZW50WzBdLnNjcm9sbFdpZHRoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0cmwobnZhbCwgb3ZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpjdHJsJywgbnZhbClcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmtleWhpZGUoKVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjdHJsJytudmFsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH07XG48L3NjcmlwdD5cblxuPCEtLSBBZGQgXCJzY29wZWRcIiBhdHRyaWJ1dGUgdG8gbGltaXQgQ1NTIHRvIHRoaXMgY29tcG9uZW50IG9ubHkgLS0+XG48c3R5bGUgc2NvcGVkPlxuICAqIHtcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveCAhaW1wb3J0YW50O1xuICB9XG5cbiAgI21hdGhpbnB1dCB7XG4gICAgbWFyZ2luOiAzcHg7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjMDA5OUZGO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB3aWR0aDogNjUlXG4gIH1cblxuICAua2V5Ym9hcmQge1xuICAgIG1hcmdpbi10b3A6IC04cHg7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XG4gICAgbGVmdDogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjFGMUYxO1xuICAgIHotaW5kZXg6IDE2Nzc3MjcxO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzO1xuICB9XG5cbiAgLmtleWJvYXJkLW91dHB1dCB7XG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIDRweCk7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHBhZGRpbmc6IDJweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICB9XG5cbiAgLmxlZnQtcmlnaHQge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBtYXJnaW4tbGVmdDogY2FsYyg2NSUgKyAxNXB4KTtcbiAgICB0b3A6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gIH1cblxuICAubGVmdC1yaWdodCBpbWcge1xuICAgIHdpZHRoOiAxNXB4O1xuICAgIGhlaWdodDogMTVweDtcbiAgfVxuXG4gIC5rZXlib2FyZC1vdXRwdXQgPiBhIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgbGluZS1oZWlnaHQ6IDQwcHg7XG4gICAgd2lkdGg6IDQycHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgY29sb3I6ICMyZTdiZmQ7XG4gICAgZm9udC1zaXplOiAxNXB4O1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMnB4O1xuICAgIHRvcDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgfVxuXG4gIEAtd2Via2l0LWtleWZyYW1lcyB2YW4tY2lyY3VsYXIge1xuICAgIDAlIHtcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEsIDIwMDtcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xuICAgIH1cbiAgICA1MCUge1xuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtNDA7XG4gICAgfVxuICAgIHRvIHtcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDkwLCAxNTA7XG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogLTEyMDtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIHZhbi1jaXJjdWxhciB7XG4gICAgMCUge1xuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMSwgMjAwO1xuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XG4gICAgfVxuICAgIDUwJSB7XG4gICAgICBzdHJva2UtZGFzaGFycmF5OiA5MCwgMTUwO1xuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC00MDtcbiAgICB9XG4gICAgdG8ge1xuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogOTAsIDE1MDtcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTIwO1xuICAgIH1cbiAgfVxuXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIge1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBwb3NpdGlvbjogY2VudGVyO1xuICB9XG5cbiAgLmtleWJvYXJkLWJvdHRvbSB7XG4gICAgcG9zaXRpb246IGNlbnRlcjtcbiAgfVxuXG5cbiAgLmtleWJvYXJkLWJvdHRvbSBsaSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAyOHB4KSAvIDYpO1xuICB9XG5cbiAgLmtleWJvYXJkLWJvdHRvbSBsaTpudGgtY2hpbGQoNSkge1xuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDI4cHgpIC8gNiAtIDJweCk7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwgLmxldHRlci1yb3cge1xuICAgIG1hcmdpbi10b3A6IDVweDtcbiAgICBoZWlnaHQ6IDQycHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCgzKSBsaTpmaXJzdC1jaGlsZCB7XG4gICAgd2lkdGg6IGNhbGMoKDMwMHZ3IC0gOTdweCkgLyAyMCk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcbiAgfVxuXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDMpIGxpOmxhc3QtY2hpbGQge1xuICAgIHdpZHRoOiBjYWxjKCgzMDB2dyAtIDk3cHgpIC8gMjApO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaTpmaXJzdC1jaGlsZCB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTlweCkgLyA0KTtcbiAgICBmb250LXNpemU6IDE1cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcbiAgfVxuXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgLmxldHRlci1yb3c6bnRoLWNoaWxkKDQpIGxpOmxhc3QtY2hpbGQge1xuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE5cHgpIC8gNCk7XG4gICAgZm9udC1zaXplOiAxNXB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIC5sZXR0ZXItcm93Om50aC1jaGlsZCg0KSBsaTpudGgtY2hpbGQoMikge1xuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDQ5cHgpIC8gMTApO1xuICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xuICB9XG5cbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciAubGV0dGVyLXJvdzpudGgtY2hpbGQoNCkgbGk6bnRoLWNoaWxkKDMpIHtcbiAgICB3aWR0aDogY2FsYygyICogKDEwMHZ3IC0gNDlweCkgLyA1ICsgMTVweCk7XG4gICAgZm9udC1zaXplOiAxNXB4O1xuICAgIC8qIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3RjcgKi9cbiAgfVxuXG4gIC5rZXlib2FyZC1wYW5lbC1sZXR0ZXIgdWwge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICB9XG5cbiAgLmtleWJvYXJkLXBhbmVsLWRlZmF1bHQge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIG1hcmdpbjogNHB4IDRweCAwIDRweDtcbiAgfVxuXG4gIC5rZXlib2FyZC1wYW5lbCB1bCB7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwgdWwgbGkge1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgaGVpZ2h0OiA0MnB4O1xuICAgIGxpbmUtaGVpZ2h0OiA0MnB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBjb2xvcjogIzBkMGQwZDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cblxuICAubGV0dGVyLXNoYWRlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDE7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwtbGV0dGVyIHVsIGxpIHtcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSA0OXB4KSAvIDEwKTtcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICB9XG5cbiAgLmtleWJvYXJkLXBhbmVsLWxldHRlciB1bCBsaTpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cblxuICAua2V5Ym9hcmQtcGFuZWwtZGVmYXVsdCB1bCBsaSB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcbiAgICBtYXJnaW4tdG9wOiA0cHg7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wge1xuICAgIHdpZHRoOiBjYWxjKCgxMDB2dyAtIDE2cHgpIC8gMyk7XG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wgPiB1bCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0Y3RjdGNztcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wgdWwgbGk6bnRoLWNoaWxkKDJuKSB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xuICB9XG5cbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sID4gdWwgbGk6bnRoLWNoaWxkKDEpIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLmtleWJvYXJkLWRlZmF1bHQtc3ltYm9sID4gdWwgbGk6bnRoLWNoaWxkKDIpIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLmtleWJvYXJkLXBhbmVsIGxpIGltZyB7XG4gICAgdG9wOiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgbWF4LWhlaWdodDogNDJweDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMDtcbiAgICBsZWZ0OiA1MCU7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wtYm90dG9tIHVsIGxpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjFGMUYxO1xuICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMTZweCkgLyAyKTtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICB3aWR0aDogY2FsYygoKDEwMHZ3IC0gMjBweCkgLyAyIC0gOHB4KSAvIDMpO1xuICB9XG5cbiAgLmtleWJvYXJkLWRlZmF1bHQtbnVtIHVsIGxpOm50aC1jaGlsZCgxKSB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoMikge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDMpIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoNikge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoOSkge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LW51bSB1bCBsaTpudGgtY2hpbGQoMTEpIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cblxuICAua2V5Ym9hcmQtZGVmYXVsdC1udW0gdWwgbGk6bnRoLWNoaWxkKDEwKSB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjhweCkgLyAzICsgM3B4KTtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LXJpZ2h0IHtcbiAgICB3aWR0aDogY2FsYygoMTAwdncgLSAxNnB4KSAvIDYgLSAycHgpO1xuICAgIGZsb2F0OiByaWdodDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgfVxuXG4gIC5rZXlib2FyZC1kZWZhdWx0LXJpZ2h0IHVsIGxpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjdGN0Y3O1xuICB9XG5cbiAgLmtleWJvYXJkLXN5bWJvbC1sZWZ0ID4gdWwge1xuICAgIGhlaWdodDogMTQ2cHg7XG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICB9XG5cbiAgLmtleWJvYXJkLXBhbmVsLXN5bWJvbCB1bCBsaSB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gMjlweCkgLyA2KTtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIG1hcmdpbi1yaWdodDogNXB4O1xuICB9XG5cbiAgLmtleWJvYXJkLXN5bWJvbC1sZWZ0IHVsIGxpOm50aC1jaGlsZCg1bikge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuXG4gIC5rZXlib2FyZC1zeW1ib2wtbGVmdCAua2V5Ym9hcmQtZGVmYXVsdC1zeW1ib2wtYm90dG9tIHVsIGxpOm50aC1jaGlsZCgzKSB7XG4gICAgd2lkdGg6IGNhbGMoKDEwMHZ3IC0gOXB4KSAvIDIpO1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICB9XG5cbiAgLmtleWJvYXJkLWZ1bmMgaW1nIHtcbiAgICBoZWlnaHQ6IDM2cHg7XG4gIH1cblxuICAua2V5Ym9hcmQtZnVuYy1pY29uOmxhc3QtY2hpbGQgaW1nIHtcbiAgICBoZWlnaHQ6IDI4cHg7XG4gICAgbWFyZ2luLXRvcDogNHB4O1xuICB9XG5cbjwvc3R5bGU+XG5cbjxzdHlsZT5cbiAgLmtleWJvYXJkIHRleHRhcmVhIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cblxuICAubWF0aHZpZXcgdGV4dGFyZWEge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuXG5cbjwvc3R5bGU+XG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwia2V5Ym9hcmRcIiwgYXR0cnM6IHsgaWQ6IFwia2V5Ym9hcmRcIiB9IH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImtleWJvYXJkLW91dHB1dFwiIH0sIFtcbiAgICAgIF9jKFwic3BhblwiLCB7XG4gICAgICAgIGF0dHJzOiB7IGlkOiBfdm0ubWF0aGlucHV0IH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3ZtLmN1cnNvckRvd24oJGV2ZW50KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG91Y2htb3ZlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdm0uY3Vyc29yTW92ZSgkZXZlbnQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b3VjaHVwOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdm0uY3Vyc29yVXAoJGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZWZ0LXJpZ2h0XCIgfSwgW1xuICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgYXR0cnM6IHsgc3JjOiBfdm0uaW1nLmN1cnNvcl9sZWZ0IH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF92bS5jdXJzb3JMZWZ0KCRldmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJtYXJnaW4tbGVmdFwiOiBcIjIwcHhcIiB9LFxuICAgICAgICAgIGF0dHJzOiB7IHNyYzogX3ZtLmltZy5jdXJzb3JfcmlnaHQgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3ZtLmN1cnNvclJpZ2h0KCRldmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJhXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNTdHlsZTogeyB3aWR0aDogXCIxNSVcIiB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdm0ua2V5aGlkZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbX3ZtLl92KFwi56Gu5a6aXCIpXVxuICAgICAgKVxuICAgIF0pLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJrZXlib2FyZC1wYW5lbFwiLFxuICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiBfdm0ua2V5b3J3cml0ZSA9PT0gMSA/IFwidW5zZXRcIiA6IFwibm9uZVwiIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIF92bS5wYW5lbCA9PT0gMVxuICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJrZXlib2FyZC1wYW5lbC1kZWZhdWx0XCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImtleWJvYXJkLWRlZmF1bHQtc3ltYm9sXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJ1bFwiLFxuICAgICAgICAgICAgICAgICAgX3ZtLl9sKF92bS5rZXlzeW0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogaXRlbS50ID8gXCIjYmFiYWJhXCIgOiBcIiNGN0Y3RjdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmluc2VydGFyKGl0ZW0udilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXR0ZXItc2hhZGVcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfYyhcImltZ1wiLCB7IGF0dHJzOiB7IHNyYzogaXRlbS5pIH0gfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoaXRlbS5rKSArIFwiXFxuICAgICAgICAgIFwiKVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJrZXlib2FyZC1kZWZhdWx0LW51bVwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0ua2V5bnVtLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGl0ZW0udCA/IFwiI2JhYmFiYVwiIDogXCIjZmZmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5pbnNlcnRhcihpdGVtLnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKGl0ZW0uaykgKyBcIlxcbiAgICAgICAgICBcIildXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwia2V5Ym9hcmQtZGVmYXVsdC1yaWdodFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiNGN0Y3RjdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmJhY2tEb3duKFwiQmFja3NwYWNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmJhY2tVcChcIkJhY2tzcGFjZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBbX2MoXCJpbWdcIiwgeyBhdHRyczogeyBzcmM6IF92bS5pbWcuYmFjayB9IH0pXVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmtleWJvYXJkUmlnaHQsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGl0ZW0udCA/IFwiI2JhYmFiYVwiIDogXCIjRjdGN0Y3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmluc2VydGFyKGl0ZW0udilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV0dGVyLXNoYWRlXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJpbWdcIiwgeyBhdHRyczogeyBzcmM6IGl0ZW0uaSB9IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhpdGVtLmspICsgXCJcXG4gICAgICAgICAgXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5wYW5lbCA9PT0gM1xuICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwia2V5Ym9hcmQtcGFuZWwtbGV0dGVyXCIgfSxcbiAgICAgICAgICAgICAgX3ZtLl9sKF92bS5rZXlhYmNbX3ZtLmNhcHNsZXR0ZXJdLCBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImxldHRlci1yb3dcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJ1bFwiLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX2woaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udiAhPT0gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW0udiAhPT0gXCJCYWNrc3BhY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBpdGVtLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiNiYWJhYmFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiI2ZmZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBpdGVtLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiNmZmZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiI0Y3RjdGN1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGl0ZW0uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIiNmZmZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiNGN0Y3RjdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udiAhPT0gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXRlbS52ICE9PSBcIkJhY2tzcGFjZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfdm0uaW5zZXJ0YXIoaXRlbS52KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5jYXBzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyhpdGVtLnQgPSB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmJhY2tEb3duKGl0ZW0udiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udiA9PT0gXCJCYWNrc3BhY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGl0ZW0uaSA9IF92bS5pbWcuZGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7KGl0ZW0udCA9IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmJhY2tVcChpdGVtLnYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnYgPT09IFwiQmFja3NwYWNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChpdGVtLmkgPSBfdm0uaW1nLmJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImxldHRlci1zaGFkZVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwiaW1nXCIsIHsgYXR0cnM6IHsgc3JjOiBpdGVtLmkgfSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoaXRlbS5rKSArIFwiXFxuICAgICAgICAgIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwia2V5Ym9hcmQtYm90dG9tXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ1bFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJmb250LXNpemVcIjogXCIxNHB4XCIgfSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmNoYW5nZXBhbmVsKF92bS5wYW5lbCA9PT0gMSA/IDMgOiAxKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhfdm0ucGFuZWwgPT09IDEgPyBcImFiY1wiIDogXCIxMjNcIikgKyBcIlxcbiAgICAgICAgXCIpXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uX2woX3ZtLmtleUJvdHRvbVN5bSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogaXRlbS50ID8gXCIjYmFiYWJhXCIgOiBcIiNGN0Y3RjdcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udiA9PT0gXCJoaWRlXCIgPyBfdm0ua2V5aGlkZSgpIDogX3ZtLmluc2VydGFyKGl0ZW0udilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV0dGVyLXNoYWRlXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaSA/IF9jKFwiaW1nXCIsIHsgYXR0cnM6IHsgc3JjOiBpdGVtLmkgfSB9KSA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKGl0ZW0uaykgKyBcIlxcbiAgICAgICAgXCIpXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICBdXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNzhlMDkyZTRcIiwgeyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfSlcbiAgfVxufSIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoY29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc4ZTA5MmU0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4va2V5Ym9hcmQudnVlXCIpXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MSEuL2tleWJvYXJkLnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9rZXlib2FyZC52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2tleWJvYXJkLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IHtyZW5kZXIgYXMgX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZucyBhcyBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19ffSBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03OGUwOTJlNFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6dHJ1ZSxcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2tleWJvYXJkLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBcImRhdGEtdi03OGUwOTJlNFwiXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyY1xcXFxsaWJcXFxca2V5Ym9hcmQudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTc4ZTA5MmU0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzhlMDkyZTRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwiPHRlbXBsYXRlID5cbiAgPGRpdiBjbGFzcz1cIm1hdGgtcmVuZGVyXCI+XG4gICAgPHNwYW4gOmlkPVwibWF0aHZpZXdcIiBjbGFzcz1cIm1hdGh2aWV3XCI+PC9zcGFuPlxuICAgIDxpbWcgOnNyYz1cImltZy5wZW5pY29uXCIgdi1pZj1cImltZ3Nob3cgJiYgIXZhbHVlXCIvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IFwibWF0aHF1aWxsL2J1aWxkL21hdGhxdWlsbFwiO1xuICAgIGltcG9ydCBpbWcgZnJvbSAnLi9pbWcuanMnXG5cbiAgICBleHBvcnQgZGVmYXVsdCB7XG4gICAgICAgIG5hbWU6IFwibWF0aC1yZW5kZXJcIixcbiAgICAgICAgZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICAgICAgbWF0aHZpZXc6ICdtYXRodmlldycgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogKDk5OTk5OSAtIDEwMDAwMCArIDEpICsgMTAwMDAwLCAxMCksXG4gICAgICAgICAgICAgICAgdmlld0ZpZWxkOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nLFxuICAgICAgICAgICAgaW1nc2hvdzoge1xuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG1hdGh2aWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tYXRodmlldyk7XG5cbiAgICAgICAgICAgIHZhciBNUSA9IE1hdGhRdWlsbC5nZXRJbnRlcmZhY2UoMik7XG5cbiAgICAgICAgICAgIHZhciB2aWV3RmllbGQgPSB0aGF0LnZpZXdGaWVsZCA9IE1RLk1hdGhGaWVsZChtYXRodmlldyk7XG5cbiAgICAgICAgICAgIHZpZXdGaWVsZC5sYXRleCh0aGF0LnZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICB3YXRjaDoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdGaWVsZC5sYXRleCh2YWwpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICRBcHAub3V0cHV0TGF0ZXgoJyQnICsgdmFsICsgJyQnKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG4gIC5tYXRodmlldyB7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBncmF5O1xuICAgIG1pbi13aWR0aDogNDVweDtcbiAgICBtaW4taGVpZ2h0OiAyMnB4O1xuICB9XG5cbiAgLm1hdGgtcmVuZGVyIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gIH1cblxuICAubWF0aC1yZW5kZXIgaW1nIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMTBweDtcbiAgICB0b3A6IDA7XG4gICAgaGVpZ2h0OiAyNHB4O1xuICB9XG48L3N0eWxlPlxuXG48c3R5bGU+XG4gIC5tYXRodmlldyB0ZXh0YXJlYSB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICB9XG5cbiAgLm1hdGh2aWV3IC5tcS1jdXJzb3Ige1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxuPC9zdHlsZT5cbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtYXRoLXJlbmRlclwiIH0sIFtcbiAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJtYXRodmlld1wiLCBhdHRyczogeyBpZDogX3ZtLm1hdGh2aWV3IH0gfSksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfdm0uaW1nc2hvdyAmJiAhX3ZtLnZhbHVlXG4gICAgICA/IF9jKFwiaW1nXCIsIHsgYXR0cnM6IHsgc3JjOiBfdm0uaW1nLnBlbmljb24gfSB9KVxuICAgICAgOiBfdm0uX2UoKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMWFmZmE2NTNcIiwgeyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfSlcbiAgfVxufSIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoY29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFhZmZhNjUzXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vcmVuZGVyLnZ1ZVwiKVxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTEhLi9yZW5kZXIudnVlXCIpXG59XG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3JlbmRlci52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3JlbmRlci52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWFmZmE2NTNcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZW5kZXIudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IFwiZGF0YS12LTFhZmZhNjUzXCJcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG5pbXBvcnQgbm9ybWFsaXplQ29tcG9uZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50LW5vcm1hbGl6ZXJcIlxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3JlbmRlcl9fLFxuICBfX3Z1ZV9zdGF0aWNfcmVuZGVyX2Zuc19fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjXFxcXGxpYlxcXFxyZW5kZXIudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTFhZmZhNjUzXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMWFmZmE2NTNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwiaW1wb3J0ICdtYXRocXVpbGwvYnVpbGQvbWF0aHF1aWxsLmNzcydcclxuaW1wb3J0IE1hdGhLZXlib2FyZCBmcm9tICcuL2tleWJvYXJkLnZ1ZScgLy8g5a+85YWl57uE5Lu2XHJcbmltcG9ydCBNYXRoUmVuZGVyIGZyb20gJy4vcmVuZGVyLnZ1ZSdcclxuY29uc3QgbWF0aGtleWJvYXJkID0ge1xyXG4gICAgaW5zdGFsbCAoVnVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgVnVlLmNvbXBvbmVudChNYXRoS2V5Ym9hcmQubmFtZSwgTWF0aEtleWJvYXJkKSAgLy8gdnVlUGF5S2V5Ym9hcmQubmFtZSDnu4Tku7bnmoRuYW1l5bGe5oCnXHJcbiAgICAgICAgVnVlLmNvbXBvbmVudChNYXRoUmVuZGVyLm5hbWUsIE1hdGhSZW5kZXIpIFxyXG4gICAgICAgLy8g57G75Ly86YCa6L+HIHRoaXMuJHh4eCDmlrnlvI/osIPnlKjmj5Lku7bnmoQg5YW25a6e5Y+q5piv5oyC6L295Yiw5Y6f5Z6L5LiK6ICM5beyXHJcbiAgICAgICAvLyBWdWUucHJvdG90eXBlLiR4eHggIC8vIOacgOe7iOWPr+S7peWcqOS7u+S9leWcsOaWuemAmui/hyB0aGlzLiR4eHgg6LCD55SoXHJcbiAgICAgICAvLyDomb3nhLbmsqHmnInmmI7noa7op4TlrprnlKgk5byA5aS0ICDkvYbmmK/lpKflrrbpg73pu5jorqTpgbXlrojov5nkuKrop4TlrppcclxuICAgIH1cclxufVxyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcclxuICAgIHdpbmRvdy5WdWUudXNlKG1hdGhrZXlib2FyZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1hdGhrZXlib2FyZCAvLyDlr7zlh7ouLiIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLnZ1ZSdcclxuaW1wb3J0IE1hdGhLZXlib2FyZCBmcm9tICcuL2xpYi9pbmRleC5qcydcclxuVnVlLnVzZShNYXRoS2V5Ym9hcmQpXHJcblxyXG5uZXcgVnVlKHtcclxuICBlbDogJyNhcHAnLFxyXG4gIHJlbmRlcjogaCA9PiBoKEFwcClcclxufSlcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n")}]);